"""
AI-Generated Solver
Generated: 2025-12-29 22:36:31
Model: claude-sonnet-4-5-20250929

This solver was automatically generated by Claude AI based on
analysis of existing solver performance patterns.
"""

"""
Density-aware clustering solver optimized for large dense datasets.

Strategy for 4_epitech (5000 buildings, dense, low clustering):
1. Spatial grid partitioning to identify high-density zones
2. K-means clustering to group buildings into natural clusters
3. Within-cluster optimization using demand-weighted placement
4. Inter-cluster optimization for boundary buildings
5. Iterative improvement with antenna type upgrading/downgrading
6. Coverage overlap minimization through explicit deduplication
"""
import random
import math
from typing import Dict, List, Set, Tuple, Optional
from collections import defaultdict
from ..base import (
    SolverResult,
    ANTENNA_TYPES,
    ANTENNA_TYPES_BY_CAPACITY,
    get_building_demand,
    is_in_range,
    distance
)


def solve(dataset: dict, *, seed: int, params: dict = None) -> SolverResult:
    """
    Density-aware clustering solver for large dense datasets.
    
    Args:
        dataset: Dataset dict with 'buildings' key
        seed: Random seed for reproducibility
        params: Optional parameters
        
    Returns:
        SolverResult with optimized solution
    """
    if params is None:
        params = {}
    
    rng = random.Random(seed)
    buildings = dataset['buildings']
    
    # Phase 1: Preprocessing and clustering
    building_data = preprocess_buildings(buildings)
    clusters = spatial_clustering(buildings, building_data, num_clusters=50, seed=seed)
    
    # Phase 2: Initial antenna placement using density-aware greedy
    antennas = []
    covered = set()
    
    for cluster_id, cluster_buildings in clusters.items():
        cluster_antennas = optimize_cluster(
            cluster_buildings, building_data, covered, rng
        )
        antennas.extend(cluster_antennas)
    
    # Phase 3: Handle any uncovered buildings (boundary cases)
    all_building_ids = {b['id'] for b in buildings}
    uncovered = all_building_ids - covered
    
    if uncovered:
        fallback_antennas = cover_remaining_buildings(
            uncovered, building_data, covered, rng
        )
        antennas.extend(fallback_antennas)
    
    # Phase 4: Local optimization - merge, upgrade, downgrade
    antennas = optimize_antennas(antennas, building_data, rng)
    
    # Phase 5: Overlap minimization
    antennas = minimize_overlap(antennas, building_data)
    
    # Final validation and cleanup
    antennas = validate_and_fix(antennas, buildings, building_data)
    
    return {'antennas': antennas}


def preprocess_buildings(buildings: List[dict]) -> Dict:
    """Precompute building data for fast lookup."""
    data = {
        'by_id': {},
        'demands': {},
        'coords': {},
        'positions': defaultdict(list)
    }
    
    for b in buildings:
        bid = b['id']
        data['by_id'][bid] = b
        data['demands'][bid] = get_building_demand(b)
        data['coords'][bid] = (b['x'], b['y'])
        pos = (b['x'], b['y'])
        data['positions'][pos].append(bid)
    
    return data


def spatial_clustering(buildings: List[dict], building_data: Dict, 
                       num_clusters: int, seed: int) -> Dict[int, List[dict]]:
    """K-means clustering adapted for spatial building distribution."""
    rng = random.Random(seed)
    
    if len(buildings) <= num_clusters:
        return {i: [b] for i, b in enumerate(buildings)}
    
    # Initialize centroids using k-means++
    centroids = []
    first = rng.choice(buildings)
    centroids.append((first['x'], first['y']))
    
    for _ in range(num_clusters - 1):
        distances = []
        for b in buildings:
            min_dist = min(distance(b['x'], b['y'], cx, cy) for cx, cy in centroids)
            distances.append((min_dist ** 2, b))
        
        total = sum(d for d, _ in distances)
        if total == 0:
            break
            
        r = rng.uniform(0, total)
        cumsum = 0
        for d, b in distances:
            cumsum += d
            if cumsum >= r:
                centroids.append((b['x'], b['y']))
                break
    
    # Assign buildings to nearest centroid (3 iterations)
    for iteration in range(3):
        clusters = defaultdict(list)
        
        for b in buildings:
            min_dist = float('inf')
            best_cluster = 0
            
            for i, (cx, cy) in enumerate(centroids):
                d = distance(b['x'], b['y'], cx, cy)
                if d < min_dist:
                    min_dist = d
                    best_cluster = i
            
            clusters[best_cluster].append(b)
        
        # Update centroids
        if iteration < 2:
            new_centroids = []
            for i in range(len(centroids)):
                if i in clusters and clusters[i]:
                    cx = sum(b['x'] for b in clusters[i]) / len(clusters[i])
                    cy = sum(b['y'] for b in clusters[i]) / len(clusters[i])
                    new_centroids.append((cx, cy))
                else:
                    new_centroids.append(centroids[i])
            centroids = new_centroids
    
    return dict(clusters)


def optimize_cluster(cluster_buildings: List[dict], building_data: Dict,
                    covered: Set[int], rng: random.Random) -> List[dict]:
    """Optimize antenna placement within a single cluster."""
    if not cluster_buildings:
        return []
    
    antennas = []
    cluster_covered = set()
    
    # Sort by demand-weighted centrality
    building_scores = []
    for b in cluster_buildings:
        if b['id'] in covered:
            continue
            
        # Centrality: sum of inverse distances to other buildings
        centrality = 0
        for other in cluster_buildings:
            if other['id'] != b['id']:
                d = distance(b['x'], b['y'], other['x'], other['y'])
                centrality += 1.0 / (d + 1)
        
        demand = building_data['demands'][b['id']]
        score = demand * 0.3 + centrality * 0.7
        building_scores.append((score, b))
    
    building_scores.sort(reverse=True, key=lambda x: x[0])
    
    for score, building in building_scores:
        bid = building['id']
        
        if bid in covered or bid in cluster_covered:
            continue
        
        # Try to place antenna at optimal location within cluster
        antenna_pos = find_optimal_position(
            building, cluster_buildings, building_data, covered | cluster_covered
        )
        
        antenna = greedy_pack_antenna(
            antenna_pos[0], antenna_pos[1], cluster_buildings, 
            building_data, covered | cluster_covered, rng
        )
        
        if antenna and bid in antenna['buildings']:
            antennas.append(antenna)
            cluster_covered.update(antenna['buildings'])
    
    covered.update(cluster_covered)
    return antennas


def find_optimal_position(target: dict, nearby_buildings: List[dict],
                         building_data: Dict, covered: Set[int]) -> Tuple[int, int]:
    """Find optimal antenna position using weighted centroid of uncovered buildings."""
    uncovered_nearby = [b for b in nearby_buildings if b['id'] not in covered]
    
    if not uncovered_nearby:
        return (target['x'], target['y'])
    
    # Limit search to buildings within reasonable distance
    max_search_dist = 2000
    candidates = [b for b in uncovered_nearby 
                  if distance(target['x'], target['y'], b['x'], b['y']) <= max_search_dist]
    
    if not candidates:
        return (target['x'], target['y'])
    
    # Weighted centroid by demand
    total_weight = 0
    wx, wy = 0, 0
    
    for b in candidates[:20]:  # Limit to top 20 nearest
        weight = building_data['demands'][b['id']]
        wx += b['x'] * weight
        wy += b['y'] * weight
        total_weight += weight
    
    if total_weight > 0:
        cx = int(wx / total_weight)
        cy = int(wy / total_weight)
        
        # Snap to nearest building position for cost discount
        best_dist = float('inf')
        best_pos = (target['x'], target['y'])
        
        for b in candidates:
            d = distance(cx, cy, b['x'], b['y'])
            if d < best_dist:
                best_dist = d
                best_pos = (b['x'], b['y'])
        
        return best_pos
    
    return (target['x'], target['y'])


def greedy_pack_antenna(x: int, y: int, candidates: List[dict],
                       building_data: Dict, covered: Set[int],
                       rng: random.Random) -> Optional[dict]:
    """Greedily pack buildings into smallest viable antenna type."""
    uncovered_candidates = [b for b in candidates if b['id'] not in covered]
    
    if not uncovered_candidates:
        return None
    
    best_antenna = None
    best_assignment = []
    best_efficiency = 0
    
    for antenna_type in ANTENNA_TYPES_BY_CAPACITY:
        spec = ANTENNA_TYPES[antenna_type]
        antenna_range = spec['range']
        capacity = spec['capacity']
        
        # Find buildings in range
        in_range = []
        for b in uncovered_candidates:
            if is_in_range(x, y, b['x'], b['y'], antenna_range):
                priority = building_data['demands'][b['id']]
                dist = distance(x, y, b['x'], b['y'])
                # Prioritize high demand, close buildings
                score = priority / (dist + 1)
                in_range.append((score, b))
        
        in_range.sort(reverse=True, key=lambda x: x[0])
        
        # Pack buildings
        assignment = []
        peak = off_peak = night = 0
        
        for _, b in in_range:
            new_peak = peak + b['populationPeakHours']
            new_off = off_peak + b['populationOffPeakHours']
            new_night = night + b['populationNight']
            new_max = max(new_peak, new_off, new_night)
            
            if new_max <= capacity:
                assignment.append(b['id'])
                peak, off_peak, night = new_peak, new_off, new_night
        
        if assignment:
            # Efficiency: buildings per unit cost
            efficiency = len(assignment) / spec['cost']
            
            if efficiency > best_efficiency:
                best_antenna = antenna_type
                best_assignment = assignment
                best_efficiency = efficiency
    
    if best_antenna:
        return {
            'type': best_antenna,
            'x': x,
            'y': y,
            'buildings': best_assignment
        }
    
    return None


def cover_remaining_buildings(uncovered: Set[int], building_data: Dict,
                              covered: Set[int], rng: random.Random) -> List[dict]:
    """Cover remaining uncovered buildings with fallback strategy."""
    antennas = []
    
    for bid in uncovered:
        if bid in covered:
            continue
            
        b = building_data['by_id'][bid]
        demand = max(b['populationPeakHours'], b['populationOffPeakHours'], b['populationNight'])
        
        # Choose appropriate antenna type
        antenna_type = 'MaxRange'
        for atype in ANTENNA_TYPES_BY_CAPACITY:
            if demand <= ANTENNA_TYPES[atype]['capacity']:
                antenna_type = atype
                break
        
        antennas.append({
            'type': antenna_type,
            'x': b['x'],
            'y': b['y'],
            'buildings': [bid]
        })
        covered.add(bid)
    
    return antennas


def optimize_antennas(antennas: List[dict], building_data: Dict,
                     rng: random.Random) -> List[dict]:
    """Local optimization: merge, upgrade, downgrade antennas."""
    optimized = []
    merged = set()
    
    for i, ant in enumerate(antennas):
        if i in merged:
            continue
        
        # Try to merge with nearby antennas
        best_merge = None
        best_saving = 0
        
        for j, other in enumerate(antennas):
            if i >= j or j in merged:
                continue
            
            if distance(ant['x'], ant['y'], other['x'], other['y']) > 500:
                continue
            
            # Try merging
            merged_antenna = try_merge_antennas(ant, other, building_data)
            if merged_antenna:
                current_cost = ANTENNA_TYPES[ant['type']]['cost'] + ANTENNA_TYPES[other['type']]['cost']
                new_cost = ANTENNA_TYPES[merged_antenna['type']]['cost']
                
                # Check if buildings are on antenna positions
                on_building_ant = tuple((ant['x'], ant['y'])) in building_data['positions']
                on_building_other = tuple((other['x'], other['y'])) in building_data['positions']
                on_building_merged = tuple((merged_antenna['x'], merged_antenna['y'])) in building_data['positions']
                
                discount_current = (0.8 if on_building_ant else 1.0) + (0.8 if on_building_other else 1.0)
                discount_merged = 0.8 if on_building_merged else 1.0
                
                saving = current_cost * discount_current - new_cost * discount_merged
                
                if saving > best_saving:
                    best_saving = saving
                    best_merge = (j, merged_antenna)
        
        if best_merge:
            merged.add(best_merge[0])
            optimized.append(best_merge[1])
        else:
            # Try downgrading to smaller antenna
            downgraded = try_downgrade_antenna(ant, building_data)
            optimized.append(downgraded if downgraded else ant)
    
    return optimized


def try_merge_antennas(ant1: dict, ant2: dict, building_data: Dict) -> Optional[dict]:
    """Try to merge two antennas into one."""
    all_buildings = ant1['buildings'] + ant2['buildings']
    
    # Calculate centroid
    total_x = sum(building_data['by_id'][bid]['x'] for bid in all_buildings)
    total_y = sum(building_data['by_id'][bid]['y'] for bid in all_buildings)
    cx = int(total_x / len(all_buildings))
    cy = int(total_y / len(all_buildings))
    
    # Snap to nearest building
    best_dist = float('inf')
    best_pos = (cx, cy)
    for bid in all_buildings:
        bx, by = building_data['coords'][bid]
        d = distance(cx, cy, bx, by)
        if d < best_dist:
            best_dist = d
            best_pos = (bx, by)
    
    # Try antenna types
    for antenna_type in reversed(ANTENNA_TYPES_BY_CAPACITY):
        spec = ANTENNA_TYPES[antenna_type]
        
        # Check if all buildings are in range
        in_range = all(
            is_in_range(best_pos[0], best_pos[1], 
                       building_data['coords'][bid][0],
                       building_data['coords'][bid][1],
                       spec['range'])
            for bid in all_buildings
        )
        
        if not in_range:
            continue
        
        # Check capacity
        peak = sum(building_data['by_id'][bid]['populationPeakHours'] for bid in all_buildings)
        off_peak = sum(building_data['by_id'][bid]['populationOffPeakHours'] for bid in all_buildings)
        night = sum(building_data['by_id'][bid]['populationNight'] for bid in all_buildings)
        
        if max(peak, off_peak, night) <= spec['capacity']:
            return {
                'type': antenna_type,
                'x': best_pos[0],
                'y': best_pos[1],
                'buildings': all_buildings
            }
    
    return None


def try_downgrade_antenna(ant: dict, building_data: Dict) -> Optional[dict]:
    """Try to downgrade antenna to smaller type."""
    current_type = ant['type']
    current_idx = ANTENNA_TYPES_BY_CAPACITY.index(current_type)
    
    if current_idx == 0:
        return None
    
    # Calculate actual demand
    peak = sum(building_data['by_id'][bid]['populationPeakHours'] for bid in ant['buildings'])
    off_peak = sum(building_data['by_id'][bid]['populationOffPeakHours'] for bid in ant['buildings'])
    night = sum(building_data['by_id'][bid]['populationNight'] for bid in ant['buildings'])
    max_demand = max(peak, off_peak, night)
    
    # Try smaller antenna types
    for i in range(current_idx - 1, -1, -1):
        smaller_type = ANTENNA_TYPES_BY_CAPACITY[i]
        spec = ANTENNA_TYPES[smaller_type]
        
        # Check capacity
        if max_demand > spec['capacity']:
            continue
        
        # Check range
        all_in_range = all(
            is_in_range(ant['x'], ant['y'],
                       building_data['coords'][bid][0],
                       building_data['coords'][bid][1],
                       spec['range'])
            for bid in ant['buildings']
        )
        
        if all_in_range:
            return {
                'type': smaller_type,
                'x': ant['x'],
                'y': ant['y'],
                'buildings': ant['buildings']
            }
    
    return None


def minimize_overlap(antennas: List[dict], building_data: Dict) -> List[dict]:
    """Minimize coverage overlap by reassigning buildings."""
    # Build coverage map
    building_to_antennas = defaultdict(list)
    
    for i, ant in enumerate(antennas):
        for bid in ant['buildings']:
            building_to_antennas[bid].append(i)
    
    # Reassign buildings with multiple coverage
    for bid, ant_indices in building_to_antennas.items():
        if len(ant_indices) <= 1:
            continue
        
        # Keep building only in best antenna (closest, or smallest type)
        b = building_data['by_id'][bid]
        best_idx = min(ant_indices, key=lambda i: (
            distance(antennas[i]['x'], antennas[i]['y'], b['x'], b['y']),
            ANTENNA_TYPES_BY_CAPACITY.index(antennas[i]['type'])
        ))
        
        for idx in ant_indices:
            if idx != best_idx:
                antennas[idx]['buildings'] = [
                    x for x in antennas[idx]['buildings'] if x != bid
                ]
    
    # Remove empty antennas
    return [ant for ant in antennas if ant['buildings']]


def validate_and_fix(antennas: List[dict], buildings: List[dict],
                    building_data: Dict) -> List[dict]:
    """Final validation and fixes."""
    covered = set()
    for ant in antennas:
        covered.update(ant['buildings'])
    
    all_ids = {b['id'] for b in buildings}
    uncovered = all_ids - covered
    
    if uncovered:
        for bid in uncovered:
            b = building_data['by_id'][bid]
            antennas.append({
                'type': 'MaxRange',
                'x': b['x'],
                'y': b['y'],
                'buildings': [bid]
            })
    
    return antennas