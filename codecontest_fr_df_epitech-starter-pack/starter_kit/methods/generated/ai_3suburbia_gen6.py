"""
AI-Generated Solver
Generated: 2025-12-29 22:31:00
Model: claude-sonnet-4-5-20250929

This solver was automatically generated by Claude AI based on
analysis of existing solver performance patterns.
"""

"""
Hybrid Voronoi-based solver optimized for low-clustering suburban distributions.

Strategy:
1. Use spatial partitioning to identify natural coverage regions
2. Apply capacity-constrained clustering with demand-aware centroids
3. Optimize antenna placement using weighted geometric centers
4. Iterative refinement: swap assignments and merge antennas
5. Final pass: attempt antenna downgrades and micro-optimizations
"""
import random
import math
from typing import Dict, List, Set, Tuple, Optional
from collections import defaultdict
from ..base import (
    SolverResult,
    ANTENNA_TYPES,
    ANTENNA_TYPES_BY_CAPACITY,
    get_building_demand,
    is_in_range,
    distance
)


def solve(dataset: dict, *, seed: int, params: dict = None) -> SolverResult:
    """
    Voronoi-based hybrid solver for suburban low-clustering scenarios.
    
    Args:
        dataset: Dataset dict with 'buildings' key
        seed: Random seed for reproducibility
        params: Optional parameters
        
    Returns:
        SolverResult with optimized antenna placement
    """
    rng = random.Random(seed)
    buildings = dataset['buildings']
    
    # Phase 1: Initial clustering using spatial partitioning
    clusters = spatial_demand_clustering(buildings, rng)
    
    # Phase 2: Generate initial antenna placement
    antennas = generate_initial_antennas(clusters, buildings, rng)
    
    # Phase 3: Local search optimization
    antennas = local_search_optimization(antennas, buildings, rng, iterations=50)
    
    # Phase 4: Antenna consolidation and downgrade
    antennas = consolidate_antennas(antennas, buildings, rng)
    
    # Phase 5: Final refinement
    antennas = final_refinement(antennas, buildings, rng)
    
    # Ensure all buildings covered
    antennas = ensure_coverage(antennas, buildings)
    
    return {'antennas': antennas}


def spatial_demand_clustering(buildings: List[dict], rng: random.Random) -> List[List[dict]]:
    """Create initial clusters using spatial grid with demand awareness."""
    if not buildings:
        return []
    
    # Find bounds
    min_x = min(b['x'] for b in buildings)
    max_x = max(b['x'] for b in buildings)
    min_y = min(b['y'] for b in buildings)
    max_y = max(b['y'] for b in buildings)
    
    # Determine grid size based on MaxRange antenna range
    max_range = ANTENNA_TYPES['MaxRange']['range']
    grid_size = max_range * 1.5
    
    # Create spatial grid
    grid = defaultdict(list)
    for b in buildings:
        grid_x = int((b['x'] - min_x) / grid_size)
        grid_y = int((b['y'] - min_y) / grid_size)
        grid[(grid_x, grid_y)].append(b)
    
    # Merge adjacent cells to create initial clusters
    clusters = []
    for cell_buildings in grid.values():
        if cell_buildings:
            clusters.append(cell_buildings)
    
    return clusters


def generate_initial_antennas(clusters: List[List[dict]], buildings: List[dict], 
                               rng: random.Random) -> List[dict]:
    """Generate initial antenna placement for each cluster."""
    antennas = []
    building_by_id = {b['id']: b for b in buildings}
    
    for cluster in clusters:
        if not cluster:
            continue
        
        # Calculate demand-weighted centroid
        total_demand = 0
        weighted_x = 0
        weighted_y = 0
        
        for b in cluster:
            demand = get_building_demand(b)
            total_demand += demand
            weighted_x += b['x'] * demand
            weighted_y += b['y'] * demand
        
        if total_demand > 0:
            centroid_x = int(weighted_x / total_demand)
            centroid_y = int(weighted_y / total_demand)
        else:
            centroid_x = int(sum(b['x'] for b in cluster) / len(cluster))
            centroid_y = int(sum(b['y'] for b in cluster) / len(cluster))
        
        # Find nearest building to centroid for antenna placement
        nearest_building = min(cluster, 
                              key=lambda b: distance(b['x'], b['y'], centroid_x, centroid_y))
        
        antenna_x = nearest_building['x']
        antenna_y = nearest_building['y']
        
        # Try to fit cluster into smallest possible antenna
        for antenna_type in ANTENNA_TYPES_BY_CAPACITY:
            antenna_spec = ANTENNA_TYPES[antenna_type]
            assignment = try_assign_buildings(antenna_x, antenna_y, cluster, 
                                             antenna_spec, building_by_id)
            
            if assignment:
                antennas.append({
                    'type': antenna_type,
                    'x': antenna_x,
                    'y': antenna_y,
                    'buildings': assignment
                })
                
                # Remove assigned buildings from cluster
                assigned_ids = set(assignment)
                cluster[:] = [b for b in cluster if b['id'] not in assigned_ids]
                break
        
        # Handle remaining buildings in cluster
        while cluster:
            # Pick building with highest demand
            b = max(cluster, key=lambda x: get_building_demand(x))
            
            for antenna_type in ANTENNA_TYPES_BY_CAPACITY:
                antenna_spec = ANTENNA_TYPES[antenna_type]
                assignment = try_assign_buildings(b['x'], b['y'], cluster,
                                                 antenna_spec, building_by_id)
                
                if assignment and b['id'] in assignment:
                    antennas.append({
                        'type': antenna_type,
                        'x': b['x'],
                        'y': b['y'],
                        'buildings': assignment
                    })
                    
                    assigned_ids = set(assignment)
                    cluster[:] = [x for x in cluster if x['id'] not in assigned_ids]
                    break
    
    return antennas


def try_assign_buildings(antenna_x: int, antenna_y: int, candidates: List[dict],
                        antenna_spec: dict, building_by_id: Dict[int, dict]) -> Optional[List[int]]:
    """Try to assign buildings to antenna respecting capacity and range."""
    antenna_range = antenna_spec['range']
    antenna_capacity = antenna_spec['capacity']
    
    # Filter by range
    in_range = [b for b in candidates 
                if is_in_range(antenna_x, antenna_y, b['x'], b['y'], antenna_range)]
    
    if not in_range:
        return None
    
    # Sort by demand (descending) for greedy packing
    in_range.sort(key=lambda b: get_building_demand(b), reverse=True)
    
    assignment = []
    total_peak = 0
    total_off_peak = 0
    total_night = 0
    
    for b in in_range:
        new_peak = total_peak + b['populationPeakHours']
        new_off_peak = total_off_peak + b['populationOffPeakHours']
        new_night = total_night + b['populationNight']
        new_max = max(new_peak, new_off_peak, new_night)
        
        if new_max <= antenna_capacity:
            assignment.append(b['id'])
            total_peak = new_peak
            total_off_peak = new_off_peak
            total_night = new_night
    
    return assignment if assignment else None


def local_search_optimization(antennas: List[dict], buildings: List[dict],
                              rng: random.Random, iterations: int = 50) -> List[dict]:
    """Apply local search to improve antenna placement."""
    building_by_id = {b['id']: b for b in buildings}
    
    for _ in range(iterations):
        # Try random improvements
        if not antennas:
            break
        
        idx = rng.randint(0, len(antennas) - 1)
        antenna = antennas[idx]
        
        # Try relocating antenna
        improved = try_relocate_antenna(antenna, building_by_id)
        if improved:
            antennas[idx] = improved
            continue
        
        # Try reassigning buildings between adjacent antennas
        if len(antennas) > 1:
            other_idx = rng.randint(0, len(antennas) - 1)
            if other_idx != idx:
                improved_pair = try_reassign_between(antenna, antennas[other_idx], building_by_id)
                if improved_pair:
                    antennas[idx] = improved_pair[0]
                    antennas[other_idx] = improved_pair[1]
    
    return antennas


def try_relocate_antenna(antenna: dict, building_by_id: Dict[int, dict]) -> Optional[dict]:
    """Try to relocate antenna to better position."""
    if not antenna['buildings']:
        return None
    
    assigned_buildings = [building_by_id[bid] for bid in antenna['buildings']]
    
    # Calculate optimal centroid
    total_demand = sum(get_building_demand(b) for b in assigned_buildings)
    if total_demand == 0:
        return None
    
    weighted_x = sum(b['x'] * get_building_demand(b) for b in assigned_buildings) / total_demand
    weighted_y = sum(b['y'] * get_building_demand(b) for b in assigned_buildings) / total_demand
    
    # Find nearest building to new centroid
    nearest = min(assigned_buildings,
                  key=lambda b: distance(b['x'], b['y'], int(weighted_x), int(weighted_y)))
    
    new_x, new_y = nearest['x'], nearest['y']
    
    # Check if all buildings still in range
    antenna_spec = ANTENNA_TYPES[antenna['type']]
    all_in_range = all(is_in_range(new_x, new_y, b['x'], b['y'], antenna_spec['range'])
                       for b in assigned_buildings)
    
    if all_in_range and (new_x != antenna['x'] or new_y != antenna['y']):
        return {
            'type': antenna['type'],
            'x': new_x,
            'y': new_y,
            'buildings': antenna['buildings'].copy()
        }
    
    return None


def try_reassign_between(ant1: dict, ant2: dict, building_by_id: Dict[int, dict]) -> Optional[Tuple[dict, dict]]:
    """Try to reassign buildings between two antennas."""
    spec1 = ANTENNA_TYPES[ant1['type']]
    spec2 = ANTENNA_TYPES[ant2['type']]
    
    # Find buildings that could be swapped
    for bid1 in ant1['buildings']:
        for bid2 in ant2['buildings']:
            b1 = building_by_id[bid1]
            b2 = building_by_id[bid2]
            
            # Check if swap is feasible
            if (is_in_range(ant1['x'], ant1['y'], b2['x'], b2['y'], spec1['range']) and
                is_in_range(ant2['x'], ant2['y'], b1['x'], b1['y'], spec2['range'])):
                
                # Try swap
                new_assign1 = [b for b in ant1['buildings'] if b != bid1] + [bid2]
                new_assign2 = [b for b in ant2['buildings'] if b != bid2] + [bid1]
                
                if (check_capacity(new_assign1, spec1['capacity'], building_by_id) and
                    check_capacity(new_assign2, spec2['capacity'], building_by_id)):
                    return (
                        {'type': ant1['type'], 'x': ant1['x'], 'y': ant1['y'], 'buildings': new_assign1},
                        {'type': ant2['type'], 'x': ant2['x'], 'y': ant2['y'], 'buildings': new_assign2}
                    )
    
    return None


def check_capacity(building_ids: List[int], capacity: int, building_by_id: Dict[int, dict]) -> bool:
    """Check if building assignment fits within capacity."""
    total_peak = sum(building_by_id[bid]['populationPeakHours'] for bid in building_ids)
    total_off_peak = sum(building_by_id[bid]['populationOffPeakHours'] for bid in building_ids)
    total_night = sum(building_by_id[bid]['populationNight'] for bid in building_ids)
    return max(total_peak, total_off_peak, total_night) <= capacity


def consolidate_antennas(antennas: List[dict], buildings: List[dict], rng: random.Random) -> List[dict]:
    """Try to merge antennas and downgrade types."""
    building_by_id = {b['id']: b for b in buildings}
    
    # Try to merge nearby antennas
    improved = True
    while improved:
        improved = False
        i = 0
        while i < len(antennas):
            j = i + 1
            while j < len(antennas):
                merged = try_merge_antennas(antennas[i], antennas[j], building_by_id)
                if merged:
                    antennas[i] = merged
                    antennas.pop(j)
                    improved = True
                    break
                j += 1
            i += 1
    
    # Try to downgrade antenna types
    for i in range(len(antennas)):
        downgraded = try_downgrade_antenna(antennas[i], building_by_id)
        if downgraded:
            antennas[i] = downgraded
    
    return antennas


def try_merge_antennas(ant1: dict, ant2: dict, building_by_id: Dict[int, dict]) -> Optional[dict]:
    """Try to merge two antennas into one."""
    all_buildings = list(set(ant1['buildings'] + ant2['buildings']))
    assigned_objs = [building_by_id[bid] for bid in all_buildings]
    
    # Calculate centroid
    if assigned_objs:
        avg_x = sum(b['x'] for b in assigned_objs) / len(assigned_objs)
        avg_y = sum(b['y'] for b in assigned_objs) / len(assigned_objs)
        nearest = min(assigned_objs, key=lambda b: distance(b['x'], b['y'], int(avg_x), int(avg_y)))
        merge_x, merge_y = nearest['x'], nearest['y']
    else:
        return None
    
    # Try each antenna type
    for antenna_type in ANTENNA_TYPES_BY_CAPACITY:
        spec = ANTENNA_TYPES[antenna_type]
        
        # Check range
        all_in_range = all(is_in_range(merge_x, merge_y, b['x'], b['y'], spec['range'])
                          for b in assigned_objs)
        
        if all_in_range and check_capacity(all_buildings, spec['capacity'], building_by_id):
            return {
                'type': antenna_type,
                'x': merge_x,
                'y': merge_y,
                'buildings': all_buildings
            }
    
    return None


def try_downgrade_antenna(antenna: dict, building_by_id: Dict[int, dict]) -> Optional[dict]:
    """Try to use a smaller antenna type."""
    current_idx = ANTENNA_TYPES_BY_CAPACITY.index(antenna['type'])
    
    for i in range(current_idx):
        smaller_type = ANTENNA_TYPES_BY_CAPACITY[i]
        spec = ANTENNA_TYPES[smaller_type]
        
        assigned_objs = [building_by_id[bid] for bid in antenna['buildings']]
        all_in_range = all(is_in_range(antenna['x'], antenna['y'], b['x'], b['y'], spec['range'])
                          for b in assigned_objs)
        
        if all_in_range and check_capacity(antenna['buildings'], spec['capacity'], building_by_id):
            return {
                'type': smaller_type,
                'x': antenna['x'],
                'y': antenna['y'],
                'buildings': antenna['buildings'].copy()
            }
    
    return None


def final_refinement(antennas: List[dict], buildings: List[dict], rng: random.Random) -> List[dict]:
    """Final optimization pass."""
    building_by_id = {b['id']: b for b in buildings}
    
    # Remove empty antennas
    antennas = [a for a in antennas if a['buildings']]
    
    # Try to add more buildings to existing antennas
    covered = set()
    for antenna in antennas:
        covered.update(antenna['buildings'])
    
    uncovered = [b for b in buildings if b['id'] not in covered]
    
    for antenna in antennas:
        spec = ANTENNA_TYPES[antenna['type']]
        for b in uncovered[:]:
            if is_in_range(antenna['x'], antenna['y'], b['x'], b['y'], spec['range']):
                test_assign = antenna['buildings'] + [b['id']]
                if check_capacity(test_assign, spec['capacity'], building_by_id):
                    antenna['buildings'] = test_assign
                    uncovered.remove(b)
                    covered.add(b['id'])
    
    return antennas


def ensure_coverage(antennas: List[dict], buildings: List[dict]) -> List[dict]:
    """Ensure all buildings are covered."""
    covered = set()
    for antenna in antennas:
        covered.update(antenna['buildings'])
    
    uncovered = [b for b in buildings if b['id'] not in covered]
    
    for b in uncovered:
        antennas.append({
            'type': 'MaxRange',
            'x': b['x'],
            'y': b['y'],
            'buildings': [b['id']]
        })
    
    return antennas