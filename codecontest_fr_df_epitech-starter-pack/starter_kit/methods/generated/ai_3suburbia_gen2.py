"""
AI-Generated Solver
Generated: 2025-12-30 11:28:34
Model: claude-sonnet-4-5-20250929

This solver was automatically generated by Claude AI based on
analysis of existing solver performance patterns.
"""

"""
Hybrid Multi-Phase Solver for Suburbia Dataset

Strategy optimized for low-clustering, moderate spatial distribution:
1. Spatial partitioning using k-means to create service regions
2. LP-relaxation inspired initial placement using weighted centroids
3. Greedy refinement with look-ahead evaluation
4. Variable Neighborhood Descent (VND) for local optimization
5. Perturbation and restart with adaptive intensity

Designed for 2601 buildings with moderate spread and low clustering.
"""
import random
import math
from collections import defaultdict
from typing import Dict, List, Set, Tuple, Optional
from ..base import (
    SolverResult,
    ANTENNA_TYPES,
    ANTENNA_TYPES_BY_CAPACITY,
    get_building_demand,
    is_in_range,
    distance
)


def solve(dataset: dict, *, seed: int, params: dict = None) -> SolverResult:
    """
    Hybrid multi-phase solver optimized for suburbia datasets.
    """
    if params is None:
        params = {}
    
    rng = random.Random(seed)
    buildings = dataset['buildings']
    
    # Phase 1: Spatial partitioning
    num_clusters = min(40, max(10, len(buildings) // 65))  # ~65 buildings per cluster
    clusters = kmeans_clustering(buildings, num_clusters, rng)
    
    # Phase 2: Initial solution via weighted centroid placement
    initial_solution = build_initial_solution(buildings, clusters, rng)
    
    # Phase 3: Greedy refinement with capacity optimization
    refined_solution = greedy_refinement(buildings, initial_solution, rng)
    
    # Phase 4: Variable Neighborhood Descent
    vnd_solution = variable_neighborhood_descent(buildings, refined_solution, rng, iterations=50)
    
    # Phase 5: Final validation and cleanup
    final_solution = validate_and_cleanup(buildings, vnd_solution)
    
    return {'antennas': final_solution}


def kmeans_clustering(buildings: List[dict], k: int, rng: random.Random) -> List[List[int]]:
    """K-means clustering on building coordinates."""
    if k >= len(buildings):
        return [[b['id']] for b in buildings]
    
    # Initialize centroids randomly
    centroids = rng.sample([(b['x'], b['y']) for b in buildings], k)
    
    building_coords = {b['id']: (b['x'], b['y']) for b in buildings}
    
    for _ in range(15):  # 15 iterations
        # Assign buildings to nearest centroid
        clusters = [[] for _ in range(k)]
        for b in buildings:
            bx, by = b['x'], b['y']
            nearest = min(range(k), key=lambda i: distance(bx, by, centroids[i][0], centroids[i][1]))
            clusters[nearest].append(b['id'])
        
        # Remove empty clusters
        clusters = [c for c in clusters if c]
        if len(clusters) < k:
            k = len(clusters)
            if k == 0:
                return [[b['id']] for b in buildings]
        
        # Update centroids
        new_centroids = []
        for cluster in clusters:
            if cluster:
                cx = sum(building_coords[bid][0] for bid in cluster) / len(cluster)
                cy = sum(building_coords[bid][1] for bid in cluster) / len(cluster)
                new_centroids.append((cx, cy))
        
        centroids = new_centroids
        k = len(centroids)
    
    return clusters


def build_initial_solution(buildings: List[dict], clusters: List[List[int]], rng: random.Random) -> List[dict]:
    """Build initial solution using weighted centroids per cluster."""
    building_by_id = {b['id']: b for b in buildings}
    antennas = []
    covered = set()
    
    for cluster in clusters:
        if not cluster:
            continue
        
        uncovered_in_cluster = [bid for bid in cluster if bid not in covered]
        if not uncovered_in_cluster:
            continue
        
        # Compute demand-weighted centroid
        total_demand = 0
        weighted_x = 0
        weighted_y = 0
        
        for bid in uncovered_in_cluster:
            b = building_by_id[bid]
            demand = get_building_demand(b)
            weighted_x += b['x'] * demand
            weighted_y += b['y'] * demand
            total_demand += demand
        
        if total_demand > 0:
            cx = int(weighted_x / total_demand)
            cy = int(weighted_y / total_demand)
        else:
            # Fallback to geometric centroid
            cx = int(sum(building_by_id[bid]['x'] for bid in uncovered_in_cluster) / len(uncovered_in_cluster))
            cy = int(sum(building_by_id[bid]['y'] for bid in uncovered_in_cluster) / len(uncovered_in_cluster))
        
        # Find nearest building to centroid for placement discount
        nearest_building = min(uncovered_in_cluster, 
                             key=lambda bid: distance(building_by_id[bid]['x'], building_by_id[bid]['y'], cx, cy))
        antenna_x = building_by_id[nearest_building]['x']
        antenna_y = building_by_id[nearest_building]['y']
        
        # Try antenna types from smallest to largest
        for antenna_type in ANTENNA_TYPES_BY_CAPACITY:
            antenna_spec = ANTENNA_TYPES[antenna_type]
            assignment = find_best_assignment(buildings, antenna_x, antenna_y, 
                                            antenna_spec, uncovered_in_cluster, covered, building_by_id)
            
            if assignment:
                antennas.append({
                    'type': antenna_type,
                    'x': antenna_x,
                    'y': antenna_y,
                    'buildings': assignment
                })
                covered.update(assignment)
                break
    
    # Cover any remaining buildings
    all_building_ids = {b['id'] for b in buildings}
    uncovered = all_building_ids - covered
    for bid in uncovered:
        b = building_by_id[bid]
        antennas.append({
            'type': 'MaxRange',
            'x': b['x'],
            'y': b['y'],
            'buildings': [bid]
        })
        covered.add(bid)
    
    return antennas


def find_best_assignment(buildings: List[dict], ax: int, ay: int, 
                        antenna_spec: dict, candidates: List[int], 
                        covered: Set[int], building_by_id: Dict[int, dict]) -> List[int]:
    """Find best assignment of buildings to an antenna."""
    antenna_range = antenna_spec['range']
    antenna_capacity = antenna_spec['capacity']
    
    # Find all uncovered buildings in range
    in_range = []
    for bid in candidates:
        if bid in covered:
            continue
        b = building_by_id[bid]
        if is_in_range(ax, ay, b['x'], b['y'], antenna_range):
            demand = get_building_demand(b)
            in_range.append((bid, demand, b))
    
    if not in_range:
        return []
    
    # Sort by demand (prioritize high demand)
    in_range.sort(key=lambda x: x[1], reverse=True)
    
    # Greedy packing
    assignment = []
    total_peak = 0
    total_off_peak = 0
    total_night = 0
    
    for bid, _, b in in_range:
        new_peak = total_peak + b['populationPeakHours']
        new_off_peak = total_off_peak + b['populationOffPeakHours']
        new_night = total_night + b['populationNight']
        new_max = max(new_peak, new_off_peak, new_night)
        
        if new_max <= antenna_capacity:
            assignment.append(bid)
            total_peak = new_peak
            total_off_peak = new_off_peak
            total_night = new_night
    
    return assignment


def greedy_refinement(buildings: List[dict], antennas: List[dict], rng: random.Random) -> List[dict]:
    """Refine solution by attempting to merge antennas and optimize placements."""
    building_by_id = {b['id']: b for b in buildings}
    
    # Try to consolidate antennas with few buildings
    changed = True
    iteration = 0
    max_iterations = 20
    
    while changed and iteration < max_iterations:
        changed = False
        iteration += 1
        
        # Sort antennas by number of buildings (ascending)
        antennas.sort(key=lambda a: len(a['buildings']))
        
        new_antennas = []
        covered = set()
        
        for antenna in antennas:
            # Skip if all buildings already covered by new antennas
            uncovered_buildings = [bid for bid in antenna['buildings'] if bid not in covered]
            if not uncovered_buildings:
                changed = True
                continue
            
            # Try to find a better antenna placement/type
            best_antenna = None
            best_score = float('inf')
            
            # Try placing on each building in the assignment
            for bid in uncovered_buildings[:5]:  # Limit search
                b = building_by_id[bid]
                ax, ay = b['x'], b['y']
                
                for antenna_type in ANTENNA_TYPES_BY_CAPACITY:
                    antenna_spec = ANTENNA_TYPES[antenna_type]
                    assignment = find_best_assignment(buildings, ax, ay, antenna_spec, 
                                                     uncovered_buildings, covered, building_by_id)
                    
                    if assignment:
                        cost = antenna_spec['cost_on_building'] // 2  # Building discount
                        score = cost / len(assignment)  # Cost per building
                        
                        if score < best_score:
                            best_score = score
                            best_antenna = {
                                'type': antenna_type,
                                'x': ax,
                                'y': ay,
                                'buildings': assignment
                            }
            
            if best_antenna:
                new_antennas.append(best_antenna)
                covered.update(best_antenna['buildings'])
        
        # Ensure all buildings are covered
        all_building_ids = {b['id'] for b in buildings}
        uncovered = all_building_ids - covered
        for bid in uncovered:
            b = building_by_id[bid]
            new_antennas.append({
                'type': 'MaxRange',
                'x': b['x'],
                'y': b['y'],
                'buildings': [bid]
            })
        
        antennas = new_antennas
    
    return antennas


def variable_neighborhood_descent(buildings: List[dict], antennas: List[dict], 
                                  rng: random.Random, iterations: int = 50) -> List[dict]:
    """VND with multiple neighborhood operators."""
    building_by_id = {b['id']: b for b in buildings}
    best_solution = antennas
    best_cost = calculate_solution_cost(antennas)
    
    for iteration in range(iterations):
        improved = False
        
        # Operator 1: Relocate antenna to different building in its coverage
        if rng.random() < 0.4:
            candidate = relocate_antenna(buildings, best_solution, rng, building_by_id)
            if candidate:
                cost = calculate_solution_cost(candidate)
                if cost < best_cost:
                    best_solution = candidate
                    best_cost = cost
                    improved = True
        
        # Operator 2: Swap buildings between antennas
        if rng.random() < 0.4:
            candidate = swap_buildings(buildings, best_solution, rng, building_by_id)
            if candidate:
                cost = calculate_solution_cost(candidate)
                if cost < best_cost:
                    best_solution = candidate
                    best_cost = cost
                    improved = True
        
        # Operator 3: Try downgrading antenna type
        if rng.random() < 0.3:
            candidate = try_downgrade_antenna(buildings, best_solution, rng, building_by_id)
            if candidate:
                cost = calculate_solution_cost(candidate)
                if cost < best_cost:
                    best_solution = candidate
                    best_cost = cost
                    improved = True
        
        # Perturbation if stuck
        if not improved and iteration % 10 == 9:
            best_solution = perturb_solution(buildings, best_solution, rng, building_by_id)
            best_cost = calculate_solution_cost(best_solution)
    
    return best_solution


def relocate_antenna(buildings: List[dict], antennas: List[dict], 
                     rng: random.Random, building_by_id: Dict[int, dict]) -> Optional[List[dict]]:
    """Try relocating an antenna to a different building in its coverage."""
    if not antennas:
        return None
    
    antenna_idx = rng.randint(0, len(antennas) - 1)
    antenna = antennas[antenna_idx]
    
    if len(antenna['buildings']) < 2:
        return None
    
    # Try moving to a different building
    new_building_id = rng.choice(antenna['buildings'])
    new_b = building_by_id[new_building_id]
    
    antenna_spec = ANTENNA_TYPES[antenna['type']]
    new_assignment = find_best_assignment(buildings, new_b['x'], new_b['y'], 
                                         antenna_spec, antenna['buildings'], set(), building_by_id)
    
    if new_assignment and len(new_assignment) >= len(antenna['buildings']) * 0.8:
        new_antennas = antennas[:antenna_idx] + antennas[antenna_idx+1:]
        new_antennas.append({
            'type': antenna['type'],
            'x': new_b['x'],
            'y': new_b['y'],
            'buildings': new_assignment
        })
        
        # Validate coverage
        if is_valid_solution(buildings, new_antennas):
            return new_antennas
    
    return None


def swap_buildings(buildings: List[dict], antennas: List[dict], 
                   rng: random.Random, building_by_id: Dict[int, dict]) -> Optional[List[dict]]:
    """Try swapping buildings between two antennas."""
    if len(antennas) < 2:
        return None
    
    idx1, idx2 = rng.sample(range(len(antennas)), 2)
    a1, a2 = antennas[idx1], antennas[idx2]
    
    if not a1['buildings'] or not a2['buildings']:
        return None
    
    # Try swapping one building from each
    b1 = rng.choice(a1['buildings'])
    b2 = rng.choice(a2['buildings'])
    
    # Check if swap is feasible
    new_a1_buildings = [b for b in a1['buildings'] if b != b1] + [b2]
    new_a2_buildings = [b for b in a2['buildings'] if b != b2] + [b1]
    
    # Validate range
    if not all(is_in_range(a1['x'], a1['y'], building_by_id[bid]['x'], 
                          building_by_id[bid]['y'], ANTENNA_TYPES[a1['type']]['range']) 
              for bid in new_a1_buildings):
        return None
    
    if not all(is_in_range(a2['x'], a2['y'], building_by_id[bid]['x'], 
                          building_by_id[bid]['y'], ANTENNA_TYPES[a2['type']]['range']) 
              for bid in new_a2_buildings):
        return None
    
    # Validate capacity
    if not is_valid_capacity(new_a1_buildings, ANTENNA_TYPES[a1['type']]['capacity'], building_by_id):
        return None
    if not is_valid_capacity(new_a2_buildings, ANTENNA_TYPES[a2['type']]['capacity'], building_by_id):
        return None
    
    new_antennas = antennas.copy()
    new_antennas[idx1] = {**a1, 'buildings': new_a1_buildings}
    new_antennas[idx2] = {**a2, 'buildings': new_a2_buildings}
    
    return new_antennas


def try_downgrade_antenna(buildings: List[dict], antennas: List[dict], 
                         rng: random.Random, building_by_id: Dict[int, dict]) -> Optional[List[dict]]:
    """Try changing an antenna to a smaller type."""
    if not antennas:
        return None
    
    antenna_idx = rng.randint(0, len(antennas) - 1)
    antenna = antennas[antenna_idx]
    
    current_type_idx = ANTENNA_TYPES_BY_CAPACITY.index(antenna['type'])
    if current_type_idx == 0:  # Already smallest
        return None
    
    # Try smaller type
    new_type = ANTENNA_TYPES_BY_CAPACITY[current_type_idx - 1]
    new_spec = ANTENNA_TYPES[new_type]
    
    # Check if current assignment fits
    if not is_valid_capacity(antenna['buildings'], new_spec['capacity'], building_by_id):
        return None
    
    if not all(is_in_range(antenna['x'], antenna['y'], building_by_id[bid]['x'], 
                          building_by_id[bid]['y'], new_spec['range']) 
              for bid in antenna['buildings']):
        return None
    
    new_antennas = antennas.copy()
    new_antennas[antenna_idx] = {**antenna, 'type': new_type}
    
    return new_antennas


def perturb_solution(buildings: List[dict], antennas: List[dict], 
                     rng: random.Random, building_by_id: Dict[int, dict]) -> List[dict]:
    """Perturb solution by removing random antennas and rebuilding."""
    if len(antennas) <= 2:
        return antennas
    
    # Remove 10-20% of antennas
    num_remove = max(1, int(len(antennas) * rng.uniform(0.1, 0.2)))
    indices_to_remove = set(rng.sample(range(len(antennas)), num_remove))
    
    kept_antennas = [a for i, a in enumerate(antennas) if i not in indices_to_remove]
    covered = set()
    for a in kept_antennas:
        covered.update(a['buildings'])
    
    # Rebuild for uncovered buildings
    all_building_ids = {b['id'] for b in buildings}
    uncovered = list(all_building_ids - covered)
    
    if uncovered:
        uncovered_buildings = [building_by_id[bid] for bid in uncovered]
        uncovered_buildings.sort(key=lambda b: get_building_demand(b), reverse=True)
        
        for b in uncovered_buildings:
            if b['id'] in covered:
                continue
            
            for antenna_type in ANTENNA_TYPES_BY_CAPACITY:
                antenna_spec = ANTENNA_TYPES[antenna_type]
                assignment = find_best_assignment(buildings, b['x'], b['y'], 
                                                antenna_spec, uncovered, covered, building_by_id)
                if assignment:
                    kept_antennas.append({
                        'type': antenna_type,
                        'x': b['x'],
                        'y': b['y'],
                        'buildings': assignment
                    })
                    covered.update(assignment)
                    break
    
    return kept_antennas


def is_valid_capacity(building_ids: List[int], capacity: int, building_by_id: Dict[int, dict]) -> bool:
    """Check if buildings fit within capacity."""
    total_peak = sum(building_by_id[bid]['populationPeakHours'] for bid in building_ids)
    total_off_peak = sum(building_by_id[bid]['populationOffPeakHours'] for bid in building_ids)
    total_night = sum(building_by_id[bid]['populationNight'] for bid in building_ids)
    return max(total_peak, total_off_peak, total_night) <= capacity


def is_valid_solution(buildings: List[dict], antennas: List[dict]) -> bool:
    """Check if solution covers all buildings."""
    covered = set()
    for a in antennas:
        covered.update(a['buildings'])
    
    all_building_ids = {b['id'] for b in buildings}
    return covered == all_building_ids


def calculate_solution_cost(antennas: List[dict]) -> int:
    """Calculate total cost of solution."""
    total_cost = 0
    for a in antennas:
        base_cost = ANTENNA_TYPES[a['type']]['cost_on_building']
        total_cost += base_cost // 2  # Assume building discount
    return total_cost


def validate_and_cleanup(buildings: List[dict], antennas: List[dict]) -> List[dict]:
    """Final validation and cleanup of solution."""
    building_by_id = {b['id']: b for b in buildings}
    covered = set()
    valid_antennas = []
    
    for antenna in antennas:
        # Validate each antenna
        antenna_spec = ANTENNA_TYPES[antenna['type']]
        valid_buildings = []
        
        for bid in antenna['buildings']:
            if bid in covered:
                continue
            b = building_by_id[bid]
            if is_in_range(antenna['x'], antenna['y'], b['x'], b['y'], antenna_spec['range']):
                valid_buildings.append(bid)
        
        # Check capacity
        if valid_buildings and is_valid_capacity(valid_buildings, antenna_spec['capacity'], building_by_id):
            valid_antennas.append({
                'type': antenna['type'],
                'x': antenna['x'],
                'y': antenna['y'],
                'buildings': valid_buildings
            })
            covered.update(valid_buildings)
    
    # Cover any remaining buildings
    all_building_ids = {b['id'] for b in buildings}
    uncovered = all_building_ids - covered
    for bid in uncovered:
        b = building_by_id[bid]
        valid_antennas.append({
            'type': 'MaxRange',
            'x': b['x'],
            'y': b['y'],
            'buildings': [bid]
        })
    
    return valid_antennas