"""
AI-Generated Solver
Generated: 2025-12-29 22:28:19
Model: claude-sonnet-4-5-20250929

This solver was automatically generated by Claude AI based on
analysis of existing solver performance patterns.
"""

"""
Multi-scale hierarchical clustering solver optimized for suburban datasets.

Strategy for 3_suburbia (low clustering, moderate distribution, large spatial spread):
1. Hierarchical spatial partitioning using quadtree decomposition
2. Density-aware antenna selection with demand weighting
3. Multi-phase optimization: coarse placement -> refinement -> consolidation
4. Explicit shared coverage optimization to exploit sublinear cost scaling
5. Adaptive antenna type selection based on local density patterns
"""
import random
import math
from typing import Dict, List, Set, Tuple, Optional
from collections import defaultdict
from ..base import (
    SolverResult,
    ANTENNA_TYPES,
    ANTENNA_TYPES_BY_CAPACITY,
    get_building_demand,
    is_in_range,
    distance
)


def solve(dataset: dict, *, seed: int, params: dict = None) -> SolverResult:
    """
    Hierarchical clustering solver optimized for suburban sprawl patterns.
    """
    if params is None:
        params = {}
    
    rng = random.Random(seed)
    buildings = dataset['buildings']
    
    solver = HierarchicalSuburbanSolver(buildings, rng, params)
    return solver.solve()


class HierarchicalSuburbanSolver:
    def __init__(self, buildings: List[dict], rng: random.Random, params: dict):
        self.buildings = buildings
        self.rng = rng
        self.params = params
        
        # Precompute building metadata
        self.building_by_id = {b['id']: b for b in buildings}
        self.building_demands = {b['id']: get_building_demand(b) for b in buildings}
        self.building_coords = {b['id']: (b['x'], b['y']) for b in buildings}
        
        # Compute spatial bounds
        all_x = [b['x'] for b in buildings]
        all_y = [b['y'] for b in buildings]
        self.min_x, self.max_x = min(all_x), max(all_x)
        self.min_y, self.max_y = min(all_y), max(all_y)
        
        self.covered = set()
        self.antennas = []
    
    def solve(self) -> SolverResult:
        """Main solving pipeline."""
        # Phase 1: Hierarchical spatial clustering
        clusters = self.hierarchical_partition()
        
        # Phase 2: Initial antenna placement per cluster
        self.place_cluster_antennas(clusters)
        
        # Phase 3: Fill gaps with targeted placement
        self.fill_coverage_gaps()
        
        # Phase 4: Local optimization - merge and upgrade
        self.optimize_antenna_placement()
        
        # Phase 5: Final validation and emergency coverage
        self.ensure_full_coverage()
        
        return {'antennas': self.antennas}
    
    def hierarchical_partition(self) -> List[List[int]]:
        """Partition buildings into spatial clusters using adaptive quadtree."""
        # Start with all buildings
        root_cluster = [b['id'] for b in self.buildings]
        clusters = []
        
        # Recursively partition until clusters are manageable
        def partition_recursive(building_ids: List[int], depth: int = 0):
            if len(building_ids) <= 10 or depth >= 6:  # Base case
                clusters.append(building_ids)
                return
            
            # Compute bounds for this cluster
            coords = [self.building_coords[bid] for bid in building_ids]
            xs = [c[0] for c in coords]
            ys = [c[1] for c in coords]
            min_x, max_x = min(xs), max(xs)
            min_y, max_y = min(ys), max(ys)
            
            # Check if cluster is compact enough
            span = max(max_x - min_x, max_y - min_y)
            if span <= 2000:  # Compact cluster
                clusters.append(building_ids)
                return
            
            # Split into quadrants
            mid_x = (min_x + max_x) / 2
            mid_y = (min_y + max_y) / 2
            
            quadrants = [[], [], [], []]
            for bid in building_ids:
                x, y = self.building_coords[bid]
                quad_idx = (0 if x < mid_x else 1) + (0 if y < mid_y else 2)
                quadrants[quad_idx].append(bid)
            
            # Recurse on non-empty quadrants
            for quadrant in quadrants:
                if quadrant:
                    partition_recursive(quadrant, depth + 1)
        
        partition_recursive(root_cluster)
        return clusters
    
    def place_cluster_antennas(self, clusters: List[List[int]]):
        """Place antennas for each spatial cluster using density-aware selection."""
        for cluster in clusters:
            if not cluster:
                continue
            
            # Sort by demand within cluster
            cluster_buildings = [(bid, self.building_demands[bid]) for bid in cluster]
            cluster_buildings.sort(key=lambda x: x[1], reverse=True)
            
            uncovered_in_cluster = set(cluster)
            
            while uncovered_in_cluster:
                # Find best anchor point (weighted centroid of uncovered buildings)
                anchor_x, anchor_y = self.compute_weighted_centroid(list(uncovered_in_cluster))
                
                # Find nearest building to anchor as antenna location
                best_building = None
                best_dist = float('inf')
                for bid in uncovered_in_cluster:
                    bx, by = self.building_coords[bid]
                    d = distance(anchor_x, anchor_y, bx, by)
                    if d < best_dist:
                        best_dist = d
                        best_building = bid
                
                if best_building is None:
                    best_building = next(iter(uncovered_in_cluster))
                
                antenna_x, antenna_y = self.building_coords[best_building]
                
                # Select best antenna type for this location
                antenna_type, assignment = self.select_best_antenna(
                    antenna_x, antenna_y, uncovered_in_cluster
                )
                
                if assignment:
                    self.antennas.append({
                        'type': antenna_type,
                        'x': antenna_x,
                        'y': antenna_y,
                        'buildings': assignment
                    })
                    self.covered.update(assignment)
                    uncovered_in_cluster -= set(assignment)
                else:
                    # Fallback for edge case
                    break
    
    def compute_weighted_centroid(self, building_ids: List[int]) -> Tuple[float, float]:
        """Compute demand-weighted centroid of buildings."""
        total_demand = 0
        weighted_x = 0
        weighted_y = 0
        
        for bid in building_ids:
            demand = self.building_demands[bid]
            x, y = self.building_coords[bid]
            weighted_x += x * demand
            weighted_y += y * demand
            total_demand += demand
        
        if total_demand == 0:
            # Fallback to simple centroid
            coords = [self.building_coords[bid] for bid in building_ids]
            return sum(c[0] for c in coords) / len(coords), sum(c[1] for c in coords) / len(coords)
        
        return weighted_x / total_demand, weighted_y / total_demand
    
    def select_best_antenna(self, x: int, y: int, candidate_ids: Set[int]) -> Tuple[str, List[int]]:
        """Select optimal antenna type and building assignment for given location."""
        best_antenna = None
        best_assignment = []
        best_score = -1
        
        for antenna_type in ANTENNA_TYPES_BY_CAPACITY:
            spec = ANTENNA_TYPES[antenna_type]
            antenna_range = spec['range']
            capacity = spec['capacity']
            
            # Find buildings in range
            in_range_buildings = []
            for bid in candidate_ids:
                if bid in self.covered:
                    continue
                bx, by = self.building_coords[bid]
                if is_in_range(x, y, bx, by, antenna_range):
                    demand = self.building_demands[bid]
                    dist = distance(x, y, bx, by)
                    # Priority: high demand, close distance
                    priority = demand * 1000 - dist
                    in_range_buildings.append((bid, priority))
            
            in_range_buildings.sort(key=lambda x: x[1], reverse=True)
            
            # Pack buildings greedily
            assignment = []
            total_peak = 0
            total_off_peak = 0
            total_night = 0
            
            for bid, _ in in_range_buildings:
                b = self.building_by_id[bid]
                new_peak = total_peak + b['populationPeakHours']
                new_off_peak = total_off_peak + b['populationOffPeakHours']
                new_night = total_night + b['populationNight']
                
                if max(new_peak, new_off_peak, new_night) <= capacity:
                    assignment.append(bid)
                    total_peak = new_peak
                    total_off_peak = new_off_peak
                    total_night = new_night
            
            if not assignment:
                continue
            
            # Score: coverage per cost unit
            cost = spec['cost_on_building'] if (x, y) not in [(self.building_coords[bid]) for bid in assignment] else spec['cost_on_building'] * 0.9
            score = len(assignment) / cost
            
            if score > best_score:
                best_score = score
                best_antenna = antenna_type
                best_assignment = assignment
        
        return best_antenna or 'MaxRange', best_assignment
    
    def fill_coverage_gaps(self):
        """Cover remaining buildings with targeted antenna placement."""
        uncovered = set(self.building_by_id.keys()) - self.covered
        
        while uncovered:
            # Find highest demand uncovered building
            best_bid = max(uncovered, key=lambda bid: self.building_demands[bid])
            bx, by = self.building_coords[best_bid]
            
            antenna_type, assignment = self.select_best_antenna(bx, by, uncovered)
            
            if not assignment:
                # Emergency: single building with MaxRange
                assignment = [best_bid]
                antenna_type = 'MaxRange'
            
            self.antennas.append({
                'type': antenna_type,
                'x': bx,
                'y': by,
                'buildings': assignment
            })
            self.covered.update(assignment)
            uncovered -= set(assignment)
    
    def optimize_antenna_placement(self):
        """Local optimization: merge nearby antennas and upgrade types."""
        improved = True
        iterations = 0
        max_iterations = 5
        
        while improved and iterations < max_iterations:
            improved = False
            iterations += 1
            
            # Try to merge small antennas
            i = 0
            while i < len(self.antennas):
                antenna1 = self.antennas[i]
                
                # Look for nearby antennas
                for j in range(i + 1, len(self.antennas)):
                    antenna2 = self.antennas[j]
                    
                    # Check if antennas are close enough to merge
                    dist = distance(antenna1['x'], antenna1['y'], antenna2['x'], antenna2['y'])
                    
                    if dist < 1500:  # Merge radius
                        # Try to merge into one antenna
                        all_buildings = antenna1['buildings'] + antenna2['buildings']
                        
                        # Try placement at both locations
                        for test_x, test_y in [(antenna1['x'], antenna1['y']), (antenna2['x'], antenna2['y'])]:
                            merged_type, merged_assignment = self.try_merge_antennas(
                                test_x, test_y, all_buildings
                            )
                            
                            if set(merged_assignment) == set(all_buildings):
                                # Successful merge
                                self.antennas[i] = {
                                    'type': merged_type,
                                    'x': test_x,
                                    'y': test_y,
                                    'buildings': merged_assignment
                                }
                                self.antennas.pop(j)
                                improved = True
                                break
                        
                        if improved:
                            break
                
                if not improved:
                    i += 1
                else:
                    break
    
    def try_merge_antennas(self, x: int, y: int, building_ids: List[int]) -> Tuple[str, List[int]]:
        """Try to fit all buildings under one antenna."""
        for antenna_type in ['Nano', 'Spot', 'Density', 'MaxRange']:
            spec = ANTENNA_TYPES[antenna_type]
            
            # Check range
            all_in_range = all(
                is_in_range(x, y, *self.building_coords[bid], spec['range'])
                for bid in building_ids
            )
            
            if not all_in_range:
                continue
            
            # Check capacity
            total_peak = sum(self.building_by_id[bid]['populationPeakHours'] for bid in building_ids)
            total_off = sum(self.building_by_id[bid]['populationOffPeakHours'] for bid in building_ids)
            total_night = sum(self.building_by_id[bid]['populationNight'] for bid in building_ids)
            
            if max(total_peak, total_off, total_night) <= spec['capacity']:
                return antenna_type, building_ids
        
        return 'MaxRange', []
    
    def ensure_full_coverage(self):
        """Final safety check: cover any missed buildings."""
        all_building_ids = set(self.building_by_id.keys())
        uncovered = all_building_ids - self.covered
        
        for bid in uncovered:
            b = self.building_by_id[bid]
            self.antennas.append({
                'type': 'MaxRange',
                'x': b['x'],
                'y': b['y'],
                'buildings': [bid]
            })
            self.covered.add(bid)