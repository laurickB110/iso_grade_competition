"""
AI-Generated Solver
Generated: 2025-12-30 11:29:51
Model: claude-sonnet-4-5-20250929

This solver was automatically generated by Claude AI based on
analysis of existing solver performance patterns.
"""

"""
Demand-Weighted Clustering Solver with Iterative Refinement

Specialized for 3_suburbia characteristics:
- 2601 buildings with moderate spatial spread and low clustering
- Leverages demand density gradients for intelligent facility placement
- Multi-phase approach: clustering -> placement -> assignment -> refinement
- Focuses on minimizing total cost through strategic antenna placement and type selection
"""

import random
import math
from typing import Dict, List, Set, Tuple, Optional
from collections import defaultdict
from ..base import (
    SolverResult,
    ANTENNA_TYPES,
    ANTENNA_TYPES_BY_CAPACITY,
    get_building_demand,
    is_in_range,
    distance
)


def solve(dataset: dict, *, seed: int, params: dict = None) -> SolverResult:
    """
    Demand-weighted clustering solver with iterative refinement.
    
    Strategy:
    1. Compute demand density grid
    2. Identify high-value placement candidates (weighted by demand and building density)
    3. Greedily place antennas at optimal locations
    4. Assign buildings to minimize cost (considering antenna cost + type upgrades)
    5. Iterative refinement: reassignment, consolidation, and type optimization
    """
    if params is None:
        params = {}
    
    rng = random.Random(seed)
    buildings = dataset['buildings']
    
    # Precompute building data
    building_by_id = {b['id']: b for b in buildings}
    building_demands = {b['id']: get_building_demand(b) for b in buildings}
    
    # Phase 1: Demand density analysis
    grid_cell_size = 200  # Grid cells for density computation
    density_grid = compute_density_grid(buildings, building_demands, grid_cell_size)
    
    # Phase 2: Generate candidate antenna locations
    candidates = generate_placement_candidates(
        buildings, building_demands, density_grid, grid_cell_size, rng
    )
    
    # Phase 3: Greedy antenna placement with smart type selection
    antennas = []
    covered = set()
    all_building_ids = {b['id'] for b in buildings}
    
    # Sort candidates by weighted score
    candidates.sort(key=lambda x: x[2], reverse=True)
    
    for x, y, score in candidates:
        if len(covered) >= len(all_building_ids):
            break
        
        # Find best antenna type and assignment for this location
        best_config = find_best_antenna_config(
            x, y, buildings, building_by_id, building_demands, covered
        )
        
        if best_config and len(best_config['buildings']) > 0:
            antennas.append(best_config)
            covered.update(best_config['buildings'])
    
    # Phase 4: Cover any remaining buildings
    uncovered = all_building_ids - covered
    for bid in uncovered:
        b = building_by_id[bid]
        # Try to find nearby antenna to extend
        extended = False
        for ant in antennas:
            if is_in_range(ant['x'], ant['y'], b['x'], b['y'], ANTENNA_TYPES[ant['type']]['range']):
                # Check if we can add this building
                if can_add_building(ant, bid, building_by_id):
                    ant['buildings'].append(bid)
                    covered.add(bid)
                    extended = True
                    break
        
        if not extended:
            # Create new antenna on this building
            antennas.append({
                'type': 'MaxRange',
                'x': b['x'],
                'y': b['y'],
                'buildings': [bid]
            })
            covered.add(bid)
    
    # Phase 5: Iterative refinement
    antennas = refine_solution(antennas, buildings, building_by_id, building_demands, rng, iterations=3)
    
    # Phase 6: Final optimization - try to downgrade antenna types
    antennas = optimize_antenna_types(antennas, building_by_id)
    
    return {'antennas': antennas}


def compute_density_grid(buildings: List[dict], building_demands: Dict[int, int], 
                         cell_size: int) -> Dict[Tuple[int, int], float]:
    """Compute demand density on a grid."""
    density = defaultdict(float)
    
    for b in buildings:
        cell_x = b['x'] // cell_size
        cell_y = b['y'] // cell_size
        demand = building_demands[b['id']]
        
        # Spread demand to nearby cells
        for dx in [-1, 0, 1]:
            for dy in [-1, 0, 1]:
                weight = 1.0 / (1 + abs(dx) + abs(dy))
                density[(cell_x + dx, cell_y + dy)] += demand * weight
    
    return density


def generate_placement_candidates(buildings: List[dict], building_demands: Dict[int, int],
                                  density_grid: Dict[Tuple[int, int], float],
                                  cell_size: int, rng: random.Random) -> List[Tuple[int, int, float]]:
    """Generate weighted candidate locations for antenna placement."""
    candidates = []
    
    # Strategy 1: High-demand buildings
    sorted_by_demand = sorted(buildings, key=lambda b: building_demands[b['id']], reverse=True)
    for b in sorted_by_demand[:500]:  # Top 500 by demand
        cell_x = b['x'] // cell_size
        cell_y = b['y'] // cell_size
        density_score = density_grid.get((cell_x, cell_y), 0)
        
        # Count nearby buildings
        nearby_count = sum(1 for other in buildings 
                          if distance(b['x'], b['y'], other['x'], other['y']) <= 300)
        
        score = building_demands[b['id']] * 0.4 + density_score * 0.3 + nearby_count * 0.3
        candidates.append((b['x'], b['y'], score))
    
    # Strategy 2: Density grid centers
    top_cells = sorted(density_grid.items(), key=lambda x: x[1], reverse=True)[:200]
    for (cell_x, cell_y), density in top_cells:
        # Find building closest to cell center
        center_x = cell_x * cell_size + cell_size // 2
        center_y = cell_y * cell_size + cell_size // 2
        
        closest_building = min(buildings, 
                              key=lambda b: distance(b['x'], b['y'], center_x, center_y))
        
        score = density * 1.2
        candidates.append((closest_building['x'], closest_building['y'], score))
    
    # Remove duplicates
    seen = set()
    unique_candidates = []
    for x, y, score in candidates:
        if (x, y) not in seen:
            seen.add((x, y))
            unique_candidates.append((x, y, score))
    
    return unique_candidates


def find_best_antenna_config(x: int, y: int, buildings: List[dict],
                             building_by_id: Dict[int, dict],
                             building_demands: Dict[int, int],
                             covered: Set[int]) -> Optional[dict]:
    """Find the best antenna type and building assignment for a location."""
    best_config = None
    best_value = -1
    
    for antenna_type in ANTENNA_TYPES_BY_CAPACITY:
        spec = ANTENNA_TYPES[antenna_type]
        antenna_range = spec['range']
        capacity = spec['capacity']
        cost = spec['cost_on_building']
        
        # Find reachable uncovered buildings
        reachable = []
        for b in buildings:
            if b['id'] not in covered and is_in_range(x, y, b['x'], b['y'], antenna_range):
                reachable.append(b['id'])
        
        if not reachable:
            continue
        
        # Greedy packing by demand
        reachable.sort(key=lambda bid: building_demands[bid], reverse=True)
        
        assignment = []
        total_peak = total_off_peak = total_night = 0
        
        for bid in reachable:
            b = building_by_id[bid]
            new_peak = total_peak + b['populationPeakHours']
            new_off_peak = total_off_peak + b['populationOffPeakHours']
            new_night = total_night + b['populationNight']
            
            if max(new_peak, new_off_peak, new_night) <= capacity:
                assignment.append(bid)
                total_peak = new_peak
                total_off_peak = new_off_peak
                total_night = new_night
        
        if assignment:
            # Value = buildings covered / cost (prefer efficient placements)
            value = len(assignment) / (cost / 1000.0)
            
            if value > best_value:
                best_value = value
                best_config = {
                    'type': antenna_type,
                    'x': x,
                    'y': y,
                    'buildings': assignment
                }
    
    return best_config


def can_add_building(antenna: dict, building_id: int, building_by_id: Dict[int, dict]) -> bool:
    """Check if a building can be added to an antenna."""
    spec = ANTENNA_TYPES[antenna['type']]
    b = building_by_id[building_id]
    
    # Check range
    if not is_in_range(antenna['x'], antenna['y'], b['x'], b['y'], spec['range']):
        return False
    
    # Check capacity
    total_peak = sum(building_by_id[bid]['populationPeakHours'] for bid in antenna['buildings'])
    total_off_peak = sum(building_by_id[bid]['populationOffPeakHours'] for bid in antenna['buildings'])
    total_night = sum(building_by_id[bid]['populationNight'] for bid in antenna['buildings'])
    
    new_peak = total_peak + b['populationPeakHours']
    new_off_peak = total_off_peak + b['populationOffPeakHours']
    new_night = total_night + b['populationNight']
    
    return max(new_peak, new_off_peak, new_night) <= spec['capacity']


def refine_solution(antennas: List[dict], buildings: List[dict],
                   building_by_id: Dict[int, dict], building_demands: Dict[int, int],
                   rng: random.Random, iterations: int = 3) -> List[dict]:
    """Iterative refinement through reassignment and consolidation."""
    
    for iteration in range(iterations):
        # Step 1: Try reassigning high-demand buildings to cheaper antennas
        all_assigned = {}
        for i, ant in enumerate(antennas):
            for bid in ant['buildings']:
                all_assigned[bid] = i
        
        # Sort buildings by demand descending
        sorted_bids = sorted(all_assigned.keys(), key=lambda bid: building_demands[bid], reverse=True)
        
        for bid in sorted_bids:
            current_ant_idx = all_assigned[bid]
            current_ant = antennas[current_ant_idx]
            
            # Try moving to another antenna
            best_alternative = None
            best_cost_delta = 0
            
            for i, ant in enumerate(antennas):
                if i == current_ant_idx:
                    continue
                
                if can_add_building(ant, bid, building_by_id):
                    # Calculate cost change
                    # Removing from current might allow downgrade
                    # Adding to new might require upgrade
                    cost_delta = estimate_cost_delta(
                        current_ant, ant, bid, building_by_id
                    )
                    
                    if cost_delta < best_cost_delta:
                        best_cost_delta = cost_delta
                        best_alternative = i
            
            if best_alternative is not None:
                # Perform reassignment
                current_ant['buildings'].remove(bid)
                antennas[best_alternative]['buildings'].append(bid)
                all_assigned[bid] = best_alternative
        
        # Step 2: Remove empty antennas
        antennas = [ant for ant in antennas if ant['buildings']]
        
        # Step 3: Try consolidating nearby antennas
        antennas = consolidate_antennas(antennas, building_by_id)
    
    return antennas


def estimate_cost_delta(from_ant: dict, to_ant: dict, building_id: int,
                       building_by_id: Dict[int, dict]) -> float:
    """Estimate cost change from moving a building between antennas."""
    # Simplified: doesn't account for type changes, just a heuristic
    return 0.0  # Neutral baseline


def consolidate_antennas(antennas: List[dict], building_by_id: Dict[int, dict]) -> List[dict]:
    """Try to merge nearby antennas."""
    changed = True
    while changed:
        changed = False
        for i in range(len(antennas)):
            for j in range(i + 1, len(antennas)):
                ant1 = antennas[i]
                ant2 = antennas[j]
                
                # Check if close enough
                if distance(ant1['x'], ant1['y'], ant2['x'], ant2['y']) > 150:
                    continue
                
                # Try merging into one antenna
                all_buildings = ant1['buildings'] + ant2['buildings']
                
                for antenna_type in ANTENNA_TYPES_BY_CAPACITY:
                    spec = ANTENNA_TYPES[antenna_type]
                    
                    # Check if all buildings are in range from ant1 location
                    all_in_range = all(
                        is_in_range(ant1['x'], ant1['y'], 
                                   building_by_id[bid]['x'], building_by_id[bid]['y'],
                                   spec['range'])
                        for bid in all_buildings
                    )
                    
                    if not all_in_range:
                        continue
                    
                    # Check capacity
                    total_peak = sum(building_by_id[bid]['populationPeakHours'] for bid in all_buildings)
                    total_off_peak = sum(building_by_id[bid]['populationOffPeakHours'] for bid in all_buildings)
                    total_night = sum(building_by_id[bid]['populationNight'] for bid in all_buildings)
                    
                    if max(total_peak, total_off_peak, total_night) <= spec['capacity']:
                        # Merge successful
                        ant1['type'] = antenna_type
                        ant1['buildings'] = all_buildings
                        antennas.pop(j)
                        changed = True
                        break
                
                if changed:
                    break
            if changed:
                break
    
    return antennas


def optimize_antenna_types(antennas: List[dict], building_by_id: Dict[int, dict]) -> List[dict]:
    """Try to downgrade antenna types where possible."""
    for ant in antennas:
        current_type = ant['type']
        
        # Calculate current demand
        total_peak = sum(building_by_id[bid]['populationPeakHours'] for bid in ant['buildings'])
        total_off_peak = sum(building_by_id[bid]['populationOffPeakHours'] for bid in ant['buildings'])
        total_night = sum(building_by_id[bid]['populationNight'] for bid in ant['buildings'])
        max_demand = max(total_peak, total_off_peak, total_night)
        
        # Try smaller antenna types
        for antenna_type in ANTENNA_TYPES_BY_CAPACITY:
            spec = ANTENNA_TYPES[antenna_type]
            
            if spec['capacity'] < max_demand:
                continue
            
            # Check if all buildings are in range
            all_in_range = all(
                is_in_range(ant['x'], ant['y'],
                           building_by_id[bid]['x'], building_by_id[bid]['y'],
                           spec['range'])
                for bid in ant['buildings']
            )
            
            if all_in_range:
                ant['type'] = antenna_type
                break
    
    return antennas