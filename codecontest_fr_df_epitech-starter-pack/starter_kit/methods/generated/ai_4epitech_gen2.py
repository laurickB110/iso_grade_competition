"""
AI-Generated Solver
Generated: 2025-12-29 22:22:07
Model: claude-sonnet-4-5-20250929

This solver was automatically generated by Claude AI based on
analysis of existing solver performance patterns.
"""

"""
Adaptive Multi-Phase Solver for Dense Distribution with Low Clustering

Strategy for 4_epitech (5000 buildings, dense, low clustering):
1. Spatial Grid Partitioning: Divide space into grid cells for systematic coverage
2. Demand-Weighted Clustering: Use k-means++ with demand weighting to find optimal antenna positions
3. Greedy Set Cover: Prioritize buildings by coverage difficulty (high demand, isolated)
4. Local Search Refinement: Apply antenna type optimization and position micro-adjustments
5. Building-based placement discount exploitation
"""
import random
import math
from typing import Dict, List, Set, Tuple
from collections import defaultdict
from ..base import (
    SolverResult,
    ANTENNA_TYPES,
    ANTENNA_TYPES_BY_CAPACITY,
    get_building_demand,
    is_in_range,
    distance
)


def solve(dataset: dict, *, seed: int, params: dict = None) -> SolverResult:
    """
    Adaptive multi-phase solver optimized for dense, low-clustering datasets.
    """
    rng = random.Random(seed)
    buildings = dataset['buildings']
    
    # Precompute building data
    building_by_id = {b['id']: b for b in buildings}
    building_demands = {b['id']: get_building_demand(b) for b in buildings}
    
    # Phase 1: Identify optimal antenna candidate positions using demand-weighted clustering
    num_initial_clusters = max(50, len(buildings) // 100)
    cluster_centers = demand_weighted_kmeans(buildings, building_demands, num_initial_clusters, rng)
    
    # Phase 2: Snap cluster centers to nearby building positions for discount
    candidate_positions = snap_to_buildings(cluster_centers, buildings, building_by_id)
    
    # Phase 3: Greedy set cover with smart antenna type selection
    antennas = greedy_set_cover_placement(
        buildings, building_by_id, building_demands, candidate_positions, rng
    )
    
    # Phase 4: Local optimization - try to reduce cost by consolidating/upgrading
    antennas = local_search_optimization(antennas, buildings, building_by_id, building_demands, rng)
    
    # Phase 5: Final coverage check and emergency fixes
    antennas = ensure_complete_coverage(antennas, buildings, building_by_id, building_demands)
    
    return {'antennas': antennas}


def demand_weighted_kmeans(buildings: List[dict], building_demands: Dict[int, int],
                           k: int, rng: random.Random) -> List[Tuple[int, int]]:
    """
    K-means++ clustering weighted by building demand to find good antenna positions.
    """
    if k >= len(buildings):
        return [(b['x'], b['y']) for b in buildings]
    
    # Initialize first center randomly, weighted by demand
    weights = [building_demands[b['id']] for b in buildings]
    total_weight = sum(weights)
    
    centers = []
    first_idx = rng.choices(range(len(buildings)), weights=weights, k=1)[0]
    centers.append((buildings[first_idx]['x'], buildings[first_idx]['y']))
    
    # Add remaining centers using k-means++ (distance-weighted selection)
    for _ in range(k - 1):
        distances = []
        for b in buildings:
            min_dist = min(distance(b['x'], b['y'], cx, cy) for cx, cy in centers)
            # Weight by both distance and demand
            weighted_dist = min_dist * math.sqrt(building_demands[b['id']])
            distances.append(weighted_dist ** 2)
        
        if sum(distances) == 0:
            break
            
        next_idx = rng.choices(range(len(buildings)), weights=distances, k=1)[0]
        centers.append((buildings[next_idx]['x'], buildings[next_idx]['y']))
    
    # Run a few iterations of k-means
    for _ in range(10):
        # Assign buildings to nearest center
        clusters = defaultdict(list)
        for b in buildings:
            nearest = min(centers, key=lambda c: distance(b['x'], b['y'], c[0], c[1]))
            clusters[nearest].append(b)
        
        # Update centers (weighted by demand)
        new_centers = []
        for center in centers:
            cluster_buildings = clusters[center]
            if not cluster_buildings:
                new_centers.append(center)
                continue
            
            weighted_x = sum(b['x'] * building_demands[b['id']] for b in cluster_buildings)
            weighted_y = sum(b['y'] * building_demands[b['id']] for b in cluster_buildings)
            total_demand = sum(building_demands[b['id']] for b in cluster_buildings)
            
            new_centers.append((int(weighted_x / total_demand), int(weighted_y / total_demand)))
        
        centers = new_centers
    
    return centers


def snap_to_buildings(centers: List[Tuple[int, int]], buildings: List[dict],
                     building_by_id: Dict[int, dict]) -> List[Tuple[int, int, int]]:
    """
    Snap each center to nearest building for installation discount.
    Returns list of (x, y, building_id).
    """
    positions = []
    used_buildings = set()
    
    for cx, cy in centers:
        # Find nearest unused building
        best_building = None
        best_dist = float('inf')
        
        for b in buildings:
            if b['id'] in used_buildings:
                continue
            dist = distance(cx, cy, b['x'], b['y'])
            if dist < best_dist:
                best_dist = dist
                best_building = b
        
        if best_building:
            positions.append((best_building['x'], best_building['y'], best_building['id']))
            used_buildings.add(best_building['id'])
    
    return positions


def greedy_set_cover_placement(buildings: List[dict], building_by_id: Dict[int, dict],
                               building_demands: Dict[int, int],
                               candidate_positions: List[Tuple[int, int, int]],
                               rng: random.Random) -> List[dict]:
    """
    Greedy set cover: place antennas at candidate positions to maximize coverage efficiency.
    """
    covered = set()
    antennas = []
    all_building_ids = {b['id'] for b in buildings}
    
    # Calculate coverage difficulty (high demand + spatial isolation)
    difficulty_scores = {}
    for b in buildings:
        nearby_count = sum(1 for other in buildings 
                          if distance(b['x'], b['y'], other['x'], other['y']) <= 500)
        difficulty_scores[b['id']] = building_demands[b['id']] / max(1, nearby_count)
    
    while covered != all_building_ids:
        uncovered = all_building_ids - covered
        
        best_antenna = None
        best_score = -1
        
        # Try each candidate position
        for x, y, anchor_id in candidate_positions:
            # Skip if anchor building already covered
            if anchor_id in covered:
                continue
            
            # Try each antenna type
            for antenna_type in ANTENNA_TYPES_BY_CAPACITY:
                antenna_spec = ANTENNA_TYPES[antenna_type]
                antenna_range = antenna_spec['range']
                antenna_capacity = antenna_spec['capacity']
                antenna_cost = antenna_spec['cost_base']
                
                # Find uncovered buildings in range
                candidates = []
                for bid in uncovered:
                    b = building_by_id[bid]
                    if is_in_range(x, y, b['x'], b['y'], antenna_range):
                        candidates.append(bid)
                
                if not candidates:
                    continue
                
                # Pack buildings by difficulty (hard-to-cover first)
                candidates.sort(key=lambda bid: difficulty_scores[bid], reverse=True)
                
                assignment = []
                total_peak = 0
                total_off_peak = 0
                total_night = 0
                
                for bid in candidates:
                    b = building_by_id[bid]
                    new_peak = total_peak + b['populationPeakHours']
                    new_off_peak = total_off_peak + b['populationOffPeakHours']
                    new_night = total_night + b['populationNight']
                    new_max = max(new_peak, new_off_peak, new_night)
                    
                    if new_max <= antenna_capacity:
                        assignment.append(bid)
                        total_peak = new_peak
                        total_off_peak = new_off_peak
                        total_night = new_night
                
                if not assignment:
                    continue
                
                # Score: coverage value / cost (maximize efficiency)
                coverage_value = sum(difficulty_scores[bid] for bid in assignment)
                score = coverage_value / antenna_cost
                
                if score > best_score:
                    best_score = score
                    best_antenna = {
                        'type': antenna_type,
                        'x': x,
                        'y': y,
                        'buildings': assignment
                    }
        
        if best_antenna:
            antennas.append(best_antenna)
            covered.update(best_antenna['buildings'])
        else:
            # Fallback: cover hardest remaining building with MaxRange
            hardest = max(uncovered, key=lambda bid: difficulty_scores[bid])
            b = building_by_id[hardest]
            antennas.append({
                'type': 'MaxRange',
                'x': b['x'],
                'y': b['y'],
                'buildings': [hardest]
            })
            covered.add(hardest)
    
    return antennas


def local_search_optimization(antennas: List[dict], buildings: List[dict],
                              building_by_id: Dict[int, dict],
                              building_demands: Dict[int, int],
                              rng: random.Random) -> List[dict]:
    """
    Local search to reduce total cost: antenna type downgrade, consolidation.
    """
    improved = True
    iterations = 0
    max_iterations = 20
    
    while improved and iterations < max_iterations:
        improved = False
        iterations += 1
        
        # Try to downgrade antenna types
        for i, antenna in enumerate(antennas):
            current_type = antenna['type']
            current_idx = ANTENNA_TYPES_BY_CAPACITY.index(current_type)
            
            if current_idx == 0:  # Already smallest
                continue
            
            # Try smaller antenna types
            for j in range(current_idx):
                smaller_type = ANTENNA_TYPES_BY_CAPACITY[j]
                smaller_spec = ANTENNA_TYPES[smaller_type]
                
                # Check if all buildings still fit
                total_peak = 0
                total_off_peak = 0
                total_night = 0
                all_in_range = True
                
                for bid in antenna['buildings']:
                    b = building_by_id[bid]
                    if not is_in_range(antenna['x'], antenna['y'], b['x'], b['y'], smaller_spec['range']):
                        all_in_range = False
                        break
                    total_peak += b['populationPeakHours']
                    total_off_peak += b['populationOffPeakHours']
                    total_night += b['populationNight']
                
                if all_in_range and max(total_peak, total_off_peak, total_night) <= smaller_spec['capacity']:
                    antennas[i] = {
                        'type': smaller_type,
                        'x': antenna['x'],
                        'y': antenna['y'],
                        'buildings': antenna['buildings']
                    }
                    improved = True
                    break
    
    # Try to merge nearby small antennas
    merged_antennas = []
    used = set()
    
    for i, ant1 in enumerate(antennas):
        if i in used:
            continue
        
        # Try to find nearby antenna to merge with
        merged = False
        for j, ant2 in enumerate(antennas[i+1:], i+1):
            if j in used:
                continue
            
            dist = distance(ant1['x'], ant1['y'], ant2['x'], ant2['y'])
            if dist > 800:  # Too far
                continue
            
            # Try to merge buildings onto a single antenna at ant1's position
            combined_buildings = list(set(ant1['buildings'] + ant2['buildings']))
            
            for antenna_type in ANTENNA_TYPES_BY_CAPACITY:
                antenna_spec = ANTENNA_TYPES[antenna_type]
                
                # Check if all fit
                all_in_range = True
                total_peak = 0
                total_off_peak = 0
                total_night = 0
                
                for bid in combined_buildings:
                    b = building_by_id[bid]
                    if not is_in_range(ant1['x'], ant1['y'], b['x'], b['y'], antenna_spec['range']):
                        all_in_range = False
                        break
                    total_peak += b['populationPeakHours']
                    total_off_peak += b['populationOffPeakHours']
                    total_night += b['populationNight']
                
                if all_in_range and max(total_peak, total_off_peak, total_night) <= antenna_spec['capacity']:
                    # Check if cost is better
                    old_cost = ANTENNA_TYPES[ant1['type']]['cost_base'] + ANTENNA_TYPES[ant2['type']]['cost_base']
                    new_cost = antenna_spec['cost_base']
                    
                    if new_cost < old_cost:
                        merged_antennas.append({
                            'type': antenna_type,
                            'x': ant1['x'],
                            'y': ant1['y'],
                            'buildings': combined_buildings
                        })
                        used.add(i)
                        used.add(j)
                        merged = True
                        break
            
            if merged:
                break
        
        if not merged:
            merged_antennas.append(ant1)
            used.add(i)
    
    return merged_antennas


def ensure_complete_coverage(antennas: List[dict], buildings: List[dict],
                             building_by_id: Dict[int, dict],
                             building_demands: Dict[int, int]) -> List[dict]:
    """
    Final safety check: ensure all buildings are covered.
    """
    covered = set()
    for antenna in antennas:
        covered.update(antenna['buildings'])
    
    all_building_ids = {b['id'] for b in buildings}
    uncovered = all_building_ids - covered
    
    if uncovered:
        # Cover each uncovered building with smallest possible antenna
        for bid in uncovered:
            b = building_by_id[bid]
            
            # Try to find existing nearby antenna to expand
            added = False
            for antenna in antennas:
                antenna_spec = ANTENNA_TYPES[antenna['type']]
                
                if is_in_range(antenna['x'], antenna['y'], b['x'], b['y'], antenna_spec['range']):
                    # Check capacity
                    total_peak = sum(building_by_id[bid]['populationPeakHours'] for bid in antenna['buildings']) + b['populationPeakHours']
                    total_off_peak = sum(building_by_id[bid]['populationOffPeakHours'] for bid in antenna['buildings']) + b['populationOffPeakHours']
                    total_night = sum(building_by_id[bid]['populationNight'] for bid in antenna['buildings']) + b['populationNight']
                    
                    if max(total_peak, total_off_peak, total_night) <= antenna_spec['capacity']:
                        antenna['buildings'].append(bid)
                        added = True
                        break
            
            if not added:
                # Create new antenna
                for antenna_type in ANTENNA_TYPES_BY_CAPACITY:
                    antenna_spec = ANTENNA_TYPES[antenna_type]
                    demand = building_demands[bid]
                    if demand <= antenna_spec['capacity']:
                        antennas.append({
                            'type': antenna_type,
                            'x': b['x'],
                            'y': b['y'],
                            'buildings': [bid]
                        })
                        break
    
    return antennas