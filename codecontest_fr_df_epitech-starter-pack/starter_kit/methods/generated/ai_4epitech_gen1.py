"""
AI-Generated Solver
Generated: 2025-12-29 17:24:31
Model: claude-sonnet-4-5-20250929

This solver was automatically generated by Claude AI based on
analysis of existing solver performance patterns.
"""

"""
Adaptive spatial clustering solver optimized for large dense datasets.

Strategy for 4_epitech (5000 buildings, dense, low clustering):
1. Create density-weighted spatial grid to identify placement zones
2. Use hierarchical facility placement: hub antennas first, then fill gaps
3. Multi-phase optimization: construction -> consolidation -> refinement
4. Exploit scale with adaptive parameters based on dataset size
"""

import random
import math
from typing import Dict, List, Set, Tuple, Optional
from collections import defaultdict
from .base import (
    SolverResult,
    ANTENNA_TYPES,
    ANTENNA_TYPES_BY_CAPACITY,
    get_building_demand,
    is_in_range,
    distance
)


def solve(dataset: dict, *, seed: int, params: dict = None) -> SolverResult:
    """
    Adaptive spatial clustering solver for large dense datasets.
    """
    rng = random.Random(seed)
    buildings = dataset['buildings']
    
    # Precompute building data
    building_by_id = {b['id']: b for b in buildings}
    building_demands = {b['id']: get_building_demand(b) for b in buildings}
    
    # Phase 1: Density-based grid analysis
    grid_size = 100
    density_grid = compute_density_grid(buildings, building_demands, grid_size)
    
    # Phase 2: Hierarchical hub placement
    hubs = place_hub_antennas(buildings, building_by_id, building_demands, density_grid, grid_size, rng)
    
    # Phase 3: Greedy fill remaining buildings
    covered = set()
    for antenna in hubs:
        covered.update(antenna['buildings'])
    
    antennas = hubs.copy()
    remaining = [b for b in buildings if b['id'] not in covered]
    
    if remaining:
        fill_antennas = greedy_fill_phase(remaining, buildings, building_by_id, building_demands, covered, rng)
        antennas.extend(fill_antennas)
        covered.update(bid for ant in fill_antennas for bid in ant['buildings'])
    
    # Phase 4: Consolidation - merge small antennas
    antennas = consolidation_phase(antennas, buildings, building_by_id, building_demands, rng)
    
    # Phase 5: Local refinement - reassign buildings to better antennas
    antennas = refinement_phase(antennas, buildings, building_by_id, building_demands)
    
    # Ensure all buildings covered
    all_covered = set(bid for ant in antennas for bid in ant['buildings'])
    uncovered = set(b['id'] for b in buildings) - all_covered
    
    if uncovered:
        for bid in uncovered:
            b = building_by_id[bid]
            antennas.append({
                'type': 'MaxRange',
                'x': b['x'],
                'y': b['y'],
                'buildings': [bid]
            })
    
    return {'antennas': antennas}


def compute_density_grid(buildings: List[dict], building_demands: Dict[int, int], 
                         grid_size: int) -> List[List[float]]:
    """Compute density heatmap for strategic antenna placement."""
    if not buildings:
        return [[0] * grid_size for _ in range(grid_size)]
    
    # Find bounds
    min_x = min(b['x'] for b in buildings)
    max_x = max(b['x'] for b in buildings)
    min_y = min(b['y'] for b in buildings)
    max_y = max(b['y'] for b in buildings)
    
    width = max_x - min_x + 1
    height = max_y - min_y + 1
    
    grid = [[0.0] * grid_size for _ in range(grid_size)]
    
    for b in buildings:
        grid_x = min(int((b['x'] - min_x) / width * grid_size), grid_size - 1)
        grid_y = min(int((b['y'] - min_y) / height * grid_size), grid_size - 1)
        
        demand = building_demands[b['id']]
        
        # Spread demand to nearby cells
        for dx in range(-2, 3):
            for dy in range(-2, 3):
                nx, ny = grid_x + dx, grid_y + dy
                if 0 <= nx < grid_size and 0 <= ny < grid_size:
                    dist_factor = 1.0 / (1.0 + abs(dx) + abs(dy))
                    grid[ny][nx] += demand * dist_factor
    
    return grid


def place_hub_antennas(buildings: List[dict], building_by_id: Dict[int, dict],
                       building_demands: Dict[int, int], density_grid: List[List[float]],
                       grid_size: int, rng: random.Random) -> List[dict]:
    """Place strategic hub antennas at density hotspots."""
    if not buildings:
        return []
    
    min_x = min(b['x'] for b in buildings)
    max_x = max(b['x'] for b in buildings)
    min_y = min(b['y'] for b in buildings)
    max_y = max(b['y'] for b in buildings)
    
    width = max_x - min_x + 1
    height = max_y - min_y + 1
    
    # Find top density hotspots
    hotspots = []
    for gy in range(grid_size):
        for gx in range(grid_size):
            if density_grid[gy][gx] > 0:
                hotspots.append((density_grid[gy][gx], gx, gy))
    
    hotspots.sort(reverse=True)
    
    # Select top hotspots with spatial diversity
    num_hubs = max(5, int(math.sqrt(len(buildings)) / 3))
    selected_hotspots = []
    min_separation = grid_size / 5
    
    for density, gx, gy in hotspots:
        if len(selected_hotspots) >= num_hubs:
            break
        
        # Check spatial separation
        too_close = False
        for _, sx, sy in selected_hotspots:
            if abs(gx - sx) + abs(gy - sy) < min_separation:
                too_close = True
                break
        
        if not too_close:
            selected_hotspots.append((density, gx, gy))
    
    # Place antennas at hotspots
    antennas = []
    covered = set()
    
    for _, gx, gy in selected_hotspots:
        # Convert grid coords to world coords
        world_x = int(min_x + (gx / grid_size) * width)
        world_y = int(min_y + (gy / grid_size) * height)
        
        # Find nearest building to this hotspot
        best_building = None
        best_dist = float('inf')
        
        for b in buildings:
            if b['id'] in covered:
                continue
            d = distance(world_x, world_y, b['x'], b['y'])
            if d < best_dist:
                best_dist = d
                best_building = b
        
        if best_building is None:
            continue
        
        # Try to place MaxRange or Density antenna for maximum coverage
        for antenna_type in ['MaxRange', 'Density', 'Spot']:
            antenna_spec = ANTENNA_TYPES[antenna_type]
            antenna_range = antenna_spec['range']
            antenna_capacity = antenna_spec['capacity']
            
            # Find all uncovered buildings within range
            candidates = []
            for b in buildings:
                if b['id'] not in covered:
                    if is_in_range(best_building['x'], best_building['y'], b['x'], b['y'], antenna_range):
                        candidates.append((b['id'], building_demands[b['id']]))
            
            candidates.sort(key=lambda x: x[1], reverse=True)
            
            # Pack greedily
            assignment = []
            total_peak = 0
            total_off_peak = 0
            total_night = 0
            
            for bid, _ in candidates:
                cb = building_by_id[bid]
                new_peak = total_peak + cb['populationPeakHours']
                new_off_peak = total_off_peak + cb['populationOffPeakHours']
                new_night = total_night + cb['populationNight']
                
                if max(new_peak, new_off_peak, new_night) <= antenna_capacity:
                    assignment.append(bid)
                    total_peak = new_peak
                    total_off_peak = new_off_peak
                    total_night = new_night
            
            if len(assignment) >= 3:  # Only create hub if it covers multiple buildings
                antennas.append({
                    'type': antenna_type,
                    'x': best_building['x'],
                    'y': best_building['y'],
                    'buildings': assignment
                })
                covered.update(assignment)
                break
    
    return antennas


def greedy_fill_phase(remaining: List[dict], all_buildings: List[dict],
                      building_by_id: Dict[int, dict], building_demands: Dict[int, int],
                      covered: Set[int], rng: random.Random) -> List[dict]:
    """Fill remaining buildings with optimally-sized antennas."""
    antennas = []
    
    # Sort remaining by demand descending
    remaining_sorted = sorted(remaining, key=lambda b: building_demands[b['id']], reverse=True)
    
    for building in remaining_sorted:
        bid = building['id']
        
        if bid in covered:
            continue
        
        antenna_x, antenna_y = building['x'], building['y']
        
        # Try antenna types from smallest to largest
        best_antenna = None
        best_assignment = []
        best_efficiency = 0
        
        for antenna_type in ANTENNA_TYPES_BY_CAPACITY:
            antenna_spec = ANTENNA_TYPES[antenna_type]
            antenna_range = antenna_spec['range']
            antenna_capacity = antenna_spec['capacity']
            antenna_cost = antenna_spec['cost']
            
            # Find candidates
            candidates = []
            for b in all_buildings:
                if b['id'] not in covered:
                    if is_in_range(antenna_x, antenna_y, b['x'], b['y'], antenna_range):
                        candidates.append((b['id'], building_demands[b['id']]))
            
            candidates.sort(key=lambda x: x[1], reverse=True)
            
            # Pack
            assignment = []
            total_peak = 0
            total_off_peak = 0
            total_night = 0
            
            for cid, _ in candidates:
                cb = building_by_id[cid]
                new_peak = total_peak + cb['populationPeakHours']
                new_off_peak = total_off_peak + cb['populationOffPeakHours']
                new_night = total_night + cb['populationNight']
                
                if max(new_peak, new_off_peak, new_night) <= antenna_capacity:
                    assignment.append(cid)
                    total_peak = new_peak
                    total_off_peak = new_off_peak
                    total_night = new_night
            
            if bid in assignment:
                efficiency = len(assignment) / antenna_cost
                if efficiency > best_efficiency:
                    best_antenna = antenna_type
                    best_assignment = assignment
                    best_efficiency = efficiency
        
        if best_antenna is None:
            best_antenna = 'MaxRange'
            best_assignment = [bid]
        
        antennas.append({
            'type': best_antenna,
            'x': antenna_x,
            'y': antenna_y,
            'buildings': best_assignment
        })
        
        covered.update(best_assignment)
    
    return antennas


def consolidation_phase(antennas: List[dict], buildings: List[dict],
                        building_by_id: Dict[int, dict], building_demands: Dict[int, int],
                        rng: random.Random) -> List[dict]:
    """Merge small antennas into larger ones where beneficial."""
    # Find small antennas (covering 1-2 buildings)
    small_antennas = [a for a in antennas if len(a['buildings']) <= 2]
    large_antennas = [a for a in antennas if len(a['buildings']) > 2]
    
    if len(small_antennas) < 2:
        return antennas
    
    # Try to merge nearby small antennas
    merged = set()
    new_antennas = large_antennas.copy()
    
    for i, ant1 in enumerate(small_antennas):
        if i in merged:
            continue
        
        # Find nearby small antennas
        nearby = []
        for j, ant2 in enumerate(small_antennas):
            if i != j and j not in merged:
                dist = distance(ant1['x'], ant1['y'], ant2['x'], ant2['y'])
                if dist < 2000:  # Within reasonable range
                    nearby.append((j, ant2, dist))
        
        if not nearby:
            new_antennas.append(ant1)
            continue
        
        # Try to merge with closest
        nearby.sort(key=lambda x: x[2])
        
        for j, ant2, dist in nearby[:3]:  # Try up to 3 closest
            combined_buildings = ant1['buildings'] + ant2['buildings']
            
            # Find centroid
            total_x = sum(building_by_id[bid]['x'] for bid in combined_buildings)
            total_y = sum(building_by_id[bid]['y'] for bid in combined_buildings)
            centroid_x = total_x // len(combined_buildings)
            centroid_y = total_y // len(combined_buildings)
            
            # Find nearest building to centroid
            best_loc = None
            best_loc_dist = float('inf')
            for bid in combined_buildings:
                b = building_by_id[bid]
                d = distance(centroid_x, centroid_y, b['x'], b['y'])
                if d < best_loc_dist:
                    best_loc_dist = d
                    best_loc = (b['x'], b['y'])
            
            # Try to fit in a single antenna
            for antenna_type in ANTENNA_TYPES_BY_CAPACITY:
                antenna_spec = ANTENNA_TYPES[antenna_type]
                
                # Check all buildings in range and capacity
                in_range_buildings = []
                total_peak = 0
                total_off_peak = 0
                total_night = 0
                
                for bid in combined_buildings:
                    b = building_by_id[bid]
                    if is_in_range(best_loc[0], best_loc[1], b['x'], b['y'], antenna_spec['range']):
                        total_peak += b['populationPeakHours']
                        total_off_peak += b['populationOffPeakHours']
                        total_night += b['populationNight']
                        in_range_buildings.append(bid)
                
                if len(in_range_buildings) == len(combined_buildings):
                    if max(total_peak, total_off_peak, total_night) <= antenna_spec['capacity']:
                        # Merge successful
                        new_antennas.append({
                            'type': antenna_type,
                            'x': best_loc[0],
                            'y': best_loc[1],
                            'buildings': in_range_buildings
                        })
                        merged.add(i)
                        merged.add(j)
                        break
                
            if i in merged:
                break
        
        if i not in merged:
            new_antennas.append(ant1)
    
    return new_antennas


def refinement_phase(antennas: List[dict], buildings: List[dict],
                     building_by_id: Dict[int, dict], building_demands: Dict[int, int]) -> List[dict]:
    """Reassign buildings to better antennas where possible."""
    # Build antenna lookup
    building_to_antenna = {}
    for idx, antenna in enumerate(antennas):
        for bid in antenna['buildings']:
            building_to_antenna[bid] = idx
    
    # Try to reassign buildings from expensive antennas to cheaper nearby ones
    changed = True
    iterations = 0
    max_iterations = 5
    
    while changed and iterations < max_iterations:
        changed = False
        iterations += 1
        
        for idx, antenna in enumerate(antennas):
            if len(antenna['buildings']) <= 1:
                continue
            
            # Try to offload buildings to other antennas
            for bid in list(antenna['buildings']):
                b = building_by_id[bid]
                
                # Find alternative antennas that could take this building
                for alt_idx, alt_antenna in enumerate(antennas):
                    if alt_idx == idx:
                        continue
                    
                    antenna_spec = ANTENNA_TYPES[alt_antenna['type']]
                    
                    # Check if in range
                    if not is_in_range(alt_antenna['x'], alt_antenna['y'], b['x'], b['y'], antenna_spec['range']):
                        continue
                    
                    # Check if has capacity
                    total_peak = sum(building_by_id[bid2]['populationPeakHours'] for bid2 in alt_antenna['buildings'])
                    total_off_peak = sum(building_by_id[bid2]['populationOffPeakHours'] for bid2 in alt_antenna['buildings'])
                    total_night = sum(building_by_id[bid2]['populationNight'] for bid2 in alt_antenna['buildings'])
                    
                    new_peak = total_peak + b['populationPeakHours']
                    new_off_peak = total_off_peak + b['populationOffPeakHours']
                    new_night = total_night + b['populationNight']
                    
                    if max(new_peak, new_off_peak, new_night) <= antenna_spec['capacity']:
                        # Move is possible - check if beneficial
                        current_cost = ANTENNA_TYPES[antenna['type']]['cost']
                        alt_cost = ANTENNA_TYPES[alt_antenna['type']]['cost']
                        
                        if alt_cost < current_cost:
                            # Make the move
                            antenna['buildings'].remove(bid)
                            alt_antenna['buildings'].append(bid)
                            building_to_antenna[bid] = alt_idx
                            changed = True
                            break
    
    # Remove empty antennas
    antennas = [a for a in antennas if len(a['buildings']) > 0]
    
    return antennas