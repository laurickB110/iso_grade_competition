"""
AI-Generated Solver
Generated: 2025-12-29 22:24:33
Model: claude-sonnet-4-5-20250929

This solver was automatically generated by Claude AI based on
analysis of existing solver performance patterns.
"""

"""
Hierarchical clustering solver with demand-weighted placement optimization.

Strategy for 4_epitech (5000 buildings, low clustering, dense distribution):
1. Use spatial decomposition via quadtree to handle large dataset efficiently
2. Apply demand-weighted k-means clustering within each quadrant
3. Optimize antenna placement at cluster centroids (weighted by demand)
4. Use mixed antenna types based on local density and demand patterns
5. Post-optimization phase to consolidate and upgrade antennas
6. Greedy refinement to minimize overlapping coverage
"""
import random
import math
from typing import Dict, List, Set, Tuple, Optional
from collections import defaultdict
from ..base import (
    SolverResult,
    ANTENNA_TYPES,
    ANTENNA_TYPES_BY_CAPACITY,
    get_building_demand,
    is_in_range,
    distance
)


def solve(dataset: dict, *, seed: int, params: dict = None) -> SolverResult:
    """
    Hierarchical clustering solver optimized for dense, large datasets.
    
    Args:
        dataset: Dataset dict with 'buildings' key
        seed: Random seed for reproducibility
        params: Optional parameters
        
    Returns:
        SolverResult with optimized antenna placement
    """
    if params is None:
        params = {}
    
    rng = random.Random(seed)
    buildings = dataset['buildings']
    
    # Precompute building data
    building_by_id = {b['id']: b for b in buildings}
    building_demands = {b['id']: get_building_demand(b) for b in buildings}
    
    # Phase 1: Spatial decomposition and clustering
    clusters = spatial_decomposition_clustering(buildings, building_demands, rng)
    
    # Phase 2: Initial antenna placement at cluster centroids
    antennas = []
    covered = set()
    
    for cluster_buildings in clusters:
        if not cluster_buildings:
            continue
            
        # Calculate demand-weighted centroid
        cx, cy = calculate_weighted_centroid(cluster_buildings, building_demands)
        
        # Find best antenna placement near centroid
        antenna_pos = find_optimal_antenna_position(
            cx, cy, cluster_buildings, building_by_id, rng
        )
        
        # Determine optimal antenna type for this cluster
        new_antennas = place_antennas_for_cluster(
            antenna_pos[0], antenna_pos[1],
            cluster_buildings,
            building_by_id,
            building_demands,
            covered
        )
        
        antennas.extend(new_antennas)
    
    # Phase 3: Cover any remaining buildings
    all_building_ids = {b['id'] for b in buildings}
    uncovered = all_building_ids - covered
    
    if uncovered:
        antennas.extend(cover_remaining_buildings(
            uncovered, building_by_id, building_demands, covered
        ))
    
    # Phase 4: Post-optimization - consolidate and upgrade
    antennas = consolidate_antennas(antennas, buildings, building_by_id, building_demands)
    
    # Phase 5: Final refinement - reduce overlap
    antennas = reduce_overlap(antennas, buildings, building_by_id, building_demands, rng)
    
    return {'antennas': antennas}


def spatial_decomposition_clustering(buildings: List[dict], 
                                    building_demands: Dict[int, int],
                                    rng: random.Random,
                                    num_clusters: int = 40) -> List[List[dict]]:
    """
    Decompose space and cluster buildings using demand-weighted k-means.
    """
    if not buildings:
        return []
    
    # Calculate bounds
    min_x = min(b['x'] for b in buildings)
    max_x = max(b['x'] for b in buildings)
    min_y = min(b['y'] for b in buildings)
    max_y = max(b['y'] for b in buildings)
    
    # Adaptive number of clusters based on dataset size and spread
    area = (max_x - min_x) * (max_y - min_y)
    density = len(buildings) / max(area, 1)
    num_clusters = min(num_clusters, max(10, len(buildings) // 100))
    
    # Initialize cluster centers randomly weighted by demand
    total_demand = sum(building_demands[b['id']] for b in buildings)
    centers = []
    
    for _ in range(num_clusters):
        # Weighted random selection
        r = rng.uniform(0, total_demand)
        cumsum = 0
        for b in buildings:
            cumsum += building_demands[b['id']]
            if cumsum >= r:
                centers.append((float(b['x']), float(b['y'])))
                break
    
    # K-means with demand weighting
    for iteration in range(15):
        # Assign buildings to nearest center
        assignments = [[] for _ in range(num_clusters)]
        
        for b in buildings:
            min_dist = float('inf')
            best_cluster = 0
            
            for i, (cx, cy) in enumerate(centers):
                dist = distance(b['x'], b['y'], cx, cy)
                # Weight distance by inverse demand (high demand = prefer closer)
                weighted_dist = dist / math.sqrt(building_demands[b['id']] + 1)
                
                if weighted_dist < min_dist:
                    min_dist = weighted_dist
                    best_cluster = i
            
            assignments[best_cluster].append(b)
        
        # Update centers (demand-weighted centroid)
        new_centers = []
        for cluster in assignments:
            if cluster:
                cx, cy = calculate_weighted_centroid(cluster, building_demands)
                new_centers.append((cx, cy))
            else:
                # Keep old center if cluster is empty
                new_centers.append(centers[len(new_centers)])
        
        centers = new_centers
    
    # Final assignment
    clusters = [[] for _ in range(num_clusters)]
    for b in buildings:
        min_dist = float('inf')
        best_cluster = 0
        
        for i, (cx, cy) in enumerate(centers):
            dist = distance(b['x'], b['y'], cx, cy)
            if dist < min_dist:
                min_dist = dist
                best_cluster = i
        
        clusters[best_cluster].append(b)
    
    return [c for c in clusters if c]


def calculate_weighted_centroid(buildings: List[dict], 
                               building_demands: Dict[int, int]) -> Tuple[float, float]:
    """Calculate demand-weighted centroid of buildings."""
    if not buildings:
        return (0.0, 0.0)
    
    total_demand = sum(building_demands[b['id']] for b in buildings)
    if total_demand == 0:
        # Fallback to simple average
        cx = sum(b['x'] for b in buildings) / len(buildings)
        cy = sum(b['y'] for b in buildings) / len(buildings)
        return (cx, cy)
    
    cx = sum(b['x'] * building_demands[b['id']] for b in buildings) / total_demand
    cy = sum(b['y'] * building_demands[b['id']] for b in buildings) / total_demand
    
    return (cx, cy)


def find_optimal_antenna_position(cx: float, cy: float,
                                 cluster_buildings: List[dict],
                                 building_by_id: Dict[int, dict],
                                 rng: random.Random) -> Tuple[int, int]:
    """
    Find optimal antenna position near centroid.
    Prefer building locations for cost discount.
    """
    # Find building closest to centroid
    min_dist = float('inf')
    best_pos = (int(cx), int(cy))
    
    for b in cluster_buildings:
        dist = distance(cx, cy, b['x'], b['y'])
        if dist < min_dist:
            min_dist = dist
            best_pos = (b['x'], b['y'])
    
    return best_pos


def place_antennas_for_cluster(x: int, y: int,
                               cluster_buildings: List[dict],
                               building_by_id: Dict[int, dict],
                               building_demands: Dict[int, int],
                               covered: Set[int]) -> List[dict]:
    """
    Place antennas to cover a cluster optimally.
    """
    antennas = []
    local_covered = set()
    
    # Sort buildings by distance to antenna position, then by demand
    sorted_buildings = sorted(
        cluster_buildings,
        key=lambda b: (distance(x, y, b['x'], b['y']), -building_demands[b['id']])
    )
    
    while len(local_covered) < len(cluster_buildings):
        # Try each antenna type from smallest to largest
        best_antenna = None
        best_assignment = []
        best_score = -1
        
        for antenna_type in ANTENNA_TYPES_BY_CAPACITY:
            antenna_spec = ANTENNA_TYPES[antenna_type]
            antenna_range = antenna_spec['range']
            antenna_capacity = antenna_spec['capacity']
            antenna_cost = antenna_spec['cost']
            
            # Check if antenna position is on a building
            on_building = any(b['x'] == x and b['y'] == y for b in cluster_buildings)
            if on_building:
                antenna_cost = antenna_cost // 10
            
            # Find uncovered buildings in range
            candidates = []
            for b in sorted_buildings:
                if b['id'] not in local_covered and b['id'] not in covered:
                    if is_in_range(x, y, b['x'], b['y'], antenna_range):
                        candidates.append(b)
            
            if not candidates:
                continue
            
            # Pack buildings into antenna
            assignment = []
            total_peak = 0
            total_off_peak = 0
            total_night = 0
            
            for b in candidates:
                new_peak = total_peak + b['populationPeakHours']
                new_off_peak = total_off_peak + b['populationOffPeakHours']
                new_night = total_night + b['populationNight']
                new_max = max(new_peak, new_off_peak, new_night)
                
                if new_max <= antenna_capacity:
                    assignment.append(b['id'])
                    total_peak = new_peak
                    total_off_peak = new_off_peak
                    total_night = new_night
            
            if assignment:
                # Score: buildings covered per cost unit
                score = len(assignment) / antenna_cost
                if score > best_score:
                    best_score = score
                    best_antenna = antenna_type
                    best_assignment = assignment
        
        if best_antenna:
            antennas.append({
                'type': best_antenna,
                'x': x,
                'y': y,
                'buildings': best_assignment
            })
            local_covered.update(best_assignment)
            covered.update(best_assignment)
        else:
            # No more buildings can be covered from this position
            break
    
    return antennas


def cover_remaining_buildings(uncovered: Set[int],
                              building_by_id: Dict[int, dict],
                              building_demands: Dict[int, int],
                              covered: Set[int]) -> List[dict]:
    """Cover remaining uncovered buildings efficiently."""
    antennas = []
    remaining = uncovered.copy()
    
    # Sort by demand (descending)
    sorted_uncovered = sorted(remaining, key=lambda bid: building_demands[bid], reverse=True)
    
    for bid in sorted_uncovered:
        if bid in covered:
            continue
        
        b = building_by_id[bid]
        
        # Try to find smallest antenna that works
        for antenna_type in ANTENNA_TYPES_BY_CAPACITY:
            antenna_spec = ANTENNA_TYPES[antenna_type]
            antenna_range = antenna_spec['range']
            antenna_capacity = antenna_spec['capacity']
            
            # Find nearby uncovered buildings
            assignment = []
            total_peak = 0
            total_off_peak = 0
            total_night = 0
            
            for other_bid in remaining:
                if other_bid in covered:
                    continue
                    
                other_b = building_by_id[other_bid]
                if is_in_range(b['x'], b['y'], other_b['x'], other_b['y'], antenna_range):
                    new_peak = total_peak + other_b['populationPeakHours']
                    new_off_peak = total_off_peak + other_b['populationOffPeakHours']
                    new_night = total_night + other_b['populationNight']
                    new_max = max(new_peak, new_off_peak, new_night)
                    
                    if new_max <= antenna_capacity:
                        assignment.append(other_bid)
                        total_peak = new_peak
                        total_off_peak = new_off_peak
                        total_night = new_night
            
            if bid in assignment:
                antennas.append({
                    'type': antenna_type,
                    'x': b['x'],
                    'y': b['y'],
                    'buildings': assignment
                })
                covered.update(assignment)
                break
    
    return antennas


def consolidate_antennas(antennas: List[dict],
                        buildings: List[dict],
                        building_by_id: Dict[int, dict],
                        building_demands: Dict[int, int]) -> List[dict]:
    """
    Consolidate antennas by merging nearby ones with spare capacity.
    """
    if len(antennas) <= 1:
        return antennas
    
    # Sort antennas by number of buildings (ascending)
    sorted_antennas = sorted(antennas, key=lambda a: len(a['buildings']))
    
    consolidated = []
    merged = set()
    
    for i, ant in enumerate(sorted_antennas):
        if i in merged:
            continue
        
        # Try to merge this antenna with nearby ones
        best_merge = None
        best_savings = 0
        
        for j, other_ant in enumerate(sorted_antennas):
            if i == j or j in merged:
                continue
            
            # Check if antennas are close
            dist = distance(ant['x'], ant['y'], other_ant['x'], other_ant['y'])
            if dist > 300:  # Arbitrary threshold
                continue
            
            # Try to merge into a single antenna
            all_buildings = set(ant['buildings']) | set(other_ant['buildings'])
            
            # Find smallest antenna type that can cover all
            for antenna_type in ANTENNA_TYPES_BY_CAPACITY:
                antenna_spec = ANTENNA_TYPES[antenna_type]
                antenna_range = antenna_spec['range']
                antenna_capacity = antenna_spec['capacity']
                
                # Use midpoint as new position
                new_x = (ant['x'] + other_ant['x']) // 2
                new_y = (ant['y'] + other_ant['y']) // 2
                
                # Check if all buildings are in range
                in_range_count = 0
                total_peak = 0
                total_off_peak = 0
                total_night = 0
                
                for bid in all_buildings:
                    b = building_by_id[bid]
                    if is_in_range(new_x, new_y, b['x'], b['y'], antenna_range):
                        in_range_count += 1
                        total_peak += b['populationPeakHours']
                        total_off_peak += b['populationOffPeakHours']
                        total_night += b['populationNight']
                
                if in_range_count == len(all_buildings):
                    if max(total_peak, total_off_peak, total_night) <= antenna_capacity:
                        # Calculate savings
                        old_cost = (ANTENNA_TYPES[ant['type']]['cost'] // 10 +
                                   ANTENNA_TYPES[other_ant['type']]['cost'] // 10)
                        new_cost = ANTENNA_TYPES[antenna_type]['cost']
                        
                        savings = old_cost - new_cost
                        if savings > best_savings:
                            best_savings = savings
                            best_merge = (j, antenna_type, new_x, new_y, list(all_buildings))
                        break
        
        if best_merge:
            j, antenna_type, new_x, new_y, all_buildings = best_merge
            consolidated.append({
                'type': antenna_type,
                'x': new_x,
                'y': new_y,
                'buildings': all_buildings
            })
            merged.add(i)
            merged.add(j)
        else:
            consolidated.append(ant)
            merged.add(i)
    
    return consolidated


def reduce_overlap(antennas: List[dict],
                   buildings: List[dict],
                   building_by_id: Dict[int, dict],
                   building_demands: Dict[int, int],
                   rng: random.Random) -> List[dict]:
    """
    Reduce overlapping coverage by reassigning buildings.
    """
    # Build coverage map
    building_coverage = defaultdict(list)
    for i, ant in enumerate(antennas):
        for bid in ant['buildings']:
            building_coverage[bid].append(i)
    
    # Reassign buildings covered by multiple antennas
    for bid, antenna_indices in building_coverage.items():
        if len(antenna_indices) <= 1:
            continue
        
        b = building_by_id[bid]
        
        # Find best antenna (closest, most spare capacity)
        best_antenna = None
        best_score = float('inf')
        
        for ant_idx in antenna_indices:
            ant = antennas[ant_idx]
            ant_spec = ANTENNA_TYPES[ant['type']]
            
            # Calculate current load
            total_peak = sum(building_by_id[b_id]['populationPeakHours'] for b_id in ant['buildings'])
            total_off_peak = sum(building_by_id[b_id]['populationOffPeakHours'] for b_id in ant['buildings'])
            total_night = sum(building_by_id[b_id]['populationNight'] for b_id in ant['buildings'])
            current_load = max(total_peak, total_off_peak, total_night)
            
            spare_capacity = ant_spec['capacity'] - current_load
            dist = distance(ant['x'], ant['y'], b['x'], b['y'])
            
            # Score: prefer closer with more spare capacity
            score = dist / (spare_capacity + 1)
            
            if score < best_score:
                best_score = score
                best_antenna = ant_idx
        
        # Remove from all others
        for ant_idx in antenna_indices:
            if ant_idx != best_antenna:
                antennas[ant_idx]['buildings'] = [
                    b_id for b_id in antennas[ant_idx]['buildings'] if b_id != bid
                ]
    
    # Remove empty antennas
    antennas = [ant for ant in antennas if ant['buildings']]
    
    return antennas