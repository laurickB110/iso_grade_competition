"""
AI-Generated Solver
Generated: 2025-12-30 11:13:53
Model: claude-sonnet-4-5-20250929

This solver was automatically generated by Claude AI based on
analysis of existing solver performance patterns.
"""

"""
Cluster-optimized solver for small sparse datasets with high clustering.

Strategy:
1. Identify optimal cluster centroid using geometric median weighted by demand
2. Try single-antenna solution first (optimal for small clustered problems)
3. If single antenna fails, use exhaustive search over antenna placements
4. For each configuration, try all antenna type combinations
5. Select minimum cost solution that covers all buildings

Optimized for: 5 buildings, high clustering, sparse distribution
"""
import random
from typing import Dict, List, Set, Tuple, Optional
from itertools import combinations, product
from .base import (
    SolverResult,
    ANTENNA_TYPES,
    ANTENNA_TYPES_BY_CAPACITY,
    get_building_demand,
    is_in_range,
    distance
)


def solve(dataset: dict, *, seed: int, params: dict = None) -> SolverResult:
    """
    Cluster-optimized exhaustive search solver for small instances.
    
    Args:
        dataset: Dataset dict with 'buildings' key
        seed: Random seed for reproducibility
        params: Optional parameters (not used)
    
    Returns:
        SolverResult with optimal or near-optimal solution
    """
    rng = random.Random(seed)
    buildings = dataset['buildings']
    n = len(buildings)
    
    # Precompute building info
    building_by_id = {b['id']: b for b in buildings}
    building_demands = {b['id']: get_building_demand(b) for b in buildings}
    
    # Calculate weighted centroid for cluster center
    centroid = calculate_weighted_centroid(buildings, building_demands)
    
    # Try single antenna solution first (likely optimal for highly clustered data)
    single_antenna = try_single_antenna(buildings, building_by_id, centroid)
    if single_antenna:
        return {'antennas': [single_antenna]}
    
    # Generate candidate antenna positions
    candidate_positions = generate_candidate_positions(buildings, centroid)
    
    # Try increasing number of antennas until solution found
    best_solution = None
    best_cost = float('inf')
    
    for num_antennas in range(1, n + 1):
        # Try different position combinations
        for positions in combinations(candidate_positions, min(num_antennas, len(candidate_positions))):
            # Try different antenna type combinations
            solution = find_best_assignment(buildings, building_by_id, positions)
            if solution:
                cost = calculate_solution_cost(solution, buildings)
                if cost < best_cost:
                    best_cost = cost
                    best_solution = solution
        
        if best_solution:
            break
    
    # Fallback: place MaxRange on each building
    if not best_solution:
        best_solution = []
        for b in buildings:
            best_solution.append({
                'type': 'MaxRange',
                'x': b['x'],
                'y': b['y'],
                'buildings': [b['id']]
            })
    
    return {'antennas': best_solution}


def calculate_weighted_centroid(buildings: List[dict], demands: Dict[int, int]) -> Tuple[int, int]:
    """Calculate demand-weighted geometric center of buildings."""
    total_weight = 0
    weighted_x = 0
    weighted_y = 0
    
    for b in buildings:
        weight = demands[b['id']]
        weighted_x += b['x'] * weight
        weighted_y += b['y'] * weight
        total_weight += weight
    
    if total_weight > 0:
        center_x = int(weighted_x / total_weight)
        center_y = int(weighted_y / total_weight)
    else:
        center_x = int(sum(b['x'] for b in buildings) / len(buildings))
        center_y = int(sum(b['y'] for b in buildings) / len(buildings))
    
    return (center_x, center_y)


def try_single_antenna(buildings: List[dict], building_by_id: Dict[int, dict], 
                       centroid: Tuple[int, int]) -> Optional[dict]:
    """Try to cover all buildings with a single antenna at optimal position."""
    positions_to_try = [centroid]
    
    # Also try each building location
    for b in buildings:
        positions_to_try.append((b['x'], b['y']))
    
    for x, y in positions_to_try:
        # Try antenna types from smallest to largest
        for antenna_type in ANTENNA_TYPES_BY_CAPACITY:
            spec = ANTENNA_TYPES[antenna_type]
            
            # Check if all buildings are in range
            in_range_buildings = []
            for b in buildings:
                if is_in_range(x, y, b['x'], b['y'], spec['range']):
                    in_range_buildings.append(b['id'])
            
            if len(in_range_buildings) != len(buildings):
                continue
            
            # Check capacity constraint
            total_peak = sum(building_by_id[bid]['populationPeakHours'] for bid in in_range_buildings)
            total_off_peak = sum(building_by_id[bid]['populationOffPeakHours'] for bid in in_range_buildings)
            total_night = sum(building_by_id[bid]['populationNight'] for bid in in_range_buildings)
            max_load = max(total_peak, total_off_peak, total_night)
            
            if max_load <= spec['capacity']:
                return {
                    'type': antenna_type,
                    'x': x,
                    'y': y,
                    'buildings': in_range_buildings
                }
    
    return None


def generate_candidate_positions(buildings: List[dict], centroid: Tuple[int, int]) -> List[Tuple[int, int]]:
    """Generate candidate antenna positions including buildings and cluster center."""
    positions = [centroid]
    
    # Add all building positions
    for b in buildings:
        pos = (b['x'], b['y'])
        if pos not in positions:
            positions.append(pos)
    
    # Add midpoints between buildings for better coverage
    for i, b1 in enumerate(buildings):
        for b2 in buildings[i+1:]:
            mid_x = (b1['x'] + b2['x']) // 2
            mid_y = (b1['y'] + b2['y']) // 2
            pos = (mid_x, mid_y)
            if pos not in positions:
                positions.append(pos)
    
    return positions


def find_best_assignment(buildings: List[dict], building_by_id: Dict[int, dict],
                        positions: Tuple[Tuple[int, int], ...]) -> Optional[List[dict]]:
    """Find best antenna assignment for given positions using exhaustive search."""
    n_positions = len(positions)
    all_building_ids = {b['id'] for b in buildings}
    
    # Try all combinations of antenna types for these positions
    antenna_type_combinations = product(ANTENNA_TYPES_BY_CAPACITY, repeat=n_positions)
    
    best_assignment = None
    best_cost = float('inf')
    
    for antenna_types in antenna_type_combinations:
        # For each antenna type combo, find optimal building assignment
        antennas = []
        
        for pos, antenna_type in zip(positions, antenna_types):
            x, y = pos
            spec = ANTENNA_TYPES[antenna_type]
            
            antennas.append({
                'type': antenna_type,
                'x': x,
                'y': y,
                'range': spec['range'],
                'capacity': spec['capacity'],
                'buildings': []
            })
        
        # Assign buildings to antennas optimally
        assignment = assign_buildings_to_antennas(buildings, building_by_id, antennas)
        
        if assignment:
            # Check if all buildings covered
            covered = set()
            for ant in assignment:
                covered.update(ant['buildings'])
            
            if covered == all_building_ids:
                cost = calculate_solution_cost(assignment, buildings)
                if cost < best_cost:
                    best_cost = cost
                    best_assignment = assignment
    
    return best_assignment


def assign_buildings_to_antennas(buildings: List[dict], building_by_id: Dict[int, dict],
                                antennas: List[dict]) -> Optional[List[dict]]:
    """Assign buildings to antennas to maximize coverage within constraints."""
    building_ids = [b['id'] for b in buildings]
    n_buildings = len(building_ids)
    
    # Try all possible assignments (each building to each antenna)
    # For small n, this is feasible
    def try_assignment(building_idx: int, current_loads: List[Tuple[int, int, int]],
                      current_assignments: List[List[int]]) -> bool:
        if building_idx == n_buildings:
            return True
        
        bid = building_ids[building_idx]
        b = building_by_id[bid]
        
        # Try assigning to each antenna
        for ant_idx, antenna in enumerate(antennas):
            # Check range
            if not is_in_range(antenna['x'], antenna['y'], b['x'], b['y'], antenna['range']):
                continue
            
            # Check capacity
            peak, off_peak, night = current_loads[ant_idx]
            new_peak = peak + b['populationPeakHours']
            new_off_peak = off_peak + b['populationOffPeakHours']
            new_night = night + b['populationNight']
            
            if max(new_peak, new_off_peak, new_night) <= antenna['capacity']:
                # Assign and recurse
                current_assignments[ant_idx].append(bid)
                old_load = current_loads[ant_idx]
                current_loads[ant_idx] = (new_peak, new_off_peak, new_night)
                
                if try_assignment(building_idx + 1, current_loads, current_assignments):
                    return True
                
                # Backtrack
                current_assignments[ant_idx].pop()
                current_loads[ant_idx] = old_load
        
        return False
    
    # Initialize
    loads = [(0, 0, 0) for _ in antennas]
    assignments = [[] for _ in antennas]
    
    if try_assignment(0, loads, assignments):
        # Build result
        result = []
        for ant, assigned_buildings in zip(antennas, assignments):
            if assigned_buildings:
                result.append({
                    'type': ant['type'],
                    'x': ant['x'],
                    'y': ant['y'],
                    'buildings': assigned_buildings
                })
        return result
    
    return None


def calculate_solution_cost(antennas: List[dict], buildings: List[dict]) -> int:
    """Calculate total cost of antenna solution."""
    total_cost = 0
    building_positions = {(b['x'], b['y']) for b in buildings}
    
    for ant in antennas:
        spec = ANTENNA_TYPES[ant['type']]
        base_cost = spec['cost']
        
        # Check if antenna is on building (50% discount)
        if (ant['x'], ant['y']) in building_positions:
            total_cost += base_cost // 2
        else:
            total_cost += base_cost
    
    return total_cost