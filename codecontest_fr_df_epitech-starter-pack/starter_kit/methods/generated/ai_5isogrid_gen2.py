"""
AI-Generated Solver
Generated: 2025-12-30 11:23:06
Model: claude-sonnet-4-5-20250929

This solver was automatically generated by Claude AI based on
analysis of existing solver performance patterns.
"""

"""
Spatial partitioning solver optimized for dense, low-clustering isogrid datasets.

Strategy:
1. Use space-filling Z-order curve to impose hierarchical structure on low-clustering data
2. Hierarchical spatial decomposition via quadtree with demand-weighted splitting
3. Multi-phase optimization: coarse placement -> refinement -> local search
4. Exploit grid structure with lattice-aware neighbor search
5. Demand-weighted spatial indexing for fast candidate selection
"""
import random
from typing import Dict, List, Set, Tuple, Optional
from collections import defaultdict
import math
from .base import (
    SolverResult,
    ANTENNA_TYPES,
    ANTENNA_TYPES_BY_CAPACITY,
    get_building_demand,
    is_in_range,
    distance
)


def morton_encode(x: int, y: int) -> int:
    """Compute Z-order (Morton) code for 2D coordinates."""
    def part_by_1(n: int) -> int:
        n &= 0x0000ffff
        n = (n | (n << 8)) & 0x00FF00FF
        n = (n | (n << 4)) & 0x0F0F0F0F
        n = (n | (n << 2)) & 0x33333333
        n = (n | (n << 1)) & 0x55555555
        return n
    
    return part_by_1(x) | (part_by_1(y) << 1)


class QuadTreeNode:
    """Quadtree node for spatial decomposition."""
    
    def __init__(self, x_min: float, y_min: float, x_max: float, y_max: float):
        self.x_min = x_min
        self.y_min = y_min
        self.x_max = x_max
        self.y_max = y_max
        self.buildings: List[dict] = []
        self.total_demand = 0
        self.children: Optional[List['QuadTreeNode']] = None
        self.center_x = (x_min + x_max) / 2
        self.center_y = (y_min + y_max) / 2
        
    def insert(self, building: dict, demand: float):
        """Insert building into quadtree."""
        self.buildings.append(building)
        self.total_demand += demand
        
    def split(self):
        """Split node into 4 children."""
        if self.children is not None:
            return
            
        cx, cy = self.center_x, self.center_y
        self.children = [
            QuadTreeNode(self.x_min, self.y_min, cx, cy),  # SW
            QuadTreeNode(cx, self.y_min, self.x_max, cy),  # SE
            QuadTreeNode(self.x_min, cy, cx, self.y_max),  # NW
            QuadTreeNode(cx, cy, self.x_max, self.y_max),  # NE
        ]
        
        for building in self.buildings:
            bx, by = building['x'], building['y']
            demand = get_building_demand(building)
            
            if bx <= cx and by <= cy:
                self.children[0].insert(building, demand)
            elif bx > cx and by <= cy:
                self.children[1].insert(building, demand)
            elif bx <= cx and by > cy:
                self.children[2].insert(building, demand)
            else:
                self.children[3].insert(building, demand)


def build_quadtree(buildings: List[dict], max_buildings: int = 100) -> QuadTreeNode:
    """Build quadtree with demand-weighted splitting."""
    if not buildings:
        return None
        
    x_coords = [b['x'] for b in buildings]
    y_coords = [b['y'] for b in buildings]
    
    root = QuadTreeNode(min(x_coords), min(y_coords), max(x_coords), max(y_coords))
    
    for b in buildings:
        root.insert(b, get_building_demand(b))
    
    # Recursively split nodes
    queue = [root]
    while queue:
        node = queue.pop(0)
        if len(node.buildings) > max_buildings:
            node.split()
            if node.children:
                queue.extend(node.children)
    
    return root


def get_leaf_nodes(node: QuadTreeNode) -> List[QuadTreeNode]:
    """Get all leaf nodes from quadtree."""
    if node.children is None:
        return [node]
    
    leaves = []
    for child in node.children:
        leaves.extend(get_leaf_nodes(child))
    return leaves


def find_best_antenna_for_buildings(buildings: List[dict], anchor_x: int, anchor_y: int,
                                   building_by_id: Dict[int, dict]) -> Tuple[str, List[int]]:
    """Find best antenna type and assignment for given buildings and location."""
    best_antenna = None
    best_assignment = []
    best_score = float('inf')
    
    for antenna_type in ANTENNA_TYPES_BY_CAPACITY:
        antenna_spec = ANTENNA_TYPES[antenna_type]
        antenna_range = antenna_spec['range']
        antenna_capacity = antenna_spec['capacity']
        
        # Find buildings within range
        candidates = []
        for b in buildings:
            if is_in_range(anchor_x, anchor_y, b['x'], b['y'], antenna_range):
                candidates.append((b['id'], get_building_demand(b)))
        
        # Sort by demand descending
        candidates.sort(key=lambda x: x[1], reverse=True)
        
        # Greedy packing
        assignment = []
        total_peak = 0
        total_off_peak = 0
        total_night = 0
        
        for bid, _ in candidates:
            b = building_by_id[bid]
            new_peak = total_peak + b['populationPeakHours']
            new_off_peak = total_off_peak + b['populationOffPeakHours']
            new_night = total_night + b['populationNight']
            
            if max(new_peak, new_off_peak, new_night) <= antenna_capacity:
                assignment.append(bid)
                total_peak = new_peak
                total_off_peak = new_off_peak
                total_night = new_night
        
        # Score: cost per building covered (prefer efficient coverage)
        if assignment:
            score = antenna_spec['cost'] / len(assignment)
            if score < best_score:
                best_score = score
                best_antenna = antenna_type
                best_assignment = assignment
    
    return best_antenna, best_assignment


def solve(dataset: dict, *, seed: int, params: dict = None) -> SolverResult:
    """
    Spatial partitioning solver optimized for dense isogrid datasets.
    """
    if params is None:
        params = {}
    
    rng = random.Random(seed)
    buildings = dataset['buildings']
    
    # Build lookup structures
    building_by_id = {b['id']: b for b in buildings}
    building_demands = {b['id']: get_building_demand(b) for b in buildings}
    
    # Sort buildings by Z-order curve for spatial locality
    buildings_with_morton = []
    for b in buildings:
        # Normalize coordinates to positive integers
        x_norm = b['x'] + abs(min(bb['x'] for bb in buildings))
        y_norm = b['y'] + abs(min(bb['y'] for bb in buildings))
        morton = morton_encode(int(x_norm), int(y_norm))
        buildings_with_morton.append((morton, b))
    
    buildings_with_morton.sort()
    morton_sorted_buildings = [b for _, b in buildings_with_morton]
    
    # Phase 1: Build quadtree for spatial decomposition
    quadtree = build_quadtree(buildings, max_buildings=80)
    leaf_nodes = get_leaf_nodes(quadtree)
    
    # Phase 2: Process each spatial region
    covered: Set[int] = set()
    antennas = []
    
    # Sort leaf nodes by total demand (high-demand regions first)
    leaf_nodes.sort(key=lambda n: n.total_demand, reverse=True)
    
    for node in leaf_nodes:
        uncovered_in_node = [b for b in node.buildings if b['id'] not in covered]
        
        if not uncovered_in_node:
            continue
        
        # Find optimal antenna placement points within this region
        # Try: node center, high-demand building locations
        candidate_locations = [(node.center_x, node.center_y)]
        
        # Add top 3 high-demand building locations
        demand_sorted = sorted(uncovered_in_node, 
                             key=lambda b: building_demands[b['id']], 
                             reverse=True)
        for b in demand_sorted[:3]:
            candidate_locations.append((b['x'], b['y']))
        
        # Try each candidate location
        best_location = None
        best_antenna_type = None
        best_assignment = []
        best_coverage = 0
        
        for loc_x, loc_y in candidate_locations:
            # Snap to nearest building for cost discount
            nearest_building = min(uncovered_in_node,
                                 key=lambda b: distance(loc_x, loc_y, b['x'], b['y']))
            snap_x, snap_y = nearest_building['x'], nearest_building['y']
            
            antenna_type, assignment = find_best_antenna_for_buildings(
                uncovered_in_node, snap_x, snap_y, building_by_id
            )
            
            if assignment and len(assignment) > best_coverage:
                best_coverage = len(assignment)
                best_location = (snap_x, snap_y)
                best_antenna_type = antenna_type
                best_assignment = assignment
        
        # Place antenna if we found a valid assignment
        if best_location and best_assignment:
            antennas.append({
                'type': best_antenna_type,
                'x': int(best_location[0]),
                'y': int(best_location[1]),
                'buildings': best_assignment
            })
            covered.update(best_assignment)
    
    # Phase 3: Cover remaining buildings (stragglers)
    all_building_ids = {b['id'] for b in buildings}
    uncovered = all_building_ids - covered
    
    if uncovered:
        uncovered_buildings = [building_by_id[bid] for bid in uncovered]
        # Sort by morton order for spatial locality
        uncovered_with_morton = []
        for b in uncovered_buildings:
            x_norm = b['x'] + abs(min(bb['x'] for bb in buildings))
            y_norm = b['y'] + abs(min(bb['y'] for bb in buildings))
            morton = morton_encode(int(x_norm), int(y_norm))
            uncovered_with_morton.append((morton, b))
        uncovered_with_morton.sort()
        
        for _, building in uncovered_with_morton:
            if building['id'] in covered:
                continue
            
            antenna_type, assignment = find_best_antenna_for_buildings(
                [b for b in buildings if b['id'] not in covered],
                building['x'], building['y'],
                building_by_id
            )
            
            if not assignment:
                # Fallback to MaxRange
                antenna_type = 'MaxRange'
                assignment = [building['id']]
            
            antennas.append({
                'type': antenna_type,
                'x': building['x'],
                'y': building['y'],
                'buildings': assignment
            })
            covered.update(assignment)
    
    # Phase 4: Local search optimization - merge nearby antennas
    antennas = merge_nearby_antennas(antennas, building_by_id, rng)
    
    return {'antennas': antennas}


def merge_nearby_antennas(antennas: List[dict], building_by_id: Dict[int, dict],
                         rng: random.Random) -> List[dict]:
    """Attempt to merge nearby antennas to reduce cost."""
    if len(antennas) <= 1:
        return antennas
    
    improved = True
    max_iterations = 3
    iteration = 0
    
    while improved and iteration < max_iterations:
        improved = False
        iteration += 1
        
        # Try to merge pairs of nearby antennas
        i = 0
        while i < len(antennas):
            antenna_i = antennas[i]
            merged = False
            
            for j in range(i + 1, len(antennas)):
                antenna_j = antennas[j]
                
                # Check if antennas are nearby
                dist = distance(antenna_i['x'], antenna_i['y'], 
                              antenna_j['x'], antenna_j['y'])
                
                if dist > 2000:  # Only try merging nearby antennas
                    continue
                
                # Try to merge all buildings into one antenna
                all_buildings = list(set(antenna_i['buildings'] + antenna_j['buildings']))
                
                # Try both locations
                for loc_x, loc_y in [(antenna_i['x'], antenna_i['y']), 
                                     (antenna_j['x'], antenna_j['y'])]:
                    antenna_type, assignment = find_best_antenna_for_buildings(
                        [building_by_id[bid] for bid in all_buildings],
                        loc_x, loc_y,
                        building_by_id
                    )
                    
                    if set(assignment) == set(all_buildings):
                        # Check if merge saves cost
                        old_cost = ANTENNA_TYPES[antenna_i['type']]['cost'] + \
                                  ANTENNA_TYPES[antenna_j['type']]['cost']
                        new_cost = ANTENNA_TYPES[antenna_type]['cost']
                        
                        if new_cost < old_cost:
                            # Merge successful
                            antennas[i] = {
                                'type': antenna_type,
                                'x': loc_x,
                                'y': loc_y,
                                'buildings': assignment
                            }
                            antennas.pop(j)
                            merged = True
                            improved = True
                            break
                
                if merged:
                    break
            
            if not merged:
                i += 1
    
    return antennas