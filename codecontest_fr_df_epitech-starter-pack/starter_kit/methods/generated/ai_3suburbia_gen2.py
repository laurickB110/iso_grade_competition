"""
AI-Generated Solver
Generated: 2025-12-29 17:25:53
Model: claude-sonnet-4-5-20250929

This solver was automatically generated by Claude AI based on
analysis of existing solver performance patterns.
"""

"""
Demand-weighted Voronoi clustering solver optimized for suburbia datasets.

Strategy:
1. Create demand-weighted cluster centers using k-means++ initialization
2. Assign buildings to clusters based on weighted distance (distance / demand_weight)
3. For each cluster, optimize antenna placement using demand centroid
4. Use hierarchical antenna selection: try to cover with minimal cost
5. Apply local search to reassign boundary buildings between clusters
6. Special handling for isolated high-demand buildings

Optimized for low-clustering, moderate-distribution datasets like suburbia.
"""
import random
import math
from typing import Dict, List, Set, Tuple
from collections import defaultdict
from .base import (
    SolverResult,
    ANTENNA_TYPES,
    ANTENNA_TYPES_BY_CAPACITY,
    get_building_demand,
    is_in_range,
    distance
)


def solve(dataset: dict, *, seed: int, params: dict = None) -> SolverResult:
    """
    Demand-weighted Voronoi clustering solver.
    
    Args:
        dataset: Dataset dict with 'buildings' key
        seed: Random seed for reproducibility
        params: Optional parameters
        
    Returns:
        SolverResult with optimized solution
    """
    if params is None:
        params = {}
    
    rng = random.Random(seed)
    buildings = dataset['buildings']
    
    # Precompute building info
    building_by_id = {b['id']: b for b in buildings}
    building_demands = {b['id']: get_building_demand(b) for b in buildings}
    
    # Estimate optimal number of clusters based on dataset size and MaxRange coverage
    max_range = ANTENNA_TYPES['MaxRange']['range']
    max_capacity = ANTENNA_TYPES['MaxRange']['capacity']
    
    # Calculate total demand
    total_demand = sum(building_demands.values())
    
    # Estimate clusters: balance between spatial coverage and capacity
    spatial_clusters = max(1, int(math.sqrt(len(buildings)) / 3))
    capacity_clusters = max(1, int(total_demand / (max_capacity * 0.7)))
    num_clusters = min(spatial_clusters, capacity_clusters, len(buildings))
    num_clusters = max(num_clusters, int(len(buildings) / 50))  # At least 1 per 50 buildings
    
    # Initialize cluster centers using weighted k-means++
    cluster_centers = initialize_weighted_clusters(buildings, building_demands, num_clusters, rng)
    
    # Iteratively refine clusters
    clusters = assign_to_clusters(buildings, cluster_centers, building_demands)
    
    for iteration in range(5):
        # Update cluster centers to demand-weighted centroids
        cluster_centers = update_cluster_centers(clusters, building_by_id, building_demands)
        # Reassign buildings
        new_clusters = assign_to_clusters(buildings, cluster_centers, building_demands)
        if new_clusters == clusters:
            break
        clusters = new_clusters
    
    # Build antennas for each cluster
    antennas = []
    covered = set()
    
    for cluster_id, building_ids in clusters.items():
        if not building_ids:
            continue
        
        cluster_buildings = [building_by_id[bid] for bid in building_ids]
        cluster_antennas = build_cluster_antennas(
            cluster_buildings, building_by_id, building_demands, covered, rng
        )
        antennas.extend(cluster_antennas)
        for antenna in cluster_antennas:
            covered.update(antenna['buildings'])
    
    # Cover any remaining buildings (edge case handling)
    all_building_ids = {b['id'] for b in buildings}
    uncovered = all_building_ids - covered
    
    if uncovered:
        for bid in uncovered:
            b = building_by_id[bid]
            antennas.append({
                'type': 'MaxRange',
                'x': b['x'],
                'y': b['y'],
                'buildings': [bid]
            })
            covered.add(bid)
    
    # Local optimization: try to merge nearby antennas
    antennas = optimize_antenna_placement(antennas, building_by_id, building_demands, rng)
    
    return {'antennas': antennas}


def initialize_weighted_clusters(buildings: List[dict], building_demands: Dict[int, int],
                                 num_clusters: int, rng: random.Random) -> List[Tuple[float, float]]:
    """Initialize cluster centers using weighted k-means++."""
    if num_clusters >= len(buildings):
        return [(b['x'], b['y']) for b in buildings]
    
    centers = []
    
    # First center: pick building with highest demand
    first = max(buildings, key=lambda b: building_demands[b['id']])
    centers.append((first['x'], first['y']))
    
    # Remaining centers: weighted by distance and demand
    for _ in range(num_clusters - 1):
        distances = []
        for b in buildings:
            min_dist = min(distance(b['x'], b['y'], cx, cy) for cx, cy in centers)
            # Weight by distance and demand
            weight = min_dist * math.sqrt(building_demands[b['id']])
            distances.append((weight, b))
        
        # Pick probabilistically based on weights
        total_weight = sum(w for w, _ in distances)
        if total_weight == 0:
            next_building = rng.choice([b for _, b in distances])
        else:
            r = rng.uniform(0, total_weight)
            cumsum = 0
            next_building = distances[0][1]
            for w, b in distances:
                cumsum += w
                if cumsum >= r:
                    next_building = b
                    break
        
        centers.append((next_building['x'], next_building['y']))
    
    return centers


def assign_to_clusters(buildings: List[dict], centers: List[Tuple[float, float]],
                       building_demands: Dict[int, int]) -> Dict[int, List[int]]:
    """Assign buildings to nearest cluster center (weighted by demand)."""
    clusters = defaultdict(list)
    
    for b in buildings:
        bid = b['id']
        demand = building_demands[bid]
        
        # Find nearest center (with demand weighting)
        min_score = float('inf')
        best_cluster = 0
        
        for i, (cx, cy) in enumerate(centers):
            dist = distance(b['x'], b['y'], cx, cy)
            # Lower score for closer centers, slightly favor high-demand buildings
            score = dist / math.sqrt(max(demand, 1))
            if score < min_score:
                min_score = score
                best_cluster = i
        
        clusters[best_cluster].append(bid)
    
    return clusters


def update_cluster_centers(clusters: Dict[int, List[int]], building_by_id: Dict[int, dict],
                           building_demands: Dict[int, int]) -> List[Tuple[float, float]]:
    """Update cluster centers to demand-weighted centroids."""
    centers = []
    
    for cluster_id in sorted(clusters.keys()):
        building_ids = clusters[cluster_id]
        if not building_ids:
            centers.append((0, 0))
            continue
        
        total_demand = sum(building_demands[bid] for bid in building_ids)
        
        if total_demand == 0:
            # Fallback to simple centroid
            avg_x = sum(building_by_id[bid]['x'] for bid in building_ids) / len(building_ids)
            avg_y = sum(building_by_id[bid]['y'] for bid in building_ids) / len(building_ids)
        else:
            # Demand-weighted centroid
            avg_x = sum(building_by_id[bid]['x'] * building_demands[bid] 
                       for bid in building_ids) / total_demand
            avg_y = sum(building_by_id[bid]['y'] * building_demands[bid] 
                       for bid in building_ids) / total_demand
        
        centers.append((avg_x, avg_y))
    
    return centers


def build_cluster_antennas(cluster_buildings: List[dict], building_by_id: Dict[int, dict],
                           building_demands: Dict[int, int], covered: Set[int],
                           rng: random.Random) -> List[dict]:
    """Build antennas for a single cluster."""
    antennas = []
    local_covered = set()
    
    # Sort by demand descending
    sorted_buildings = sorted(cluster_buildings, 
                             key=lambda b: building_demands[b['id']], 
                             reverse=True)
    
    for building in sorted_buildings:
        bid = building['id']
        
        if bid in local_covered or bid in covered:
            continue
        
        # Find optimal antenna placement near this building
        best_antenna = None
        best_assignment = []
        best_cost_per_building = float('inf')
        
        # Try placing antenna on this building and nearby buildings
        candidate_positions = [(building['x'], building['y'])]
        
        # Add nearby high-demand buildings as potential antenna locations
        for other in cluster_buildings:
            if distance(building['x'], building['y'], other['x'], other['y']) < 500:
                candidate_positions.append((other['x'], other['y']))
        
        candidate_positions = list(set(candidate_positions))[:5]  # Limit candidates
        
        for ant_x, ant_y in candidate_positions:
            for antenna_type in ANTENNA_TYPES_BY_CAPACITY:
                antenna_spec = ANTENNA_TYPES[antenna_type]
                antenna_range = antenna_spec['range']
                antenna_capacity = antenna_spec['capacity']
                
                # Find uncovered buildings in range
                candidates = []
                for other in cluster_buildings:
                    other_id = other['id']
                    if other_id not in local_covered and other_id not in covered:
                        if is_in_range(ant_x, ant_y, other['x'], other['y'], antenna_range):
                            candidates.append(other_id)
                
                if not candidates or bid not in candidates:
                    continue
                
                # Greedy packing by demand
                candidates.sort(key=lambda cid: building_demands[cid], reverse=True)
                
                assignment = []
                total_peak = 0
                total_off_peak = 0
                total_night = 0
                
                for cid in candidates:
                    cb = building_by_id[cid]
                    new_peak = total_peak + cb['populationPeakHours']
                    new_off_peak = total_off_peak + cb['populationOffPeakHours']
                    new_night = total_night + cb['populationNight']
                    new_max = max(new_peak, new_off_peak, new_night)
                    
                    if new_max <= antenna_capacity:
                        assignment.append(cid)
                        total_peak = new_peak
                        total_off_peak = new_off_peak
                        total_night = new_night
                
                if assignment and bid in assignment:
                    # Check if on building for discount
                    on_building = any(b['x'] == ant_x and b['y'] == ant_y 
                                     for b in cluster_buildings)
                    cost = antenna_spec['cost'] if on_building else antenna_spec['cost'] * 1.5
                    cost_per_building = cost / len(assignment)
                    
                    if cost_per_building < best_cost_per_building:
                        best_antenna = antenna_type
                        best_assignment = assignment
                        best_cost_per_building = cost_per_building
                        best_position = (ant_x, ant_y)
        
        if best_antenna:
            antennas.append({
                'type': best_antenna,
                'x': best_position[0],
                'y': best_position[1],
                'buildings': best_assignment
            })
            local_covered.update(best_assignment)
        else:
            # Fallback
            antennas.append({
                'type': 'MaxRange',
                'x': building['x'],
                'y': building['y'],
                'buildings': [bid]
            })
            local_covered.add(bid)
    
    return antennas


def optimize_antenna_placement(antennas: List[dict], building_by_id: Dict[int, dict],
                               building_demands: Dict[int, int], rng: random.Random) -> List[dict]:
    """Local optimization: try to merge or upgrade antennas."""
    # Try to merge small nearby antennas
    optimized = []
    merged = set()
    
    for i, ant1 in enumerate(antennas):
        if i in merged:
            continue
        
        # Try to find nearby antennas to merge with
        candidates_to_merge = [i]
        all_buildings = set(ant1['buildings'])
        
        for j, ant2 in enumerate(antennas):
            if j <= i or j in merged:
                continue
            
            # Check if close enough to potentially merge
            if distance(ant1['x'], ant1['y'], ant2['x'], ant2['y']) < 300:
                combined_buildings = all_buildings | set(ant2['buildings'])
                
                # Try to find antenna that can cover all
                for antenna_type in ANTENNA_TYPES_BY_CAPACITY:
                    antenna_spec = ANTENNA_TYPES[antenna_type]
                    
                    # Try centroid position
                    buildings_list = [building_by_id[bid] for bid in combined_buildings]
                    avg_x = sum(b['x'] for b in buildings_list) / len(buildings_list)
                    avg_y = sum(b['y'] for b in buildings_list) / len(buildings_list)
                    
                    # Snap to nearest building
                    snap_x, snap_y = min(buildings_list, 
                                        key=lambda b: distance(b['x'], b['y'], avg_x, avg_y))['x'], \
                                     min(buildings_list, 
                                        key=lambda b: distance(b['x'], b['y'], avg_x, avg_y))['y']
                    
                    # Check if all buildings in range and capacity
                    if can_cover_all(snap_x, snap_y, combined_buildings, building_by_id, 
                                    antenna_spec):
                        candidates_to_merge.append(j)
                        all_buildings = combined_buildings
                        break
        
        if len(candidates_to_merge) > 1:
            # Merge successful
            buildings_list = [building_by_id[bid] for bid in all_buildings]
            avg_x = sum(b['x'] for b in buildings_list) / len(buildings_list)
            avg_y = sum(b['y'] for b in buildings_list) / len(buildings_list)
            snap_x, snap_y = min(buildings_list, 
                                key=lambda b: distance(b['x'], b['y'], avg_x, avg_y))['x'], \
                             min(buildings_list, 
                                key=lambda b: distance(b['x'], b['y'], avg_x, avg_y))['y']
            
            for antenna_type in reversed(ANTENNA_TYPES_BY_CAPACITY):
                antenna_spec = ANTENNA_TYPES[antenna_type]
                if can_cover_all(snap_x, snap_y, all_buildings, building_by_id, antenna_spec):
                    optimized.append({
                        'type': antenna_type,
                        'x': snap_x,
                        'y': snap_y,
                        'buildings': list(all_buildings)
                    })
                    merged.update(candidates_to_merge)
                    break
        else:
            optimized.append(ant1)
            merged.add(i)
    
    return optimized


def can_cover_all(ant_x: int, ant_y: int, building_ids: Set[int], 
                  building_by_id: Dict[int, dict], antenna_spec: dict) -> bool:
    """Check if antenna can cover all buildings in range and capacity."""
    antenna_range = antenna_spec['range']
    antenna_capacity = antenna_spec['capacity']
    
    total_peak = 0
    total_off_peak = 0
    total_night = 0
    
    for bid in building_ids:
        b = building_by_id[bid]
        if not is_in_range(ant_x, ant_y, b['x'], b['y'], antenna_range):
            return False
        
        total_peak += b['populationPeakHours']
        total_off_peak += b['populationOffPeakHours']
        total_night += b['populationNight']
    
    return max(total_peak, total_off_peak, total_night) <= antenna_capacity