"""
AI-Generated Solver
Generated: 2025-12-29 17:23:35
Model: claude-sonnet-4-5-20250929

This solver was automatically generated by Claude AI based on
analysis of existing solver performance patterns.
"""

"""
Spatial clustering solver optimized for suburbia dataset.

Strategy:
1. Create density-aware spatial grid to identify local demand hotspots
2. Use hierarchical clustering (DBSCAN-like) to find micro-clusters
3. Place facilities at weighted centroids of clusters
4. Use gradient-descent facility repositioning
5. Multi-phase optimization: construction -> swap -> reassignment
6. Exploit building-placement cost discount by snapping to nearest buildings
"""
import random
import math
from typing import Dict, List, Set, Tuple, Optional
from collections import defaultdict
from .base import (
    SolverResult,
    ANTENNA_TYPES,
    ANTENNA_TYPES_BY_CAPACITY,
    get_building_demand,
    is_in_range,
    distance
)


def solve(dataset: dict, *, seed: int, params: dict = None) -> SolverResult:
    """
    Spatial clustering solver for suburbia-type datasets.
    
    Args:
        dataset: Dataset dict with 'buildings' key
        seed: Random seed for reproducibility
        params: Optional parameters
        
    Returns:
        SolverResult with optimized antenna placement
    """
    rng = random.Random(seed)
    buildings = dataset['buildings']
    
    # Precompute building data
    building_data = {}
    for b in buildings:
        bid = b['id']
        building_data[bid] = {
            'x': b['x'],
            'y': b['y'],
            'peak': b['populationPeakHours'],
            'off_peak': b['populationOffPeakHours'],
            'night': b['populationNight'],
            'max_demand': get_building_demand(b)
        }
    
    # Phase 1: Density-aware clustering
    clusters = create_density_clusters(buildings, building_data, rng)
    
    # Phase 2: Initial facility placement at cluster centroids
    antennas = place_initial_antennas(clusters, buildings, building_data, rng)
    
    # Phase 3: Snap antennas to nearest buildings for cost discount
    antennas = snap_to_buildings(antennas, buildings, building_data)
    
    # Phase 4: Local search with facility swaps
    antennas = facility_swap_optimization(antennas, buildings, building_data, rng, iterations=50)
    
    # Phase 5: Demand reassignment optimization
    antennas = reassign_buildings(antennas, buildings, building_data)
    
    # Phase 6: Consolidation - merge underutilized antennas
    antennas = consolidate_antennas(antennas, buildings, building_data)
    
    # Ensure all buildings covered
    antennas = ensure_full_coverage(antennas, buildings, building_data)
    
    return {'antennas': antennas}


def create_density_clusters(buildings: List[dict], building_data: dict, rng: random.Random) -> List[List[int]]:
    """Create spatial clusters based on demand density using adaptive radius."""
    # Calculate spatial bounds
    xs = [b['x'] for b in buildings]
    ys = [b['y'] for b in buildings]
    min_x, max_x = min(xs), max(xs)
    min_y, max_y = min(ys), max(ys)
    
    # Create density grid (100x100)
    grid_size = 100
    grid = defaultdict(list)
    
    for b in buildings:
        bid = b['id']
        grid_x = int((b['x'] - min_x) / (max_x - min_x + 1) * (grid_size - 1))
        grid_y = int((b['y'] - min_y) / (max_y - min_y + 1) * (grid_size - 1))
        grid[(grid_x, grid_y)].append(bid)
    
    # Identify high-density cells
    density_threshold = len(buildings) / (grid_size * grid_size) * 2
    hotspots = [(cell, bids) for cell, bids in grid.items() if len(bids) >= density_threshold]
    
    # DBSCAN-like clustering with adaptive epsilon
    visited = set()
    clusters = []
    epsilon = 1500  # Initial search radius for suburbia
    min_cluster_size = 3
    
    building_list = list(building_data.keys())
    rng.shuffle(building_list)
    
    for bid in building_list:
        if bid in visited:
            continue
            
        cluster = []
        queue = [bid]
        
        while queue:
            current = queue.pop(0)
            if current in visited:
                continue
                
            visited.add(current)
            cluster.append(current)
            
            # Find neighbors within epsilon
            cx, cy = building_data[current]['x'], building_data[current]['y']
            for other_id in building_data:
                if other_id not in visited:
                    ox, oy = building_data[other_id]['x'], building_data[other_id]['y']
                    if distance(cx, cy, ox, oy) <= epsilon:
                        queue.append(other_id)
        
        if len(cluster) >= min_cluster_size:
            clusters.append(cluster)
        else:
            # Small clusters become individual antennas
            for bid in cluster:
                clusters.append([bid])
    
    return clusters


def place_initial_antennas(clusters: List[List[int]], buildings: List[dict], 
                           building_data: dict, rng: random.Random) -> List[dict]:
    """Place antennas at weighted centroids of clusters."""
    antennas = []
    
    for cluster in clusters:
        if not cluster:
            continue
        
        # Calculate demand-weighted centroid
        total_demand = sum(building_data[bid]['max_demand'] for bid in cluster)
        if total_demand == 0:
            total_demand = len(cluster)
        
        centroid_x = sum(building_data[bid]['x'] * building_data[bid]['max_demand'] 
                        for bid in cluster) / total_demand
        centroid_y = sum(building_data[bid]['y'] * building_data[bid]['max_demand'] 
                        for bid in cluster) / total_demand
        
        # Calculate total capacity needed
        total_peak = sum(building_data[bid]['peak'] for bid in cluster)
        total_off_peak = sum(building_data[bid]['off_peak'] for bid in cluster)
        total_night = sum(building_data[bid]['night'] for bid in cluster)
        max_load = max(total_peak, total_off_peak, total_night)
        
        # Select smallest antenna type that fits
        selected_type = 'MaxRange'
        for antenna_type in ANTENNA_TYPES_BY_CAPACITY:
            if ANTENNA_TYPES[antenna_type]['capacity'] >= max_load:
                selected_type = antenna_type
                break
        
        antenna_spec = ANTENNA_TYPES[selected_type]
        
        # Verify all buildings in range, split if needed
        in_range_buildings = []
        out_of_range = []
        
        for bid in cluster:
            bx, by = building_data[bid]['x'], building_data[bid]['y']
            if distance(centroid_x, centroid_y, bx, by) <= antenna_spec['range']:
                in_range_buildings.append(bid)
            else:
                out_of_range.append(bid)
        
        if in_range_buildings:
            antennas.append({
                'type': selected_type,
                'x': int(centroid_x),
                'y': int(centroid_y),
                'buildings': in_range_buildings
            })
        
        # Handle out of range buildings
        for bid in out_of_range:
            bx, by = building_data[bid]['x'], building_data[bid]['y']
            antennas.append({
                'type': 'Nano',
                'x': bx,
                'y': by,
                'buildings': [bid]
            })
    
    return antennas


def snap_to_buildings(antennas: List[dict], buildings: List[dict], 
                     building_data: dict) -> List[dict]:
    """Snap antenna locations to nearest buildings for cost discount."""
    snapped = []
    
    for antenna in antennas:
        ax, ay = antenna['x'], antenna['y']
        antenna_spec = ANTENNA_TYPES[antenna['type']]
        
        # Find nearest building that keeps all assigned buildings in range
        best_building = None
        best_distance = float('inf')
        
        for bid, bdata in building_data.items():
            bx, by = bdata['x'], bdata['y']
            dist = distance(ax, ay, bx, by)
            
            if dist < best_distance:
                # Check if all buildings still in range from this position
                all_in_range = True
                for assigned_bid in antenna['buildings']:
                    assigned_x = building_data[assigned_bid]['x']
                    assigned_y = building_data[assigned_bid]['y']
                    if distance(bx, by, assigned_x, assigned_y) > antenna_spec['range']:
                        all_in_range = False
                        break
                
                if all_in_range:
                    best_building = (bx, by)
                    best_distance = dist
        
        if best_building:
            snapped.append({
                'type': antenna['type'],
                'x': best_building[0],
                'y': best_building[1],
                'buildings': antenna['buildings']
            })
        else:
            snapped.append(antenna)
    
    return snapped


def facility_swap_optimization(antennas: List[dict], buildings: List[dict],
                               building_data: dict, rng: random.Random, 
                               iterations: int = 50) -> List[dict]:
    """Optimize antenna placements using local swaps."""
    current = antennas[:]
    
    for _ in range(iterations):
        # Try random antenna type changes
        i = rng.randint(0, len(current) - 1)
        antenna = current[i]
        
        # Calculate current load
        peak = sum(building_data[bid]['peak'] for bid in antenna['buildings'])
        off_peak = sum(building_data[bid]['off_peak'] for bid in antenna['buildings'])
        night = sum(building_data[bid]['night'] for bid in antenna['buildings'])
        max_load = max(peak, off_peak, night)
        
        # Try downgrading antenna type
        current_type = antenna['type']
        current_idx = ANTENNA_TYPES_BY_CAPACITY.index(current_type)
        
        if current_idx > 0:
            smaller_type = ANTENNA_TYPES_BY_CAPACITY[current_idx - 1]
            smaller_spec = ANTENNA_TYPES[smaller_type]
            
            if smaller_spec['capacity'] >= max_load:
                # Check range constraint
                all_in_range = True
                for bid in antenna['buildings']:
                    bx, by = building_data[bid]['x'], building_data[bid]['y']
                    if distance(antenna['x'], antenna['y'], bx, by) > smaller_spec['range']:
                        all_in_range = False
                        break
                
                if all_in_range:
                    current[i] = {
                        'type': smaller_type,
                        'x': antenna['x'],
                        'y': antenna['y'],
                        'buildings': antenna['buildings']
                    }
    
    return current


def reassign_buildings(antennas: List[dict], buildings: List[dict],
                      building_data: dict) -> List[dict]:
    """Reassign buildings to better antennas."""
    # Create mapping of building to antenna
    building_to_antenna = {}
    for i, antenna in enumerate(antennas):
        for bid in antenna['buildings']:
            building_to_antenna[bid] = i
    
    improved = True
    while improved:
        improved = False
        
        for bid in building_data:
            current_antenna_idx = building_to_antenna[bid]
            current_antenna = antennas[current_antenna_idx]
            
            # Try moving to other antennas
            for i, antenna in enumerate(antennas):
                if i == current_antenna_idx:
                    continue
                
                # Check if in range
                bx, by = building_data[bid]['x'], building_data[bid]['y']
                antenna_spec = ANTENNA_TYPES[antenna['type']]
                
                if distance(antenna['x'], antenna['y'], bx, by) > antenna_spec['range']:
                    continue
                
                # Check capacity
                peak = sum(building_data[b]['peak'] for b in antenna['buildings']) + building_data[bid]['peak']
                off_peak = sum(building_data[b]['off_peak'] for b in antenna['buildings']) + building_data[bid]['off_peak']
                night = sum(building_data[b]['night'] for b in antenna['buildings']) + building_data[bid]['night']
                
                if max(peak, off_peak, night) <= antenna_spec['capacity']:
                    # Move building
                    antennas[current_antenna_idx]['buildings'].remove(bid)
                    antennas[i]['buildings'].append(bid)
                    building_to_antenna[bid] = i
                    improved = True
                    break
    
    return antennas


def consolidate_antennas(antennas: List[dict], buildings: List[dict],
                        building_data: dict) -> List[dict]:
    """Merge underutilized antennas."""
    consolidated = []
    used = set()
    
    for i, antenna in enumerate(antennas):
        if i in used or not antenna['buildings']:
            continue
        
        current_buildings = antenna['buildings'][:]
        antenna_spec = ANTENNA_TYPES[antenna['type']]
        
        # Try to absorb nearby antennas
        for j, other in enumerate(antennas):
            if i == j or j in used or not other['buildings']:
                continue
            
            # Check if we can merge
            combined_buildings = current_buildings + other['buildings']
            
            # Check capacity
            peak = sum(building_data[bid]['peak'] for bid in combined_buildings)
            off_peak = sum(building_data[bid]['off_peak'] for bid in combined_buildings)
            night = sum(building_data[bid]['night'] for bid in combined_buildings)
            max_load = max(peak, off_peak, night)
            
            # Find suitable antenna type
            suitable_type = None
            for atype in ANTENNA_TYPES_BY_CAPACITY:
                spec = ANTENNA_TYPES[atype]
                if spec['capacity'] >= max_load:
                    # Check range
                    all_in_range = True
                    for bid in combined_buildings:
                        bx, by = building_data[bid]['x'], building_data[bid]['y']
                        if distance(antenna['x'], antenna['y'], bx, by) > spec['range']:
                            all_in_range = False
                            break
                    
                    if all_in_range:
                        suitable_type = atype
                        break
            
            if suitable_type:
                current_buildings = combined_buildings
                antenna_spec = ANTENNA_TYPES[suitable_type]
                antenna = {
                    'type': suitable_type,
                    'x': antenna['x'],
                    'y': antenna['y'],
                    'buildings': current_buildings
                }
                used.add(j)
        
        consolidated.append(antenna)
        used.add(i)
    
    return consolidated


def ensure_full_coverage(antennas: List[dict], buildings: List[dict],
                        building_data: dict) -> List[dict]:
    """Ensure all buildings are covered."""
    covered = set()
    for antenna in antennas:
        covered.update(antenna['buildings'])
    
    all_buildings = set(building_data.keys())
    uncovered = all_buildings - covered
    
    for bid in uncovered:
        bx, by = building_data[bid]['x'], building_data[bid]['y']
        antennas.append({
            'type': 'Nano',
            'x': bx,
            'y': by,
            'buildings': [bid]
        })
    
    return antennas