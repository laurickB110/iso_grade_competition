"""
AI-Generated Solver
Generated: 2025-12-29 22:35:27
Model: claude-sonnet-4-5-20250929

This solver was automatically generated by Claude AI based on
analysis of existing solver performance patterns.
"""

"""
Density-aware clustering solver optimized for suburban sprawl (3_suburbia).

Strategy:
1. Spatial clustering to identify natural building groups in low-density areas
2. Multi-phase optimization: quick cluster coverage + inter-cluster refinement
3. Demand-weighted placement prioritizing high-demand buildings
4. Adaptive antenna selection based on local density
5. Coverage overlap minimization with explicit deduplication
6. Local search with antenna repositioning for cost reduction
"""

import random
import math
from typing import Dict, List, Set, Tuple, Optional
from collections import defaultdict
from ..base import (
    SolverResult,
    ANTENNA_TYPES,
    ANTENNA_TYPES_BY_CAPACITY,
    get_building_demand,
    is_in_range,
    distance
)


def solve(dataset: dict, *, seed: int, params: dict = None) -> SolverResult:
    """
    Density-aware clustering solver for suburban sprawl optimization.
    """
    rng = random.Random(seed)
    buildings = dataset['buildings']
    
    if not buildings:
        return {'antennas': []}
    
    # Phase 1: Precompute building data
    building_data = precompute_building_data(buildings)
    
    # Phase 2: Spatial clustering with density awareness
    clusters = spatial_clustering(buildings, building_data, rng)
    
    # Phase 3: Initial antenna placement per cluster
    antennas = []
    covered = set()
    
    for cluster in clusters:
        cluster_antennas = place_antennas_in_cluster(
            cluster, buildings, building_data, covered, rng
        )
        antennas.extend(cluster_antennas)
    
    # Phase 4: Cover any remaining buildings (safety net)
    all_building_ids = {b['id'] for b in buildings}
    uncovered = all_building_ids - covered
    
    if uncovered:
        for bid in uncovered:
            b = building_data['by_id'][bid]
            antennas.append({
                'type': 'MaxRange',
                'x': b['x'],
                'y': b['y'],
                'buildings': [bid]
            })
            covered.add(bid)
    
    # Phase 5: Local search optimization
    antennas = local_search_optimization(antennas, buildings, building_data, rng, iterations=50)
    
    # Phase 6: Coverage deduplication
    antennas = deduplicate_coverage(antennas, buildings, building_data)
    
    return {'antennas': antennas}


def precompute_building_data(buildings: List[dict]) -> Dict:
    """Precompute all building-related data for fast lookup."""
    data = {
        'demands': {},
        'coords': {},
        'by_id': {},
        'positions': defaultdict(list),
        'peak': {},
        'off_peak': {},
        'night': {}
    }
    
    for b in buildings:
        bid = b['id']
        data['demands'][bid] = get_building_demand(b)
        data['coords'][bid] = (b['x'], b['y'])
        data['by_id'][bid] = b
        data['positions'][(b['x'], b['y'])].append(bid)
        data['peak'][bid] = b['populationPeakHours']
        data['off_peak'][bid] = b['populationOffPeakHours']
        data['night'][bid] = b['populationNight']
    
    return data


def spatial_clustering(buildings: List[dict], building_data: Dict, rng: random.Random) -> List[List[int]]:
    """
    Density-based spatial clustering optimized for suburban sprawl.
    Uses adaptive radius based on local density.
    """
    # Calculate average distance to nearest neighbors for radius estimation
    sample_size = min(100, len(buildings))
    sample = rng.sample(buildings, sample_size)
    
    avg_nearest_dist = 0
    for b in sample:
        min_dist = float('inf')
        for other in buildings:
            if b['id'] != other['id']:
                d = distance(b['x'], b['y'], other['x'], other['y'])
                if d < min_dist:
                    min_dist = d
        avg_nearest_dist += min_dist
    
    avg_nearest_dist /= sample_size
    cluster_radius = max(800, avg_nearest_dist * 3)  # Adaptive radius
    
    # DBSCAN-like clustering
    unvisited = {b['id'] for b in buildings}
    clusters = []
    noise = []
    
    # Sort by demand for better initial cluster seeds
    sorted_buildings = sorted(buildings, key=lambda b: building_data['demands'][b['id']], reverse=True)
    
    for building in sorted_buildings:
        if building['id'] not in unvisited:
            continue
        
        unvisited.remove(building['id'])
        cluster = [building['id']]
        queue = [building]
        
        while queue:
            current = queue.pop(0)
            neighbors = []
            
            for other in buildings:
                if other['id'] in unvisited:
                    if distance(current['x'], current['y'], other['x'], other['y']) <= cluster_radius:
                        neighbors.append(other)
            
            if len(neighbors) >= 2:  # Low density threshold
                for neighbor in neighbors:
                    if neighbor['id'] in unvisited:
                        unvisited.remove(neighbor['id'])
                        cluster.append(neighbor['id'])
                        queue.append(neighbor)
        
        if len(cluster) >= 3:
            clusters.append(cluster)
        else:
            noise.extend(cluster)
    
    # Add noise as individual clusters
    for bid in noise:
        clusters.append([bid])
    
    return clusters


def place_antennas_in_cluster(cluster: List[int], buildings: List[dict], 
                               building_data: Dict, covered: Set[int], 
                               rng: random.Random) -> List[dict]:
    """
    Place antennas within a cluster using demand-weighted optimization.
    """
    antennas = []
    cluster_uncovered = set(cluster) - covered
    
    if not cluster_uncovered:
        return antennas
    
    # Calculate cluster centroid and density
    cluster_buildings = [building_data['by_id'][bid] for bid in cluster_uncovered]
    centroid_x = sum(b['x'] for b in cluster_buildings) / len(cluster_buildings)
    centroid_y = sum(b['y'] for b in cluster_buildings) / len(cluster_buildings)
    
    # Sort by demand and distance to centroid (prioritize high-demand central buildings)
    def priority_score(bid):
        b = building_data['by_id'][bid]
        dist_to_centroid = distance(b['x'], b['y'], centroid_x, centroid_y)
        demand = building_data['demands'][bid]
        return demand * 1000 - dist_to_centroid  # Weighted priority
    
    sorted_cluster = sorted(cluster_uncovered, key=priority_score, reverse=True)
    
    for bid in sorted_cluster:
        if bid in covered:
            continue
        
        b = building_data['by_id'][bid]
        
        # Try to place antenna at optimal position
        best_antenna = find_optimal_antenna(
            b, cluster_buildings, building_data, covered, rng
        )
        
        if best_antenna:
            antennas.append(best_antenna)
            covered.update(best_antenna['buildings'])
    
    return antennas


def find_optimal_antenna(seed_building: dict, candidates: List[dict], 
                        building_data: Dict, covered: Set[int], 
                        rng: random.Random) -> Optional[dict]:
    """
    Find optimal antenna type and placement for a seed building.
    """
    # Calculate local density around seed building
    nearby_uncovered = []
    for b in candidates:
        if b['id'] not in covered:
            nearby_uncovered.append(b)
    
    if not nearby_uncovered:
        return None
    
    density = len(nearby_uncovered)
    
    # Adaptive antenna selection based on density
    if density <= 3:
        antenna_preference = ['Nano', 'Spot', 'Density', 'MaxRange']
    elif density <= 8:
        antenna_preference = ['Spot', 'Density', 'Nano', 'MaxRange']
    else:
        antenna_preference = ['Density', 'Spot', 'MaxRange', 'Nano']
    
    best_antenna = None
    best_score = -1
    
    # Try each antenna type
    for antenna_type in antenna_preference:
        antenna_spec = ANTENNA_TYPES[antenna_type]
        antenna_range = antenna_spec['range']
        antenna_capacity = antenna_spec['capacity']
        antenna_cost = antenna_spec['cost_on_building']
        
        # Try placing at seed building location (gets discount)
        antenna_x, antenna_y = seed_building['x'], seed_building['y']
        
        # Find coverable buildings
        assignment = []
        total_peak = 0
        total_off_peak = 0
        total_night = 0
        
        # Sort by demand for greedy packing
        reachable = []
        for b in nearby_uncovered:
            if is_in_range(antenna_x, antenna_y, b['x'], b['y'], antenna_range):
                reachable.append((b['id'], building_data['demands'][b['id']]))
        
        reachable.sort(key=lambda x: x[1], reverse=True)
        
        for bid, _ in reachable:
            b = building_data['by_id'][bid]
            new_peak = total_peak + b['populationPeakHours']
            new_off_peak = total_off_peak + b['populationOffPeakHours']
            new_night = total_night + b['populationNight']
            new_max = max(new_peak, new_off_peak, new_night)
            
            if new_max <= antenna_capacity:
                assignment.append(bid)
                total_peak = new_peak
                total_off_peak = new_off_peak
                total_night = new_night
        
        # Must cover seed building
        if seed_building['id'] not in assignment:
            continue
        
        # Score: coverage per cost (higher is better)
        effective_cost = antenna_cost * 0.9  # Building discount
        score = len(assignment) / effective_cost
        
        if score > best_score:
            best_score = score
            best_antenna = {
                'type': antenna_type,
                'x': antenna_x,
                'y': antenna_y,
                'buildings': assignment
            }
    
    return best_antenna


def local_search_optimization(antennas: List[dict], buildings: List[dict], 
                              building_data: Dict, rng: random.Random, 
                              iterations: int = 50) -> List[dict]:
    """
    Local search with antenna repositioning and type swapping.
    """
    current_antennas = [a.copy() for a in antennas]
    
    for _ in range(iterations):
        # Try random improvement move
        if not current_antennas:
            break
        
        idx = rng.randint(0, len(current_antennas) - 1)
        antenna = current_antennas[idx]
        
        # Try swapping to cheaper antenna type
        improved = try_downgrade_antenna(antenna, buildings, building_data)
        if improved:
            current_antennas[idx] = improved
            continue
        
        # Try repositioning antenna
        improved = try_reposition_antenna(antenna, buildings, building_data, rng)
        if improved:
            current_antennas[idx] = improved
    
    return current_antennas


def try_downgrade_antenna(antenna: dict, buildings: List[dict], 
                         building_data: Dict) -> Optional[dict]:
    """Try to use a cheaper antenna type while maintaining coverage."""
    current_type = antenna['type']
    current_idx = ANTENNA_TYPES_BY_CAPACITY.index(current_type)
    
    # Try cheaper types
    for i in range(current_idx):
        cheaper_type = ANTENNA_TYPES_BY_CAPACITY[i]
        spec = ANTENNA_TYPES[cheaper_type]
        
        # Check if all buildings still in range and within capacity
        valid = True
        total_peak = 0
        total_off_peak = 0
        total_night = 0
        
        for bid in antenna['buildings']:
            b = building_data['by_id'][bid]
            if not is_in_range(antenna['x'], antenna['y'], b['x'], b['y'], spec['range']):
                valid = False
                break
            
            total_peak += b['populationPeakHours']
            total_off_peak += b['populationOffPeakHours']
            total_night += b['populationNight']
        
        if valid and max(total_peak, total_off_peak, total_night) <= spec['capacity']:
            return {
                'type': cheaper_type,
                'x': antenna['x'],
                'y': antenna['y'],
                'buildings': antenna['buildings']
            }
    
    return None


def try_reposition_antenna(antenna: dict, buildings: List[dict], 
                           building_data: Dict, rng: random.Random) -> Optional[dict]:
    """Try repositioning antenna to cover more buildings or reduce cost."""
    if len(antenna['buildings']) <= 1:
        return None
    
    # Calculate centroid of covered buildings
    covered_buildings = [building_data['by_id'][bid] for bid in antenna['buildings']]
    centroid_x = sum(b['x'] for b in covered_buildings) / len(covered_buildings)
    centroid_y = sum(b['y'] for b in covered_buildings)
    
    # Try placing at centroid
    spec = ANTENNA_TYPES[antenna['type']]
    new_x, new_y = int(centroid_x), int(centroid_y)
    
    # Check if still covers all buildings
    valid = True
    for bid in antenna['buildings']:
        b = building_data['by_id'][bid]
        if not is_in_range(new_x, new_y, b['x'], b['y'], spec['range']):
            valid = False
            break
    
    if valid:
        return {
            'type': antenna['type'],
            'x': new_x,
            'y': new_y,
            'buildings': antenna['buildings']
        }
    
    return None


def deduplicate_coverage(antennas: List[dict], buildings: List[dict], 
                        building_data: Dict) -> List[dict]:
    """
    Remove redundant coverage by consolidating buildings to most efficient antennas.
    """
    # Build coverage map
    building_to_antennas = defaultdict(list)
    for i, antenna in enumerate(antennas):
        for bid in antenna['buildings']:
            building_to_antennas[bid].append(i)
    
    # Reassign buildings with multiple coverage
    new_antennas = []
    for i, antenna in enumerate(antennas):
        # Keep only buildings exclusively or optimally covered by this antenna
        kept_buildings = []
        for bid in antenna['buildings']:
            if len(building_to_antennas[bid]) == 1:
                kept_buildings.append(bid)
            else:
                # Keep in cheapest antenna
                covering_antennas = building_to_antennas[bid]
                cheapest_idx = min(covering_antennas, 
                                 key=lambda idx: ANTENNA_TYPES[antennas[idx]['type']]['cost_on_building'])
                if cheapest_idx == i:
                    kept_buildings.append(bid)
        
        if kept_buildings:
            new_antennas.append({
                'type': antenna['type'],
                'x': antenna['x'],
                'y': antenna['y'],
                'buildings': kept_buildings
            })
    
    return new_antennas