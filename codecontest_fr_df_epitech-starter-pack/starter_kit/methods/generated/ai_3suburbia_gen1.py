"""
AI-Generated Solver
Generated: 2025-12-30 11:26:57
Model: claude-sonnet-4-5-20250929

This solver was automatically generated by Claude AI based on
analysis of existing solver performance patterns.
"""

"""
Advanced solver for 3_suburbia dataset using adaptive spatial decomposition 
with multi-start local search and demand-weighted optimization.

Strategy:
1. Use k-d tree for efficient spatial queries in low-clustering environment
2. Multi-start approach: Generate diverse initial solutions using different heuristics
3. Demand-weighted distance metrics for better coverage in moderate distribution
4. Variable neighborhood descent for local optimization
5. Adaptive antenna selection based on demand density
"""

import random
from typing import Dict, List, Set, Tuple, Optional
from collections import defaultdict
import math

from ..base import (
    SolverResult,
    ANTENNA_TYPES,
    ANTENNA_TYPES_BY_CAPACITY,
    get_building_demand,
    is_in_range,
    distance
)


class KDNode:
    """Simple k-d tree node for 2D spatial indexing."""
    def __init__(self, point, building_id, left=None, right=None, axis=0):
        self.point = point
        self.building_id = building_id
        self.left = left
        self.right = right
        self.axis = axis


class KDTree:
    """K-d tree for efficient spatial queries."""
    def __init__(self, buildings):
        points = [(b['x'], b['y'], b['id']) for b in buildings]
        self.root = self._build(points, depth=0)
    
    def _build(self, points, depth):
        if not points:
            return None
        
        axis = depth % 2
        points.sort(key=lambda p: p[axis])
        median = len(points) // 2
        
        return KDNode(
            point=(points[median][0], points[median][1]),
            building_id=points[median][2],
            left=self._build(points[:median], depth + 1),
            right=self._build(points[median + 1:], depth + 1),
            axis=axis
        )
    
    def range_query(self, center_x, center_y, radius):
        """Find all buildings within radius of center point."""
        results = []
        self._range_query_recursive(self.root, center_x, center_y, radius, results)
        return results
    
    def _range_query_recursive(self, node, cx, cy, radius, results):
        if node is None:
            return
        
        dist = distance(cx, cy, node.point[0], node.point[1])
        if dist <= radius:
            results.append(node.building_id)
        
        axis = node.axis
        center = (cx, cy)
        diff = center[axis] - node.point[axis]
        
        if diff <= radius:
            self._range_query_recursive(node.left, cx, cy, radius, results)
        if diff >= -radius:
            self._range_query_recursive(node.right, cx, cy, radius, results)


def compute_demand_weight(building, buildings_dict):
    """Compute demand-weighted importance of a building."""
    demand = get_building_demand(building)
    # Weight by demand with logarithmic scaling to avoid extreme values
    return math.log(1 + demand)


def find_demand_weighted_centroid(building_ids, buildings_dict):
    """Find demand-weighted centroid of a set of buildings."""
    total_weight = 0
    weighted_x = 0
    weighted_y = 0
    
    for bid in building_ids:
        b = buildings_dict[bid]
        weight = compute_demand_weight(b, buildings_dict)
        weighted_x += b['x'] * weight
        weighted_y += b['y'] * weight
        total_weight += weight
    
    if total_weight == 0:
        return None
    
    return int(weighted_x / total_weight), int(weighted_y / total_weight)


def select_antenna_type(building_ids, buildings_dict, center_x, center_y):
    """Select optimal antenna type for given buildings and location."""
    total_peak = 0
    total_off_peak = 0
    total_night = 0
    max_dist = 0
    
    for bid in building_ids:
        b = buildings_dict[bid]
        total_peak += b['populationPeakHours']
        total_off_peak += b['populationOffPeakHours']
        total_night += b['populationNight']
        max_dist = max(max_dist, distance(center_x, center_y, b['x'], b['y']))
    
    required_capacity = max(total_peak, total_off_peak, total_night)
    
    # Find smallest antenna that satisfies both capacity and range
    for antenna_type in ANTENNA_TYPES_BY_CAPACITY:
        spec = ANTENNA_TYPES[antenna_type]
        if spec['capacity'] >= required_capacity and spec['range'] >= max_dist:
            return antenna_type
    
    return None


def greedy_construction_furthest_first(buildings, buildings_dict, kdtree, rng):
    """Construct solution starting from furthest uncovered building."""
    covered = set()
    antennas = []
    
    # Start from a random peripheral building
    remaining = list(buildings)
    rng.shuffle(remaining)
    
    # Find building furthest from center
    center_x = sum(b['x'] for b in buildings) / len(buildings)
    center_y = sum(b['y'] for b in buildings) / len(buildings)
    remaining.sort(key=lambda b: distance(b['x'], b['y'], center_x, center_y), reverse=True)
    
    while len(covered) < len(buildings):
        # Find furthest uncovered building
        current = None
        for b in remaining:
            if b['id'] not in covered:
                current = b
                break
        
        if current is None:
            break
        
        # Try to place antenna at building location first
        antenna_x, antenna_y = current['x'], current['y']
        
        # Find best antenna configuration
        best_antenna = None
        best_assignment = []
        
        for antenna_type in ANTENNA_TYPES_BY_CAPACITY:
            spec = ANTENNA_TYPES[antenna_type]
            candidates = kdtree.range_query(antenna_x, antenna_y, spec['range'])
            
            # Pack buildings greedily by demand
            assignment = []
            total_peak = total_off_peak = total_night = 0
            
            candidate_buildings = [(bid, get_building_demand(buildings_dict[bid])) 
                                   for bid in candidates if bid not in covered]
            candidate_buildings.sort(key=lambda x: x[1], reverse=True)
            
            for bid, _ in candidate_buildings:
                b = buildings_dict[bid]
                new_peak = total_peak + b['populationPeakHours']
                new_off_peak = total_off_peak + b['populationOffPeakHours']
                new_night = total_night + b['populationNight']
                
                if max(new_peak, new_off_peak, new_night) <= spec['capacity']:
                    assignment.append(bid)
                    total_peak = new_peak
                    total_off_peak = new_off_peak
                    total_night = new_night
            
            if current['id'] in assignment and len(assignment) > len(best_assignment):
                best_antenna = antenna_type
                best_assignment = assignment
        
        if best_antenna is None:
            best_antenna = 'MaxRange'
            best_assignment = [current['id']]
        
        antennas.append({
            'type': best_antenna,
            'x': antenna_x,
            'y': antenna_y,
            'buildings': best_assignment
        })
        covered.update(best_assignment)
    
    return antennas


def greedy_construction_density_based(buildings, buildings_dict, kdtree, rng):
    """Construct solution based on demand density clusters."""
    covered = set()
    antennas = []
    
    # Compute local density for each building
    density_scores = {}
    search_radius = 2000  # Moderate search radius for suburban setting
    
    for b in buildings:
        nearby = kdtree.range_query(b['x'], b['y'], search_radius)
        total_demand = sum(get_building_demand(buildings_dict[bid]) for bid in nearby)
        density_scores[b['id']] = total_demand / (1 + len(nearby))
    
    # Sort by density
    sorted_buildings = sorted(buildings, key=lambda b: density_scores[b['id']], reverse=True)
    
    for building in sorted_buildings:
        if building['id'] in covered:
            continue
        
        # Use demand-weighted centroid for antenna placement
        nearby = kdtree.range_query(building['x'], building['y'], search_radius)
        uncovered_nearby = [bid for bid in nearby if bid not in covered]
        
        if not uncovered_nearby:
            continue
        
        centroid = find_demand_weighted_centroid(uncovered_nearby[:20], buildings_dict)
        if centroid is None:
            centroid = (building['x'], building['y'])
        
        antenna_x, antenna_y = centroid
        
        # Find best antenna
        best_antenna = None
        best_assignment = []
        
        for antenna_type in ANTENNA_TYPES_BY_CAPACITY:
            spec = ANTENNA_TYPES[antenna_type]
            candidates = kdtree.range_query(antenna_x, antenna_y, spec['range'])
            
            assignment = []
            total_peak = total_off_peak = total_night = 0
            
            candidate_buildings = [(bid, get_building_demand(buildings_dict[bid])) 
                                   for bid in candidates if bid not in covered]
            candidate_buildings.sort(key=lambda x: x[1], reverse=True)
            
            for bid, _ in candidate_buildings:
                b = buildings_dict[bid]
                new_peak = total_peak + b['populationPeakHours']
                new_off_peak = total_off_peak + b['populationOffPeakHours']
                new_night = total_night + b['populationNight']
                
                if max(new_peak, new_off_peak, new_night) <= spec['capacity']:
                    assignment.append(bid)
                    total_peak = new_peak
                    total_off_peak = new_off_peak
                    total_night = new_night
            
            if len(assignment) > len(best_assignment):
                best_antenna = antenna_type
                best_assignment = assignment
        
        if not best_assignment:
            best_antenna = 'MaxRange'
            best_assignment = [building['id']]
        
        antennas.append({
            'type': best_antenna,
            'x': antenna_x,
            'y': antenna_y,
            'buildings': best_assignment
        })
        covered.update(best_assignment)
    
    return antennas


def local_search_swap(antennas, buildings_dict, kdtree, rng, max_iterations=100):
    """Local search: try swapping building assignments between antennas."""
    improved = True
    iterations = 0
    
    while improved and iterations < max_iterations:
        improved = False
        iterations += 1
        
        # Try relocating antennas to better positions
        for i, antenna in enumerate(antennas):
            if not antenna['buildings']:
                continue
            
            # Try moving antenna to demand-weighted centroid
            centroid = find_demand_weighted_centroid(antenna['buildings'], buildings_dict)
            if centroid is None:
                continue
            
            new_x, new_y = centroid
            
            # Check if all buildings still in range
            spec = ANTENNA_TYPES[antenna['type']]
            all_in_range = all(
                is_in_range(new_x, new_y, buildings_dict[bid]['x'], buildings_dict[bid]['y'], spec['range'])
                for bid in antenna['buildings']
            )
            
            if all_in_range and (new_x != antenna['x'] or new_y != antenna['y']):
                antenna['x'] = new_x
                antenna['y'] = new_y
                improved = True
    
    return antennas


def local_search_consolidate(antennas, buildings_dict, kdtree):
    """Try to consolidate nearby antennas."""
    merged = True
    
    while merged:
        merged = False
        
        for i in range(len(antennas)):
            if i >= len(antennas):
                break
            
            for j in range(i + 1, len(antennas)):
                if j >= len(antennas):
                    break
                
                a1, a2 = antennas[i], antennas[j]
                
                # Try to merge if close enough
                if distance(a1['x'], a1['y'], a2['x'], a2['y']) < 1000:
                    combined_buildings = list(set(a1['buildings'] + a2['buildings']))
                    
                    # Find centroid
                    centroid = find_demand_weighted_centroid(combined_buildings, buildings_dict)
                    if centroid is None:
                        continue
                    
                    # Try to find antenna that can cover all
                    antenna_type = select_antenna_type(combined_buildings, buildings_dict, centroid[0], centroid[1])
                    
                    if antenna_type is not None:
                        # Successful merge
                        antennas[i] = {
                            'type': antenna_type,
                            'x': centroid[0],
                            'y': centroid[1],
                            'buildings': combined_buildings
                        }
                        antennas.pop(j)
                        merged = True
                        break
            
            if merged:
                break
    
    return antennas


def solve(dataset: dict, *, seed: int, params: dict = None) -> SolverResult:
    """
    Advanced solver optimized for 3_suburbia dataset characteristics.
    """
    if params is None:
        params = {}
    
    rng = random.Random(seed)
    buildings = dataset['buildings']
    
    # Build lookup structures
    buildings_dict = {b['id']: b for b in buildings}
    kdtree = KDTree(buildings)
    
    # Multi-start: generate multiple solutions
    solutions = []
    
    # Solution 1: Furthest-first construction
    sol1 = greedy_construction_furthest_first(buildings, buildings_dict, kdtree, rng)
    sol1 = local_search_swap(sol1, buildings_dict, kdtree, rng, max_iterations=50)
    sol1 = local_search_consolidate(sol1, buildings_dict, kdtree)
    solutions.append(sol1)
    
    # Solution 2: Density-based construction
    sol2 = greedy_construction_density_based(buildings, buildings_dict, kdtree, rng)
    sol2 = local_search_swap(sol2, buildings_dict, kdtree, rng, max_iterations=50)
    sol2 = local_search_consolidate(sol2, buildings_dict, kdtree)
    solutions.append(sol2)
    
    # Solution 3: Random seed with different parameters
    rng2 = random.Random(seed + 12345)
    remaining_buildings = buildings.copy()
    rng2.shuffle(remaining_buildings)
    sol3 = greedy_construction_density_based(remaining_buildings, buildings_dict, kdtree, rng2)
    sol3 = local_search_consolidate(sol3, buildings_dict, kdtree)
    solutions.append(sol3)
    
    # Select best solution by antenna count (proxy for cost)
    best_solution = min(solutions, key=lambda s: len(s))
    
    # Final validation and repair
    covered = set()
    for antenna in best_solution:
        covered.update(antenna['buildings'])
    
    all_building_ids = {b['id'] for b in buildings}
    uncovered = all_building_ids - covered
    
    # Cover any remaining buildings
    for bid in uncovered:
        b = buildings_dict[bid]
        best_solution.append({
            'type': 'MaxRange',
            'x': b['x'],
            'y': b['y'],
            'buildings': [bid]
        })
    
    return {'antennas': best_solution}