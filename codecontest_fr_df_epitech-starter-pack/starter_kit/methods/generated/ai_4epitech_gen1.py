"""
AI-Generated Solver
Generated: 2025-12-29 22:20:01
Model: claude-sonnet-4-5-20250929

This solver was automatically generated by Claude AI based on
analysis of existing solver performance patterns.
"""

"""
Hierarchical demand-aware solver optimized for dense, low-clustering datasets.

Strategy:
1. Spatial decomposition using grid-based partitioning for O(n log n) neighbor queries
2. Demand-weighted centroid initialization for antenna placement
3. Iterative refinement with capacity-aware reassignment
4. Multi-start local search with best solution tracking
5. Exploits dense distribution by optimizing for building colocation
"""
import random
import math
from typing import Dict, List, Set, Tuple, Optional
from collections import defaultdict
from ..base import (
    SolverResult,
    ANTENNA_TYPES,
    ANTENNA_TYPES_BY_CAPACITY,
    get_building_demand,
    is_in_range,
    distance
)


def solve(dataset: dict, *, seed: int, params: dict = None) -> SolverResult:
    """
    Hierarchical demand-aware solver for dense distributions.
    
    Args:
        dataset: Dataset dict with 'buildings' key
        seed: Random seed for reproducibility
        params: Optional parameters
        
    Returns:
        SolverResult with optimized solution
    """
    if params is None:
        params = {}
    
    rng = random.Random(seed)
    buildings = dataset['buildings']
    
    # Precompute building data
    building_by_id = {b['id']: b for b in buildings}
    building_demands = {b['id']: get_building_demand(b) for b in buildings}
    
    # Build spatial index for fast neighbor queries
    spatial_index = build_spatial_index(buildings)
    
    # Multi-start approach: run multiple times and keep best
    best_solution = None
    best_cost = float('inf')
    
    num_restarts = 3
    for restart in range(num_restarts):
        restart_seed = seed + restart * 1000
        solution = construct_solution(
            buildings, building_by_id, building_demands, 
            spatial_index, restart_seed
        )
        
        # Local improvement
        solution = local_search(
            solution, buildings, building_by_id, 
            building_demands, spatial_index, restart_seed
        )
        
        # Calculate cost
        cost = calculate_cost(solution, building_by_id)
        
        if cost < best_cost:
            best_cost = cost
            best_solution = solution
    
    return {'antennas': best_solution}


def build_spatial_index(buildings: List[dict]) -> Dict[Tuple[int, int], List[dict]]:
    """Build grid-based spatial index for O(1) neighbor queries."""
    # Use grid cells of 1000 units (smaller than smallest antenna range)
    grid_size = 1000
    index = defaultdict(list)
    
    for b in buildings:
        cell_x = b['x'] // grid_size
        cell_y = b['y'] // grid_size
        index[(cell_x, cell_y)].append(b)
    
    return index


def get_nearby_buildings(x: int, y: int, max_range: int, 
                        spatial_index: Dict[Tuple[int, int], List[dict]]) -> List[dict]:
    """Get buildings within max_range using spatial index."""
    grid_size = 1000
    cell_x = x // grid_size
    cell_y = y // grid_size
    
    # Check surrounding cells
    cell_radius = (max_range // grid_size) + 1
    nearby = []
    
    for dx in range(-cell_radius, cell_radius + 1):
        for dy in range(-cell_radius, cell_radius + 1):
            cell = (cell_x + dx, cell_y + dy)
            if cell in spatial_index:
                for b in spatial_index[cell]:
                    if distance(x, y, b['x'], b['y']) <= max_range:
                        nearby.append(b)
    
    return nearby


def construct_solution(buildings: List[dict], building_by_id: Dict[int, dict],
                      building_demands: Dict[int, int], 
                      spatial_index: Dict[Tuple[int, int], List[dict]],
                      seed: int) -> List[dict]:
    """Construct initial solution using demand-weighted clustering."""
    rng = random.Random(seed)
    
    covered = set()
    antennas = []
    
    # Sort buildings by demand (high to low) with slight randomization
    building_list = sorted(
        buildings, 
        key=lambda b: building_demands[b['id']] + rng.uniform(0, 50),
        reverse=True
    )
    
    for building in building_list:
        if building['id'] in covered:
            continue
        
        # Find best antenna placement using demand-weighted centroid
        best_antenna = find_best_antenna_placement(
            building, buildings, building_by_id, building_demands,
            spatial_index, covered, rng
        )
        
        if best_antenna:
            antennas.append(best_antenna)
            covered.update(best_antenna['buildings'])
    
    # Ensure all buildings covered
    all_ids = {b['id'] for b in buildings}
    uncovered = all_ids - covered
    
    for bid in uncovered:
        b = building_by_id[bid]
        antennas.append({
            'type': 'MaxRange',
            'x': b['x'],
            'y': b['y'],
            'buildings': [bid]
        })
    
    return antennas


def find_best_antenna_placement(seed_building: dict, all_buildings: List[dict],
                                building_by_id: Dict[int, dict],
                                building_demands: Dict[int, int],
                                spatial_index: Dict[Tuple[int, int], List[dict]],
                                covered: Set[int], rng: random.Random) -> Optional[dict]:
    """Find optimal antenna placement for seed building using demand-weighted centroid."""
    
    # Try each antenna type from smallest to largest
    for antenna_type in ANTENNA_TYPES_BY_CAPACITY:
        antenna_spec = ANTENNA_TYPES[antenna_type]
        antenna_range = antenna_spec['range']
        antenna_capacity = antenna_spec['capacity']
        
        # Find candidate placement locations
        candidates = get_nearby_buildings(
            seed_building['x'], seed_building['y'],
            antenna_range, spatial_index
        )
        
        # Filter to uncovered buildings within range of seed
        candidates = [
            b for b in candidates 
            if b['id'] not in covered and 
            is_in_range(seed_building['x'], seed_building['y'], b['x'], b['y'], antenna_range)
        ]
        
        if not candidates or seed_building['id'] not in [c['id'] for c in candidates]:
            continue
        
        # Calculate demand-weighted centroid for antenna placement
        placement_x, placement_y = calculate_weighted_centroid(
            candidates, building_demands
        )
        
        # Check if placement on building for cost discount
        best_placement = find_nearest_building_location(
            placement_x, placement_y, candidates
        )
        
        # Assign buildings to this antenna
        assignment = assign_buildings_to_antenna(
            best_placement[0], best_placement[1], antenna_range,
            antenna_capacity, candidates, building_by_id, covered
        )
        
        # Must cover seed building
        if seed_building['id'] in assignment:
            return {
                'type': antenna_type,
                'x': best_placement[0],
                'y': best_placement[1],
                'buildings': assignment
            }
    
    # Fallback to MaxRange on seed building
    return {
        'type': 'MaxRange',
        'x': seed_building['x'],
        'y': seed_building['y'],
        'buildings': [seed_building['id']]
    }


def calculate_weighted_centroid(buildings: List[dict], 
                               building_demands: Dict[int, int]) -> Tuple[int, int]:
    """Calculate demand-weighted centroid of buildings."""
    total_weight = 0
    weighted_x = 0
    weighted_y = 0
    
    for b in buildings:
        weight = building_demands[b['id']]
        weighted_x += b['x'] * weight
        weighted_y += b['y'] * weight
        total_weight += weight
    
    if total_weight == 0:
        return buildings[0]['x'], buildings[0]['y']
    
    return int(weighted_x / total_weight), int(weighted_y / total_weight)


def find_nearest_building_location(target_x: int, target_y: int, 
                                   buildings: List[dict]) -> Tuple[int, int]:
    """Find building location nearest to target point."""
    best_dist = float('inf')
    best_loc = (buildings[0]['x'], buildings[0]['y'])
    
    for b in buildings:
        dist = distance(target_x, target_y, b['x'], b['y'])
        if dist < best_dist:
            best_dist = dist
            best_loc = (b['x'], b['y'])
    
    return best_loc


def assign_buildings_to_antenna(antenna_x: int, antenna_y: int, antenna_range: int,
                               antenna_capacity: int, candidates: List[dict],
                               building_by_id: Dict[int, dict],
                               covered: Set[int]) -> List[int]:
    """Assign buildings to antenna using greedy capacity-aware approach."""
    # Filter and sort candidates by demand
    valid_candidates = [
        b for b in candidates
        if b['id'] not in covered and 
        is_in_range(antenna_x, antenna_y, b['x'], b['y'], antenna_range)
    ]
    
    valid_candidates.sort(key=lambda b: get_building_demand(b), reverse=True)
    
    assignment = []
    total_peak = 0
    total_off_peak = 0
    total_night = 0
    
    for b in valid_candidates:
        new_peak = total_peak + b['populationPeakHours']
        new_off_peak = total_off_peak + b['populationOffPeakHours']
        new_night = total_night + b['populationNight']
        new_max = max(new_peak, new_off_peak, new_night)
        
        if new_max <= antenna_capacity:
            assignment.append(b['id'])
            total_peak = new_peak
            total_off_peak = new_off_peak
            total_night = new_night
    
    return assignment


def local_search(antennas: List[dict], buildings: List[dict],
                building_by_id: Dict[int, dict], building_demands: Dict[int, int],
                spatial_index: Dict[Tuple[int, int], List[dict]],
                seed: int) -> List[dict]:
    """Apply local search to improve solution."""
    rng = random.Random(seed)
    
    improved = True
    iterations = 0
    max_iterations = 50
    
    while improved and iterations < max_iterations:
        improved = False
        iterations += 1
        
        # Try to merge nearby antennas
        merged = try_merge_antennas(antennas, building_by_id)
        if merged != antennas:
            antennas = merged
            improved = True
            continue
        
        # Try to downgrade antenna types
        downgraded = try_downgrade_antennas(antennas, building_by_id)
        if downgraded != antennas:
            antennas = downgraded
            improved = True
            continue
        
        # Try to relocate antennas
        relocated = try_relocate_antennas(antennas, building_by_id, building_demands, rng)
        if relocated != antennas:
            antennas = relocated
            improved = True
    
    return antennas


def try_merge_antennas(antennas: List[dict], 
                      building_by_id: Dict[int, dict]) -> List[dict]:
    """Try to merge nearby antennas to reduce count."""
    if len(antennas) < 2:
        return antennas
    
    new_antennas = []
    merged_indices = set()
    
    for i, ant1 in enumerate(antennas):
        if i in merged_indices:
            continue
        
        merged = False
        for j, ant2 in enumerate(antennas[i+1:], start=i+1):
            if j in merged_indices:
                continue
            
            # Check if antennas are close enough to merge
            if distance(ant1['x'], ant1['y'], ant2['x'], ant2['y']) > 2000:
                continue
            
            # Try to merge into single antenna
            combined_buildings = list(set(ant1['buildings'] + ant2['buildings']))
            
            # Calculate combined demand
            total_peak = sum(building_by_id[bid]['populationPeakHours'] 
                           for bid in combined_buildings)
            total_off_peak = sum(building_by_id[bid]['populationOffPeakHours'] 
                               for bid in combined_buildings)
            total_night = sum(building_by_id[bid]['populationNight'] 
                            for bid in combined_buildings)
            max_demand = max(total_peak, total_off_peak, total_night)
            
            # Find suitable antenna type
            for antenna_type in ANTENNA_TYPES_BY_CAPACITY:
                spec = ANTENNA_TYPES[antenna_type]
                if max_demand <= spec['capacity']:
                    # Check range from centroid
                    cx = sum(building_by_id[bid]['x'] for bid in combined_buildings) // len(combined_buildings)
                    cy = sum(building_by_id[bid]['y'] for bid in combined_buildings) // len(combined_buildings)
                    
                    # Find building location nearest to centroid
                    best_x, best_y = None, None
                    best_dist = float('inf')
                    for bid in combined_buildings:
                        b = building_by_id[bid]
                        d = distance(cx, cy, b['x'], b['y'])
                        if d < best_dist:
                            best_dist = d
                            best_x, best_y = b['x'], b['y']
                    
                    # Check if all buildings in range
                    all_in_range = all(
                        is_in_range(best_x, best_y, 
                                   building_by_id[bid]['x'], 
                                   building_by_id[bid]['y'], 
                                   spec['range'])
                        for bid in combined_buildings
                    )
                    
                    if all_in_range:
                        new_antennas.append({
                            'type': antenna_type,
                            'x': best_x,
                            'y': best_y,
                            'buildings': combined_buildings
                        })
                        merged_indices.add(i)
                        merged_indices.add(j)
                        merged = True
                        break
            
            if merged:
                break
        
        if not merged:
            new_antennas.append(ant1)
    
    return new_antennas if len(new_antennas) < len(antennas) else antennas


def try_downgrade_antennas(antennas: List[dict], 
                          building_by_id: Dict[int, dict]) -> List[dict]:
    """Try to downgrade antennas to cheaper types."""
    new_antennas = []
    
    for ant in antennas:
        current_type = ant['type']
        current_idx = ANTENNA_TYPES_BY_CAPACITY.index(current_type)
        
        # Calculate actual demand
        total_peak = sum(building_by_id[bid]['populationPeakHours'] 
                        for bid in ant['buildings'])
        total_off_peak = sum(building_by_id[bid]['populationOffPeakHours'] 
                            for bid in ant['buildings'])
        total_night = sum(building_by_id[bid]['populationNight'] 
                         for bid in ant['buildings'])
        max_demand = max(total_peak, total_off_peak, total_night)
        
        # Try smaller antenna types
        downgraded = False
        for i in range(current_idx):
            candidate_type = ANTENNA_TYPES_BY_CAPACITY[i]
            spec = ANTENNA_TYPES[candidate_type]
            
            if max_demand <= spec['capacity']:
                # Check range
                all_in_range = all(
                    is_in_range(ant['x'], ant['y'],
                               building_by_id[bid]['x'],
                               building_by_id[bid]['y'],
                               spec['range'])
                    for bid in ant['buildings']
                )
                
                if all_in_range:
                    new_antennas.append({
                        'type': candidate_type,
                        'x': ant['x'],
                        'y': ant['y'],
                        'buildings': ant['buildings']
                    })
                    downgraded = True
                    break
        
        if not downgraded:
            new_antennas.append(ant)
    
    return new_antennas


def try_relocate_antennas(antennas: List[dict], building_by_id: Dict[int, dict],
                         building_demands: Dict[int, int], 
                         rng: random.Random) -> List[dict]:
    """Try to relocate antennas to better positions."""
    new_antennas = []
    
    for ant in antennas:
        if len(ant['buildings']) <= 1:
            new_antennas.append(ant)
            continue
        
        # Calculate demand-weighted centroid
        buildings_list = [building_by_id[bid] for bid in ant['buildings']]
        cx, cy = calculate_weighted_centroid(buildings_list, building_demands)
        
        # Find nearest building to centroid
        best_x, best_y = find_nearest_building_location(cx, cy, buildings_list)
        
        # Check if relocation improves (all buildings still in range)
        spec = ANTENNA_TYPES[ant['type']]
        all_in_range = all(
            is_in_range(best_x, best_y,
                       building_by_id[bid]['x'],
                       building_by_id[bid]['y'],
                       spec['range'])
            for bid in ant['buildings']
        )
        
        if all_in_range and (best_x != ant['x'] or best_y != ant['y']):
            new_antennas.append({
                'type': ant['type'],
                'x': best_x,
                'y': best_y,
                'buildings': ant['buildings']
            })
        else:
            new_antennas.append(ant)
    
    return new_antennas


def calculate_cost(antennas: List[dict], building_by_id: Dict[int, dict]) -> int:
    """Calculate total cost of solution."""
    total_cost = 0
    
    for ant in antennas:
        spec = ANTENNA_TYPES[ant['type']]
        base_cost = spec['cost']
        
        # Check if on building location for discount
        on_building = any(
            b['x'] == ant['x'] and b['y'] == ant['y']
            for b in building_by_id.values()
        )
        
        if on_building:
            total_cost += base_cost
        else:
            total_cost += base_cost * 3
    
    return total_cost