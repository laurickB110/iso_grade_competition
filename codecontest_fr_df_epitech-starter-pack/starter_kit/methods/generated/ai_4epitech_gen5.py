"""
AI-Generated Solver
Generated: 2025-12-29 22:29:31
Model: claude-sonnet-4-5-20250929

This solver was automatically generated by Claude AI based on
analysis of existing solver performance patterns.
"""

"""
Multi-scale hierarchical solver optimized for 4_epitech dataset.

Strategy:
1. Hierarchical spatial decomposition using adaptive grid
2. Demand-weighted density clustering to identify micro-clusters
3. Mixed antenna portfolio optimization (exploit economies of scale)
4. Iterative refinement with escape mechanisms
5. Density-aware heuristics for spatially dense configurations

Optimized for: dense distribution, low clustering, 5000 buildings, high spatial spread
"""
import random
import math
from typing import Dict, List, Set, Tuple, Optional
from collections import defaultdict
from ..base import (
    SolverResult,
    ANTENNA_TYPES,
    ANTENNA_TYPES_BY_CAPACITY,
    get_building_demand,
    is_in_range,
    distance
)


def solve(dataset: dict, *, seed: int, params: dict = None) -> SolverResult:
    """
    Multi-scale hierarchical solver with density-aware optimization.
    """
    rng = random.Random(seed)
    buildings = dataset['buildings']
    
    # Phase 1: Preprocessing and spatial indexing
    building_data = preprocess_buildings(buildings)
    
    # Phase 2: Adaptive grid-based spatial decomposition
    grid_cells = create_adaptive_grid(buildings, building_data, grid_size=20)
    
    # Phase 3: Demand-weighted clustering within each cell
    clusters = create_demand_weighted_clusters(buildings, building_data, grid_cells, rng)
    
    # Phase 4: Initial antenna placement using mixed portfolio
    antennas = place_antennas_hierarchical(buildings, building_data, clusters, rng)
    
    # Phase 5: Coverage validation and gap filling
    antennas = fill_coverage_gaps(buildings, building_data, antennas, rng)
    
    # Phase 6: Local optimization with escape mechanisms
    antennas = iterative_refinement(buildings, building_data, antennas, rng, iterations=3)
    
    # Phase 7: Final consolidation pass
    antennas = consolidate_antennas(buildings, building_data, antennas, rng)
    
    return {'antennas': antennas}


def preprocess_buildings(buildings: List[dict]) -> Dict:
    """Precompute building properties and create spatial index."""
    data = {
        'demands': {},
        'coords': {},
        'by_id': {},
        'peak_demand': {},
        'spatial_index': defaultdict(list),
        'bounds': {'min_x': float('inf'), 'max_x': float('-inf'),
                   'min_y': float('inf'), 'max_y': float('-inf')}
    }
    
    for b in buildings:
        bid = b['id']
        data['demands'][bid] = get_building_demand(b)
        data['coords'][bid] = (b['x'], b['y'])
        data['by_id'][bid] = b
        data['peak_demand'][bid] = b['populationPeakHours']
        
        # Update bounds
        data['bounds']['min_x'] = min(data['bounds']['min_x'], b['x'])
        data['bounds']['max_x'] = max(data['bounds']['max_x'], b['x'])
        data['bounds']['min_y'] = min(data['bounds']['min_y'], b['y'])
        data['bounds']['max_y'] = max(data['bounds']['max_y'], b['y'])
        
        # Spatial index (coarse grid for fast neighbor lookup)
        grid_x = b['x'] // 1000
        grid_y = b['y'] // 1000
        data['spatial_index'][(grid_x, grid_y)].append(bid)
    
    return data


def create_adaptive_grid(buildings: List[dict], building_data: Dict, grid_size: int) -> Dict:
    """Create adaptive grid with density information."""
    bounds = building_data['bounds']
    width = bounds['max_x'] - bounds['min_x']
    height = bounds['max_y'] - bounds['min_y']
    
    cell_width = width / grid_size
    cell_height = height / grid_size
    
    grid = defaultdict(lambda: {'buildings': [], 'total_demand': 0, 'center': None})
    
    for b in buildings:
        cell_x = int((b['x'] - bounds['min_x']) / cell_width)
        cell_y = int((b['y'] - bounds['min_y']) / cell_height)
        cell_x = min(cell_x, grid_size - 1)
        cell_y = min(cell_y, grid_size - 1)
        
        key = (cell_x, cell_y)
        grid[key]['buildings'].append(b['id'])
        grid[key]['total_demand'] += building_data['demands'][b['id']]
    
    # Compute cell centers
    for (cx, cy), cell in grid.items():
        if cell['buildings']:
            avg_x = sum(building_data['coords'][bid][0] for bid in cell['buildings']) / len(cell['buildings'])
            avg_y = sum(building_data['coords'][bid][1] for bid in cell['buildings']) / len(cell['buildings'])
            cell['center'] = (int(avg_x), int(avg_y))
    
    return grid


def create_demand_weighted_clusters(buildings: List[dict], building_data: Dict, 
                                    grid_cells: Dict, rng: random.Random) -> List[Dict]:
    """Create micro-clusters using demand-weighted k-means++."""
    clusters = []
    
    # Process high-density cells with clustering
    high_density_cells = sorted(
        [(k, v) for k, v in grid_cells.items() if len(v['buildings']) > 10],
        key=lambda x: x[1]['total_demand'],
        reverse=True
    )
    
    for cell_key, cell_data in high_density_cells:
        cell_buildings = [building_data['by_id'][bid] for bid in cell_data['buildings']]
        
        # Determine number of clusters based on total demand and building count
        total_demand = cell_data['total_demand']
        num_buildings = len(cell_buildings)
        
        # Estimate number of antennas needed
        avg_antenna_capacity = 1500  # Approximate average
        estimated_antennas = max(1, int(math.ceil(total_demand / avg_antenna_capacity)))
        num_clusters = min(estimated_antennas, max(1, num_buildings // 20))
        
        # K-means++ initialization with demand weighting
        centers = kmeans_plus_plus(cell_buildings, building_data, num_clusters, rng)
        
        for center_x, center_y in centers:
            cluster = {
                'center': (center_x, center_y),
                'buildings': [],
                'total_demand': 0
            }
            clusters.append(cluster)
    
    # Low-density cells: one cluster per cell
    low_density_cells = [(k, v) for k, v in grid_cells.items() if len(v['buildings']) <= 10]
    for cell_key, cell_data in low_density_cells:
        if cell_data['buildings'] and cell_data['center']:
            clusters.append({
                'center': cell_data['center'],
                'buildings': cell_data['buildings'][:],
                'total_demand': cell_data['total_demand']
            })
    
    return clusters


def kmeans_plus_plus(buildings: List[dict], building_data: Dict, 
                     k: int, rng: random.Random) -> List[Tuple[int, int]]:
    """K-means++ initialization with demand weighting."""
    if not buildings or k <= 0:
        return []
    
    centers = []
    
    # First center: weighted by demand
    weights = [building_data['demands'][b['id']] for b in buildings]
    first = rng.choices(buildings, weights=weights, k=1)[0]
    centers.append((first['x'], first['y']))
    
    # Subsequent centers: maximize distance to nearest existing center
    for _ in range(min(k - 1, len(buildings) - 1)):
        distances = []
        for b in buildings:
            min_dist = min(distance(b['x'], b['y'], cx, cy) for cx, cy in centers)
            # Weight by distance squared and demand
            weight = (min_dist ** 2) * building_data['demands'][b['id']]
            distances.append(weight)
        
        if sum(distances) > 0:
            next_building = rng.choices(buildings, weights=distances, k=1)[0]
            centers.append((next_building['x'], next_building['y']))
    
    return centers


def place_antennas_hierarchical(buildings: List[dict], building_data: Dict,
                                clusters: List[Dict], rng: random.Random) -> List[dict]:
    """Place antennas using hierarchical strategy with mixed portfolio."""
    antennas = []
    covered = set()
    
    # Sort clusters by total demand (descending)
    sorted_clusters = sorted(clusters, key=lambda c: c.get('total_demand', 0), reverse=True)
    
    for cluster in sorted_clusters:
        if not cluster['buildings']:
            continue
        
        # Get uncovered buildings in this cluster
        uncovered_in_cluster = [bid for bid in cluster['buildings'] if bid not in covered]
        if not uncovered_in_cluster:
            continue
        
        # Try to cover cluster with optimal antenna placement
        cluster_antennas = cover_cluster_optimally(
            uncovered_in_cluster, building_data, cluster['center'], rng
        )
        
        for ant in cluster_antennas:
            antennas.append(ant)
            covered.update(ant['buildings'])
    
    return antennas


def cover_cluster_optimally(building_ids: List[int], building_data: Dict,
                            suggested_center: Tuple[int, int], rng: random.Random) -> List[dict]:
    """Optimally cover a cluster of buildings with minimal antennas."""
    antennas = []
    remaining = set(building_ids)
    
    while remaining:
        # Find best antenna placement for remaining buildings
        best_antenna = find_best_antenna_placement(remaining, building_data, suggested_center, rng)
        
        if best_antenna:
            antennas.append(best_antenna)
            remaining -= set(best_antenna['buildings'])
        else:
            # Fallback: cover one building at a time
            bid = remaining.pop()
            b = building_data['by_id'][bid]
            antennas.append({
                'type': 'MaxRange',
                'x': b['x'],
                'y': b['y'],
                'buildings': [bid]
            })
    
    return antennas


def find_best_antenna_placement(building_ids: Set[int], building_data: Dict,
                                suggested_center: Tuple[int, int], 
                                rng: random.Random) -> Optional[dict]:
    """Find best antenna type and position to cover maximum buildings."""
    if not building_ids:
        return None
    
    # Candidate positions: building locations + cluster center
    candidates = []
    for bid in building_ids:
        candidates.append(building_data['coords'][bid])
    candidates.append(suggested_center)
    
    # Sample to reduce computation for large clusters
    if len(candidates) > 20:
        candidates = rng.sample(candidates, 20)
    
    best_solution = None
    best_score = -1
    
    for pos_x, pos_y in candidates:
        # Try each antenna type
        for antenna_type in ['Nano', 'Spot', 'Density', 'MaxRange']:
            antenna_spec = ANTENNA_TYPES[antenna_type]
            
            # Find buildings in range
            in_range_ids = []
            for bid in building_ids:
                bx, by = building_data['coords'][bid]
                if is_in_range(pos_x, pos_y, bx, by, antenna_spec['range']):
                    in_range_ids.append(bid)
            
            if not in_range_ids:
                continue
            
            # Pack buildings by capacity
            assignment = pack_buildings_by_capacity(
                in_range_ids, building_data, antenna_spec['capacity']
            )
            
            if not assignment:
                continue
            
            # Score: coverage / cost ratio
            cost = antenna_spec['cost']
            # Discount if on building
            if (pos_x, pos_y) in [building_data['coords'][bid] for bid in building_ids]:
                cost = cost * 0.95
            
            score = len(assignment) / cost
            
            if score > best_score:
                best_score = score
                best_solution = {
                    'type': antenna_type,
                    'x': pos_x,
                    'y': pos_y,
                    'buildings': assignment
                }
    
    return best_solution


def pack_buildings_by_capacity(building_ids: List[int], building_data: Dict, 
                               capacity: int) -> List[int]:
    """Greedily pack buildings into antenna capacity."""
    # Sort by demand (ascending to fit more buildings)
    sorted_ids = sorted(building_ids, key=lambda bid: building_data['demands'][bid])
    
    assignment = []
    total_peak = 0
    total_off_peak = 0
    total_night = 0
    
    for bid in sorted_ids:
        b = building_data['by_id'][bid]
        
        new_peak = total_peak + b['populationPeakHours']
        new_off_peak = total_off_peak + b['populationOffPeakHours']
        new_night = total_night + b['populationNight']
        new_max = max(new_peak, new_off_peak, new_night)
        
        if new_max <= capacity:
            assignment.append(bid)
            total_peak = new_peak
            total_off_peak = new_off_peak
            total_night = new_night
    
    return assignment


def fill_coverage_gaps(buildings: List[dict], building_data: Dict,
                       antennas: List[dict], rng: random.Random) -> List[dict]:
    """Ensure all buildings are covered."""
    covered = set()
    for ant in antennas:
        covered.update(ant['buildings'])
    
    all_ids = {b['id'] for b in buildings}
    uncovered = all_ids - covered
    
    while uncovered:
        bid = uncovered.pop()
        b = building_data['by_id'][bid]
        
        # Try to find nearby antenna that can accommodate this building
        found = False
        for ant in antennas:
            ant_spec = ANTENNA_TYPES[ant['type']]
            
            if is_in_range(ant['x'], ant['y'], b['x'], b['y'], ant_spec['range']):
                # Check capacity
                current_demand = compute_antenna_demand(ant, building_data)
                new_demand = (
                    current_demand[0] + b['populationPeakHours'],
                    current_demand[1] + b['populationOffPeakHours'],
                    current_demand[2] + b['populationNight']
                )
                
                if max(new_demand) <= ant_spec['capacity']:
                    ant['buildings'].append(bid)
                    found = True
                    break
        
        if not found:
            # Create new antenna
            antennas.append({
                'type': 'MaxRange',
                'x': b['x'],
                'y': b['y'],
                'buildings': [bid]
            })
    
    return antennas


def compute_antenna_demand(antenna: dict, building_data: Dict) -> Tuple[int, int, int]:
    """Compute total demand served by antenna."""
    total_peak = 0
    total_off_peak = 0
    total_night = 0
    
    for bid in antenna['buildings']:
        b = building_data['by_id'][bid]
        total_peak += b['populationPeakHours']
        total_off_peak += b['populationOffPeakHours']
        total_night += b['populationNight']
    
    return (total_peak, total_off_peak, total_night)


def iterative_refinement(buildings: List[dict], building_data: Dict,
                        antennas: List[dict], rng: random.Random, 
                        iterations: int = 3) -> List[dict]:
    """Iterative local search with perturbation to escape local optima."""
    best_antennas = antennas
    best_cost = compute_solution_cost(antennas)
    
    for iteration in range(iterations):
        # Perturbation: randomly modify some antennas
        perturbed = perturb_solution(antennas, building_data, rng, 
                                     intensity=0.1 + 0.05 * iteration)
        
        # Local improvement
        improved = local_improvement(perturbed, building_data, rng)
        
        # Accept if better
        cost = compute_solution_cost(improved)
        if cost < best_cost:
            best_antennas = improved
            best_cost = cost
    
    return best_antennas


def perturb_solution(antennas: List[dict], building_data: Dict,
                     rng: random.Random, intensity: float = 0.1) -> List[dict]:
    """Perturb solution to escape local optima."""
    perturbed = [ant.copy() for ant in antennas]
    
    num_to_perturb = max(1, int(len(perturbed) * intensity))
    indices = rng.sample(range(len(perturbed)), min(num_to_perturb, len(perturbed)))
    
    for idx in indices:
        ant = perturbed[idx]
        
        # Strategy: try upgrading or downgrading antenna type
        current_type = ant['type']
        type_idx = ANTENNA_TYPES_BY_CAPACITY.index(current_type)
        
        if rng.random() < 0.5 and type_idx > 0:
            # Try smaller antenna
            new_type = ANTENNA_TYPES_BY_CAPACITY[type_idx - 1]
            new_spec = ANTENNA_TYPES[new_type]
            
            # Repack buildings
            assignment = pack_buildings_by_capacity(
                ant['buildings'], building_data, new_spec['capacity']
            )
            
            if assignment:
                ant['type'] = new_type
                ant['buildings'] = assignment
        elif type_idx < len(ANTENNA_TYPES_BY_CAPACITY) - 1:
            # Try larger antenna
            new_type = ANTENNA_TYPES_BY_CAPACITY[type_idx + 1]
            ant['type'] = new_type
    
    return perturbed


def local_improvement(antennas: List[dict], building_data: Dict,
                      rng: random.Random) -> List[dict]:
    """Local improvement: try to merge or optimize antennas."""
    improved = [ant.copy() for ant in antennas]
    
    # Try to merge small antennas
    i = 0
    while i < len(improved):
        if len(improved[i]['buildings']) <= 3:
            # Try to redistribute buildings to nearby antennas
            buildings_to_redistribute = improved[i]['buildings'][:]
            success = True
            
            for bid in buildings_to_redistribute:
                b = building_data['by_id'][bid]
                placed = False
                
                for j, other_ant in enumerate(improved):
                    if i == j:
                        continue
                    
                    other_spec = ANTENNA_TYPES[other_ant['type']]
                    
                    if is_in_range(other_ant['x'], other_ant['y'], b['x'], b['y'], other_spec['range']):
                        # Check capacity
                        current_demand = compute_antenna_demand(other_ant, building_data)
                        new_demand = (
                            current_demand[0] + b['populationPeakHours'],
                            current_demand[1] + b['populationOffPeakHours'],
                            current_demand[2] + b['populationNight']
                        )
                        
                        if max(new_demand) <= other_spec['capacity']:
                            other_ant['buildings'].append(bid)
                            placed = True
                            break
                
                if not placed:
                    success = False
                    break
            
            if success:
                improved.pop(i)
            else:
                # Restore buildings
                for j, other_ant in enumerate(improved):
                    if i != j:
                        for bid in buildings_to_redistribute:
                            if bid in other_ant['buildings']:
                                other_ant['buildings'].remove(bid)
                i += 1
        else:
            i += 1
    
    return improved


def consolidate_antennas(buildings: List[dict], building_data: Dict,
                        antennas: List[dict], rng: random.Random) -> List[dict]:
    """Final consolidation pass."""
    # Try to downgrade antenna types where possible
    for ant in antennas:
        current_type = ant['type']
        type_idx = ANTENNA_TYPES_BY_CAPACITY.index(current_type)
        
        # Try smaller types
        for i in range(type_idx):
            smaller_type = ANTENNA_TYPES_BY_CAPACITY[i]
            smaller_spec = ANTENNA_TYPES[smaller_type]
            
            # Check if all buildings are in range
            all_in_range = all(
                is_in_range(ant['x'], ant['y'], 
                           building_data['coords'][bid][0],
                           building_data['coords'][bid][1],
                           smaller_spec['range'])
                for bid in ant['buildings']
            )
            
            if not all_in_range:
                break
            
            # Check capacity
            demand = compute_antenna_demand(ant, building_data)
            if max(demand) <= smaller_spec['capacity']:
                ant['type'] = smaller_type
                break
    
    return antennas


def compute_solution_cost(antennas: List[dict]) -> int:
    """Compute total cost of solution (simplified - actual validator is more complex)."""
    total = 0
    for ant in antennas:
        total += ANTENNA_TYPES[ant['type']]['cost']
    return total