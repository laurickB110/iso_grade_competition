"""
AI-Generated Solver
Generated: 2025-12-29 16:58:01
Model: claude-sonnet-4-5-20250929

This solver was automatically generated by Claude AI based on
analysis of existing solver performance patterns.
"""

"""
Cluster-aware weighted geometric median solver optimized for peaceful_village.

Strategy for small, sparse, high-clustering datasets:
1. Detect spatial clusters using distance-based grouping
2. For each cluster, compute demand-weighted geometric median (Weiszfeld algorithm)
3. Evaluate candidate antenna placements at:
   - Cluster centroids (weighted by demand)
   - Building positions (for cost discount)
   - Geometric medians of clusters
4. Use exhaustive search over candidate positions (feasible for 5 buildings)
5. Select optimal antenna type and assignment for each position
6. Apply cost-benefit pruning to minimize total installation cost
"""
import random
from typing import Dict, List, Set, Tuple, Optional
from ..base import (
    SolverResult,
    ANTENNA_TYPES,
    ANTENNA_TYPES_BY_CAPACITY,
    get_building_demand,
    is_in_range,
    distance
)


def solve(dataset: dict, *, seed: int, params: dict = None) -> SolverResult:
    """
    Cluster-aware geometric median solver for small sparse datasets.
    
    Args:
        dataset: Dataset dict with 'buildings' key
        seed: Random seed for reproducibility
        params: Optional parameters
        
    Returns:
        SolverResult with optimized antenna placement
    """
    rng = random.Random(seed)
    buildings = dataset['buildings']
    
    if not buildings:
        return {'antennas': []}
    
    # Precompute building information
    building_by_id = {b['id']: b for b in buildings}
    building_demands = {b['id']: get_building_demand(b) for b in buildings}
    
    # Detect clusters
    clusters = detect_clusters(buildings, building_demands)
    
    # Generate candidate antenna positions
    candidates = generate_candidate_positions(buildings, clusters, building_demands)
    
    # Find optimal solution using exhaustive search (feasible for 5 buildings)
    best_solution = find_optimal_placement(
        buildings, building_by_id, building_demands, candidates, rng
    )
    
    return {'antennas': best_solution}


def detect_clusters(buildings: List[dict], building_demands: Dict[int, int]) -> List[List[int]]:
    """
    Detect spatial clusters using distance-based grouping.
    
    For small datasets, use simple distance threshold clustering.
    """
    if len(buildings) <= 1:
        return [[b['id'] for b in buildings]]
    
    # Calculate average pairwise distance to determine threshold
    distances = []
    for i, b1 in enumerate(buildings):
        for b2 in buildings[i+1:]:
            dist = distance(b1['x'], b1['y'], b2['x'], b2['y'])
            distances.append(dist)
    
    if not distances:
        return [[b['id'] for b in buildings]]
    
    avg_dist = sum(distances) / len(distances)
    cluster_threshold = avg_dist * 0.8  # Adaptive threshold
    
    # Simple agglomerative clustering
    clusters = [[b['id']] for b in buildings]
    building_positions = {b['id']: (b['x'], b['y']) for b in buildings}
    
    merged = True
    while merged and len(clusters) > 1:
        merged = False
        best_merge = None
        best_dist = cluster_threshold
        
        for i in range(len(clusters)):
            for j in range(i + 1, len(clusters)):
                # Calculate minimum distance between clusters
                min_dist = float('inf')
                for bid1 in clusters[i]:
                    for bid2 in clusters[j]:
                        pos1 = building_positions[bid1]
                        pos2 = building_positions[bid2]
                        dist = distance(pos1[0], pos1[1], pos2[0], pos2[1])
                        min_dist = min(min_dist, dist)
                
                if min_dist < best_dist:
                    best_dist = min_dist
                    best_merge = (i, j)
        
        if best_merge:
            i, j = best_merge
            clusters[i].extend(clusters[j])
            clusters.pop(j)
            merged = True
    
    return clusters


def weighted_geometric_median(buildings: List[dict], building_demands: Dict[int, int],
                              building_ids: List[int], iterations: int = 50) -> Tuple[float, float]:
    """
    Calculate demand-weighted geometric median using Weiszfeld algorithm.
    
    This finds the point that minimizes sum of weighted distances to buildings.
    """
    if not building_ids:
        return (0, 0)
    
    # Start with weighted centroid
    total_weight = sum(building_demands[bid] for bid in building_ids)
    building_by_id = {b['id']: b for b in buildings}
    
    x = sum(building_by_id[bid]['x'] * building_demands[bid] for bid in building_ids) / total_weight
    y = sum(building_by_id[bid]['y'] * building_demands[bid] for bid in building_ids) / total_weight
    
    # Iterative refinement (Weiszfeld algorithm)
    for _ in range(iterations):
        numerator_x = 0
        numerator_y = 0
        denominator = 0
        
        for bid in building_ids:
            b = building_by_id[bid]
            weight = building_demands[bid]
            dist = distance(x, y, b['x'], b['y'])
            
            if dist < 1e-6:  # Avoid division by zero
                continue
            
            numerator_x += weight * b['x'] / dist
            numerator_y += weight * b['y'] / dist
            denominator += weight / dist
        
        if denominator > 0:
            x = numerator_x / denominator
            y = numerator_y / denominator
    
    return (int(round(x)), int(round(y)))


def generate_candidate_positions(buildings: List[dict], clusters: List[List[int]],
                                building_demands: Dict[int, int]) -> List[Tuple[int, int]]:
    """
    Generate candidate antenna positions based on geometric and demand characteristics.
    """
    candidates = set()
    building_by_id = {b['id']: b for b in buildings}
    
    # Add all building positions (for cost discount)
    for b in buildings:
        candidates.add((b['x'], b['y']))
    
    # Add cluster centroids (demand-weighted)
    for cluster in clusters:
        if cluster:
            total_demand = sum(building_demands[bid] for bid in cluster)
            cx = sum(building_by_id[bid]['x'] * building_demands[bid] for bid in cluster) / total_demand
            cy = sum(building_by_id[bid]['y'] * building_demands[bid] for bid in cluster) / total_demand
            candidates.add((int(round(cx)), int(round(cy))))
    
    # Add geometric medians for each cluster
    for cluster in clusters:
        if cluster:
            median_pos = weighted_geometric_median(buildings, building_demands, cluster)
            candidates.add(median_pos)
    
    # Add global weighted centroid
    total_demand = sum(building_demands.values())
    global_cx = sum(b['x'] * building_demands[b['id']] for b in buildings) / total_demand
    global_cy = sum(b['y'] * building_demands[b['id']] for b in buildings) / total_demand
    candidates.add((int(round(global_cx)), int(round(global_cy))))
    
    # Add global geometric median
    all_ids = [b['id'] for b in buildings]
    global_median = weighted_geometric_median(buildings, building_demands, all_ids)
    candidates.add(global_median)
    
    return list(candidates)


def find_optimal_placement(buildings: List[dict], building_by_id: Dict[int, dict],
                          building_demands: Dict[int, int], candidates: List[Tuple[int, int]],
                          rng: random.Random) -> List[dict]:
    """
    Find optimal antenna placement using exhaustive search over candidate positions.
    
    For each subset of uncovered buildings, try all candidate positions and antenna types.
    """
    all_building_ids = set(b['id'] for b in buildings)
    best_solution = None
    best_cost = float('inf')
    
    # Try different antenna placement strategies
    for _ in range(100):  # Multiple attempts with different orderings
        solution = greedy_placement(buildings, building_by_id, building_demands, 
                                   candidates, all_building_ids.copy(), rng)
        cost = calculate_solution_cost(solution, buildings)
        
        if cost < best_cost:
            best_cost = cost
            best_solution = solution
    
    # Ensure all buildings are covered
    if best_solution:
        covered = set()
        for ant in best_solution:
            covered.update(ant['buildings'])
        
        if covered != all_building_ids:
            # Add missing buildings
            uncovered = all_building_ids - covered
            for bid in uncovered:
                b = building_by_id[bid]
                best_solution.append({
                    'type': 'MaxRange',
                    'x': b['x'],
                    'y': b['y'],
                    'buildings': [bid]
                })
    
    return best_solution if best_solution else []


def greedy_placement(buildings: List[dict], building_by_id: Dict[int, dict],
                    building_demands: Dict[int, int], candidates: List[Tuple[int, int]],
                    uncovered: Set[int], rng: random.Random) -> List[dict]:
    """
    Greedy antenna placement with randomized candidate ordering.
    """
    antennas = []
    candidate_list = candidates.copy()
    rng.shuffle(candidate_list)
    
    while uncovered:
        best_antenna = None
        best_value = -1
        
        # Try each candidate position
        for x, y in candidate_list:
            # Try each antenna type
            for antenna_type in ANTENNA_TYPES_BY_CAPACITY:
                antenna_spec = ANTENNA_TYPES[antenna_type]
                ant_range = antenna_spec['range']
                ant_capacity = antenna_spec['capacity']
                ant_cost = antenna_spec['baseCost']
                
                # Check if position is on a building for discount
                on_building = any(b['x'] == x and b['y'] == y for b in buildings)
                if on_building:
                    ant_cost = int(ant_cost * 0.9)
                
                # Find buildings we can cover
                can_cover = []
                for bid in uncovered:
                    b = building_by_id[bid]
                    if is_in_range(x, y, b['x'], b['y'], ant_range):
                        can_cover.append(bid)
                
                if not can_cover:
                    continue
                
                # Pack buildings greedily by demand
                assignment = pack_buildings(can_cover, building_by_id, ant_capacity)
                
                if assignment:
                    # Calculate value: buildings covered per unit cost
                    value = len(assignment) / ant_cost
                    
                    if value > best_value:
                        best_value = value
                        best_antenna = {
                            'type': antenna_type,
                            'x': x,
                            'y': y,
                            'buildings': assignment
                        }
        
        if best_antenna:
            antennas.append(best_antenna)
            uncovered -= set(best_antenna['buildings'])
        else:
            # Fallback: cover one building with MaxRange
            if uncovered:
                bid = uncovered.pop()
                b = building_by_id[bid]
                antennas.append({
                    'type': 'MaxRange',
                    'x': b['x'],
                    'y': b['y'],
                    'buildings': [bid]
                })
    
    return antennas


def pack_buildings(building_ids: List[int], building_by_id: Dict[int, dict],
                  capacity: int) -> List[int]:
    """
    Pack buildings into antenna capacity using greedy algorithm.
    """
    # Sort by demand (descending) for better packing
    sorted_ids = sorted(building_ids, 
                       key=lambda bid: get_building_demand(building_by_id[bid]), 
                       reverse=True)
    
    assignment = []
    total_peak = 0
    total_off_peak = 0
    total_night = 0
    
    for bid in sorted_ids:
        b = building_by_id[bid]
        new_peak = total_peak + b['populationPeakHours']
        new_off_peak = total_off_peak + b['populationOffPeakHours']
        new_night = total_night + b['populationNight']
        new_max = max(new_peak, new_off_peak, new_night)
        
        if new_max <= capacity:
            assignment.append(bid)
            total_peak = new_peak
            total_off_peak = new_off_peak
            total_night = new_night
    
    return assignment


def calculate_solution_cost(antennas: List[dict], buildings: List[dict]) -> int:
    """
    Calculate total installation cost of a solution.
    """
    total_cost = 0
    building_positions = {(b['x'], b['y']) for b in buildings}
    
    for ant in antennas:
        base_cost = ANTENNA_TYPES[ant['type']]['baseCost']
        on_building = (ant['x'], ant['y']) in building_positions
        cost = int(base_cost * 0.9) if on_building else base_cost
        total_cost += cost
    
    return total_cost