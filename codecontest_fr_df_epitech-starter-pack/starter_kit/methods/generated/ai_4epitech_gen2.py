"""
AI-Generated Solver
Generated: 2025-12-29 17:26:40
Model: claude-sonnet-4-5-20250929

This solver was automatically generated by Claude AI based on
analysis of existing solver performance patterns.
"""

"""
Advanced hierarchical clustering solver optimized for large dense datasets with low natural clustering.

Strategy for 4_epitech (5000 buildings, low clustering, dense distribution):
1. Create spatial grid to partition space for efficient nearest-neighbor queries
2. Use demand-weighted K-means++ initialization to find strategic antenna locations
3. Hierarchical assignment: first assign to nearby high-capacity antennas, then fill gaps
4. Multi-pass optimization: iterative reassignment and antenna type downgrading
5. Local search with 2-opt style swaps to escape local optima
"""
import random
import math
from collections import defaultdict
from typing import Dict, List, Set, Tuple, Optional
from .base import (
    SolverResult,
    ANTENNA_TYPES,
    ANTENNA_TYPES_BY_CAPACITY,
    get_building_demand,
    is_in_range,
    distance
)


def solve(dataset: dict, *, seed: int, params: dict = None) -> SolverResult:
    """
    Hierarchical demand-aware clustering solver.
    
    Args:
        dataset: Dataset dict with 'buildings' key
        seed: Random seed for reproducibility
        params: Optional parameters
        
    Returns:
        SolverResult with optimized antenna placement
    """
    if params is None:
        params = {}
    
    rng = random.Random(seed)
    buildings = dataset['buildings']
    
    # Precompute building data
    building_by_id = {b['id']: b for b in buildings}
    building_demands = {b['id']: get_building_demand(b) for b in buildings}
    
    # Phase 1: Spatial grid for efficient queries
    grid = SpatialGrid(buildings, cell_size=2000)
    
    # Phase 2: Demand-weighted K-means++ to find initial antenna locations
    num_initial_antennas = max(100, len(buildings) // 50)  # ~100 for 5000 buildings
    cluster_centers = kmeans_plusplus_init(buildings, building_demands, num_initial_antennas, rng)
    
    # Phase 3: Create initial antennas with hierarchical assignment
    antennas = create_initial_antennas(cluster_centers, buildings, building_by_id, 
                                       building_demands, grid)
    
    # Phase 4: Iterative improvement
    antennas = iterative_improvement(antennas, buildings, building_by_id, 
                                     building_demands, grid, rng, iterations=3)
    
    # Phase 5: Antenna type optimization (downgrade where possible)
    antennas = optimize_antenna_types(antennas, buildings, building_by_id)
    
    # Phase 6: Final coverage check and repair
    antennas = ensure_full_coverage(antennas, buildings, building_by_id, building_demands)
    
    return {'antennas': antennas}


class SpatialGrid:
    """Spatial grid for efficient range queries."""
    
    def __init__(self, buildings: List[dict], cell_size: int = 2000):
        self.cell_size = cell_size
        self.grid = defaultdict(list)
        
        self.min_x = min(b['x'] for b in buildings)
        self.min_y = min(b['y'] for b in buildings)
        
        for b in buildings:
            cell = self._get_cell(b['x'], b['y'])
            self.grid[cell].append(b)
    
    def _get_cell(self, x: int, y: int) -> Tuple[int, int]:
        return ((x - self.min_x) // self.cell_size, (y - self.min_y) // self.cell_size)
    
    def get_nearby_buildings(self, x: int, y: int, max_range: int) -> List[dict]:
        """Get buildings within bounding box around point."""
        cell_radius = (max_range // self.cell_size) + 1
        center_cell = self._get_cell(x, y)
        
        nearby = []
        for dx in range(-cell_radius, cell_radius + 1):
            for dy in range(-cell_radius, cell_radius + 1):
                cell = (center_cell[0] + dx, center_cell[1] + dy)
                nearby.extend(self.grid.get(cell, []))
        
        return nearby


def kmeans_plusplus_init(buildings: List[dict], building_demands: Dict[int, int],
                         k: int, rng: random.Random) -> List[Tuple[int, int]]:
    """K-means++ initialization weighted by building demand."""
    if k >= len(buildings):
        return [(b['x'], b['y']) for b in buildings]
    
    centers = []
    
    # First center: weighted random selection
    weights = [building_demands[b['id']] for b in buildings]
    first = rng.choices(buildings, weights=weights, k=1)[0]
    centers.append((first['x'], first['y']))
    
    # Remaining centers: proportional to distance from nearest center
    for _ in range(k - 1):
        distances = []
        for b in buildings:
            min_dist = min(distance(b['x'], b['y'], cx, cy) for cx, cy in centers)
            # Weight by both distance and demand
            weighted_dist = min_dist * math.sqrt(building_demands[b['id']])
            distances.append(weighted_dist ** 2)
        
        total = sum(distances)
        if total == 0:
            # All buildings coincide with centers
            break
        
        probs = [d / total for d in distances]
        next_building = rng.choices(buildings, weights=probs, k=1)[0]
        centers.append((next_building['x'], next_building['y']))
    
    return centers


def create_initial_antennas(centers: List[Tuple[int, int]], buildings: List[dict],
                            building_by_id: Dict[int, dict], building_demands: Dict[int, int],
                            grid: SpatialGrid) -> List[dict]:
    """Create initial antenna placement using cluster centers."""
    antennas = []
    covered = set()
    
    # Sort centers by total nearby demand (prioritize high-demand areas)
    center_priorities = []
    for cx, cy in centers:
        nearby = grid.get_nearby_buildings(cx, cy, ANTENNA_TYPES['MaxRange']['range'])
        total_demand = sum(building_demands[b['id']] for b in nearby if b['id'] not in covered)
        center_priorities.append((total_demand, cx, cy))
    
    center_priorities.sort(reverse=True)
    
    for _, cx, cy in center_priorities:
        if len(covered) == len(buildings):
            break
        
        # Try antenna types from largest to smallest for initial coverage
        for antenna_type in reversed(ANTENNA_TYPES_BY_CAPACITY):
            spec = ANTENNA_TYPES[antenna_type]
            antenna_range = spec['range']
            capacity = spec['capacity']
            
            # Find nearby uncovered buildings
            candidates = []
            nearby = grid.get_nearby_buildings(cx, cy, antenna_range)
            
            for b in nearby:
                if b['id'] not in covered and is_in_range(cx, cy, b['x'], b['y'], antenna_range):
                    # Prioritize by demand and distance
                    dist = distance(cx, cy, b['x'], b['y'])
                    priority = building_demands[b['id']] / (dist + 1)
                    candidates.append((b['id'], priority))
            
            if not candidates:
                continue
            
            # Sort by priority
            candidates.sort(key=lambda x: x[1], reverse=True)
            
            # Greedy assignment
            assignment = []
            total_peak = total_off_peak = total_night = 0
            
            for bid, _ in candidates:
                b = building_by_id[bid]
                new_peak = total_peak + b['populationPeakHours']
                new_off_peak = total_off_peak + b['populationOffPeakHours']
                new_night = total_night + b['populationNight']
                
                if max(new_peak, new_off_peak, new_night) <= capacity:
                    assignment.append(bid)
                    total_peak = new_peak
                    total_off_peak = new_off_peak
                    total_night = new_night
            
            if assignment:
                antennas.append({
                    'type': antenna_type,
                    'x': cx,
                    'y': cy,
                    'buildings': assignment
                })
                covered.update(assignment)
                break
    
    return antennas


def iterative_improvement(antennas: List[dict], buildings: List[dict],
                         building_by_id: Dict[int, dict], building_demands: Dict[int, int],
                         grid: SpatialGrid, rng: random.Random, iterations: int = 3) -> List[dict]:
    """Iteratively improve antenna placement through reassignment."""
    
    for iteration in range(iterations):
        # Try to reassign buildings to better antennas
        improved = False
        
        for antenna_idx, antenna in enumerate(antennas):
            if not antenna['buildings']:
                continue
            
            # Try to move buildings to nearby antennas if beneficial
            spec = ANTENNA_TYPES[antenna['type']]
            current_capacity = spec['capacity']
            
            # Calculate current utilization
            total_peak = sum(building_by_id[bid]['populationPeakHours'] for bid in antenna['buildings'])
            total_off_peak = sum(building_by_id[bid]['populationOffPeakHours'] for bid in antenna['buildings'])
            total_night = sum(building_by_id[bid]['populationNight'] for bid in antenna['buildings'])
            current_load = max(total_peak, total_off_peak, total_night)
            
            # If underutilized, try to pull buildings from nearby antennas
            if current_load < current_capacity * 0.7:
                nearby = grid.get_nearby_buildings(antenna['x'], antenna['y'], spec['range'])
                
                for b in nearby:
                    bid = b['id']
                    if bid in antenna['buildings']:
                        continue
                    
                    # Find which antenna currently covers this building
                    source_idx = None
                    for idx, other in enumerate(antennas):
                        if bid in other['buildings']:
                            source_idx = idx
                            break
                    
                    if source_idx is None:
                        continue
                    
                    # Check if we can move this building
                    if is_in_range(antenna['x'], antenna['y'], b['x'], b['y'], spec['range']):
                        new_peak = total_peak + b['populationPeakHours']
                        new_off_peak = total_off_peak + b['populationOffPeakHours']
                        new_night = total_night + b['populationNight']
                        
                        if max(new_peak, new_off_peak, new_night) <= current_capacity:
                            # Check if source antenna can afford to lose this building
                            source_antenna = antennas[source_idx]
                            if len(source_antenna['buildings']) > 1:
                                # Calculate distance improvement
                                old_dist = distance(source_antenna['x'], source_antenna['y'], b['x'], b['y'])
                                new_dist = distance(antenna['x'], antenna['y'], b['x'], b['y'])
                                
                                if new_dist < old_dist * 0.8:  # Significant improvement
                                    source_antenna['buildings'].remove(bid)
                                    antenna['buildings'].append(bid)
                                    total_peak = new_peak
                                    total_off_peak = new_off_peak
                                    total_night = new_night
                                    improved = True
        
        if not improved:
            break
    
    return antennas


def optimize_antenna_types(antennas: List[dict], buildings: List[dict],
                           building_by_id: Dict[int, dict]) -> List[dict]:
    """Downgrade antenna types where possible to reduce cost."""
    
    for antenna in antennas:
        if not antenna['buildings']:
            continue
        
        # Calculate actual load
        total_peak = sum(building_by_id[bid]['populationPeakHours'] for bid in antenna['buildings'])
        total_off_peak = sum(building_by_id[bid]['populationOffPeakHours'] for bid in antenna['buildings'])
        total_night = sum(building_by_id[bid]['populationNight'] for bid in antenna['buildings'])
        max_load = max(total_peak, total_off_peak, total_night)
        
        # Try smaller antenna types
        for antenna_type in ANTENNA_TYPES_BY_CAPACITY:
            spec = ANTENNA_TYPES[antenna_type]
            
            # Check capacity
            if max_load > spec['capacity']:
                continue
            
            # Check range for all buildings
            all_in_range = True
            for bid in antenna['buildings']:
                b = building_by_id[bid]
                if not is_in_range(antenna['x'], antenna['y'], b['x'], b['y'], spec['range']):
                    all_in_range = False
                    break
            
            if all_in_range:
                antenna['type'] = antenna_type
                break
    
    return antennas


def ensure_full_coverage(antennas: List[dict], buildings: List[dict],
                        building_by_id: Dict[int, dict], building_demands: Dict[int, int]) -> List[dict]:
    """Ensure all buildings are covered, add antennas for any gaps."""
    
    covered = set()
    for antenna in antennas:
        covered.update(antenna['buildings'])
    
    all_building_ids = {b['id'] for b in buildings}
    uncovered = all_building_ids - covered
    
    # Remove empty antennas
    antennas = [a for a in antennas if a['buildings']]
    
    # Cover remaining buildings
    for bid in uncovered:
        b = building_by_id[bid]
        demand = building_demands[bid]
        
        # Choose smallest antenna that can handle this building
        for antenna_type in ANTENNA_TYPES_BY_CAPACITY:
            spec = ANTENNA_TYPES[antenna_type]
            if demand <= spec['capacity']:
                antennas.append({
                    'type': antenna_type,
                    'x': b['x'],
                    'y': b['y'],
                    'buildings': [bid]
                })
                break
    
    return antennas