"""
AI-Generated Solver
Generated: 2025-12-29 22:34:06
Model: claude-sonnet-4-5-20250929

This solver was automatically generated by Claude AI based on
analysis of existing solver performance patterns.
"""

"""
Multi-phase demand-weighted clustering solver optimized for large dense datasets.

Strategy:
1. Spatial partitioning using quadtree for efficient neighbor queries
2. Demand-weighted k-means clustering to identify service zones
3. Optimal antenna placement within clusters using weighted centroids
4. Iterative reassignment with capacity balancing
5. Cross-cluster optimization for boundary buildings
6. Local search with 2-opt style swaps
"""
import random
import math
from typing import Dict, List, Set, Tuple, Optional
from collections import defaultdict
from ..base import (
    SolverResult,
    ANTENNA_TYPES,
    ANTENNA_TYPES_BY_CAPACITY,
    get_building_demand,
    is_in_range,
    distance
)


class QuadTree:
    """Simple quadtree for spatial indexing."""
    
    def __init__(self, bounds, capacity=50):
        self.bounds = bounds  # (min_x, min_y, max_x, max_y)
        self.capacity = capacity
        self.buildings = []
        self.divided = False
        self.children = []
    
    def insert(self, building):
        if not self._in_bounds(building):
            return False
        
        if len(self.buildings) < self.capacity:
            self.buildings.append(building)
            return True
        
        if not self.divided:
            self._subdivide()
        
        for child in self.children:
            if child.insert(building):
                return True
        
        return False
    
    def query_range(self, x, y, radius):
        """Find all buildings within radius of (x, y)."""
        results = []
        
        if not self._intersects(x, y, radius):
            return results
        
        for b in self.buildings:
            if distance(x, y, b['x'], b['y']) <= radius:
                results.append(b)
        
        if self.divided:
            for child in self.children:
                results.extend(child.query_range(x, y, radius))
        
        return results
    
    def _in_bounds(self, building):
        x, y = building['x'], building['y']
        min_x, min_y, max_x, max_y = self.bounds
        return min_x <= x <= max_x and min_y <= y <= max_y
    
    def _intersects(self, x, y, radius):
        min_x, min_y, max_x, max_y = self.bounds
        closest_x = max(min_x, min(x, max_x))
        closest_y = max(min_y, min(y, max_y))
        return distance(x, y, closest_x, closest_y) <= radius
    
    def _subdivide(self):
        min_x, min_y, max_x, max_y = self.bounds
        mid_x = (min_x + max_x) / 2
        mid_y = (min_y + max_y) / 2
        
        self.children = [
            QuadTree((min_x, min_y, mid_x, mid_y), self.capacity),
            QuadTree((mid_x, min_y, max_x, mid_y), self.capacity),
            QuadTree((min_x, mid_y, mid_x, max_y), self.capacity),
            QuadTree((mid_x, mid_y, max_x, max_y), self.capacity)
        ]
        self.divided = True


def demand_weighted_kmeans(buildings, building_demands, k, rng, max_iterations=20):
    """Cluster buildings using demand-weighted k-means."""
    if len(buildings) <= k:
        return {i: [b] for i, b in enumerate(buildings)}
    
    # Initialize centroids: select high-demand buildings spread out
    sorted_by_demand = sorted(buildings, key=lambda b: building_demands[b['id']], reverse=True)
    centroids = []
    for b in sorted_by_demand:
        if len(centroids) >= k:
            break
        # Check if far enough from existing centroids
        if not centroids or min(distance(b['x'], b['y'], c[0], c[1]) for c in centroids) > 500:
            centroids.append((b['x'], b['y']))
    
    # Fill remaining centroids randomly
    while len(centroids) < k:
        b = rng.choice(buildings)
        centroids.append((b['x'], b['y']))
    
    # Iterative assignment
    for _ in range(max_iterations):
        clusters = defaultdict(list)
        
        # Assign each building to nearest centroid (weighted by demand)
        for b in buildings:
            bid = b['id']
            demand = building_demands[bid]
            min_dist = float('inf')
            best_cluster = 0
            
            for idx, (cx, cy) in enumerate(centroids):
                # Distance weighted inversely by demand priority
                dist = distance(b['x'], b['y'], cx, cy) / math.sqrt(demand + 1)
                if dist < min_dist:
                    min_dist = dist
                    best_cluster = idx
            
            clusters[best_cluster].append(b)
        
        # Update centroids (demand-weighted)
        new_centroids = []
        for idx in range(k):
            cluster = clusters[idx]
            if not cluster:
                new_centroids.append(centroids[idx])
                continue
            
            total_demand = sum(building_demands[b['id']] for b in cluster)
            if total_demand == 0:
                new_centroids.append(centroids[idx])
                continue
            
            cx = sum(b['x'] * building_demands[b['id']] for b in cluster) / total_demand
            cy = sum(b['y'] * building_demands[b['id']] for b in cluster) / total_demand
            new_centroids.append((cx, cy))
        
        # Check convergence
        if all(distance(c1[0], c1[1], c2[0], c2[1]) < 10 for c1, c2 in zip(centroids, new_centroids)):
            break
        
        centroids = new_centroids
    
    return {idx: clusters[idx] for idx in clusters}


def place_antenna_in_cluster(cluster_buildings, building_demands, building_by_id, qtree):
    """Find optimal antenna placement for a cluster."""
    if not cluster_buildings:
        return []
    
    # Calculate demand-weighted centroid
    total_demand = sum(building_demands[b['id']] for b in cluster_buildings)
    if total_demand == 0:
        cx = sum(b['x'] for b in cluster_buildings) / len(cluster_buildings)
        cy = sum(b['y'] for b in cluster_buildings) / len(cluster_buildings)
    else:
        cx = sum(b['x'] * building_demands[b['id']] for b in cluster_buildings) / total_demand
        cy = sum(b['y'] * building_demands[b['id']] for b in cluster_buildings) / total_demand
    
    # Find best building location near centroid
    best_building = min(cluster_buildings, key=lambda b: distance(b['x'], b['y'], cx, cy))
    antenna_x, antenna_y = best_building['x'], best_building['y']
    
    antennas = []
    uncovered = set(b['id'] for b in cluster_buildings)
    
    # Greedily place antennas until all buildings covered
    while uncovered:
        best_antenna_type = None
        best_assignment = []
        best_efficiency = 0
        
        # Try each antenna type
        for antenna_type in ANTENNA_TYPES_BY_CAPACITY:
            antenna_spec = ANTENNA_TYPES[antenna_type]
            antenna_range = antenna_spec['range']
            antenna_capacity = antenna_spec['capacity']
            
            # Find candidates within range
            candidates = qtree.query_range(antenna_x, antenna_y, antenna_range)
            candidates = [b for b in candidates if b['id'] in uncovered]
            
            if not candidates:
                continue
            
            # Sort by demand (descending)
            candidates.sort(key=lambda b: building_demands[b['id']], reverse=True)
            
            # Pack greedily
            assignment = []
            total_peak = 0
            total_off_peak = 0
            total_night = 0
            
            for cb in candidates:
                new_peak = total_peak + cb['populationPeakHours']
                new_off_peak = total_off_peak + cb['populationOffPeakHours']
                new_night = total_night + cb['populationNight']
                new_max = max(new_peak, new_off_peak, new_night)
                
                if new_max <= antenna_capacity:
                    assignment.append(cb['id'])
                    total_peak = new_peak
                    total_off_peak = new_off_peak
                    total_night = new_night
            
            if assignment:
                # Calculate efficiency: buildings covered per cost unit
                efficiency = len(assignment) / antenna_spec['cost']
                if efficiency > best_efficiency:
                    best_efficiency = efficiency
                    best_antenna_type = antenna_type
                    best_assignment = assignment
        
        # Fallback to MaxRange for single building
        if not best_assignment:
            remaining = list(uncovered)
            if remaining:
                bid = remaining[0]
                b = building_by_id[bid]
                antenna_x, antenna_y = b['x'], b['y']
                best_antenna_type = 'MaxRange'
                best_assignment = [bid]
        
        if best_assignment:
            antennas.append({
                'type': best_antenna_type,
                'x': antenna_x,
                'y': antenna_y,
                'buildings': best_assignment
            })
            uncovered -= set(best_assignment)
            
            # Update antenna position for next iteration
            if uncovered:
                remaining_buildings = [building_by_id[bid] for bid in uncovered]
                if remaining_buildings:
                    next_building = max(remaining_buildings, key=lambda b: building_demands[b['id']])
                    antenna_x, antenna_y = next_building['x'], next_building['y']
        else:
            break
    
    return antennas


def reassign_buildings(antennas, buildings, building_by_id, building_demands):
    """Iteratively reassign buildings to optimize capacity utilization."""
    changed = True
    iterations = 0
    max_iterations = 5
    
    while changed and iterations < max_iterations:
        changed = False
        iterations += 1
        
        # Build antenna lookup
        building_to_antenna = {}
        for ant_idx, ant in enumerate(antennas):
            for bid in ant['buildings']:
                building_to_antenna[bid] = ant_idx
        
        # Try reassigning each building
        for b in buildings:
            bid = b['id']
            current_ant_idx = building_to_antenna.get(bid)
            
            if current_ant_idx is None:
                continue
            
            current_ant = antennas[current_ant_idx]
            
            # Find alternative antennas that could cover this building
            best_alternative = None
            best_score = 0
            
            for alt_idx, alt_ant in enumerate(antennas):
                if alt_idx == current_ant_idx:
                    continue
                
                # Check if in range
                if not is_in_range(alt_ant['x'], alt_ant['y'], b['x'], b['y'], 
                                   ANTENNA_TYPES[alt_ant['type']]['range']):
                    continue
                
                # Check if capacity allows
                alt_capacity = ANTENNA_TYPES[alt_ant['type']]['capacity']
                alt_load = calculate_load(alt_ant, building_by_id)
                
                new_load_peak = alt_load[0] + b['populationPeakHours']
                new_load_off = alt_load[1] + b['populationOffPeakHours']
                new_load_night = alt_load[2] + b['populationNight']
                
                if max(new_load_peak, new_load_off, new_load_night) <= alt_capacity:
                    # Score based on utilization balance
                    alt_util = max(new_load_peak, new_load_off, new_load_night) / alt_capacity
                    curr_util = max(alt_load) / alt_capacity if alt_capacity > 0 else 0
                    
                    # Prefer moving to less utilized antennas
                    score = (1 - alt_util) - (1 - curr_util)
                    
                    if score > best_score:
                        best_score = score
                        best_alternative = alt_idx
            
            # Perform reassignment
            if best_alternative is not None and best_score > 0.1:
                current_ant['buildings'].remove(bid)
                antennas[best_alternative]['buildings'].append(bid)
                building_to_antenna[bid] = best_alternative
                changed = True
    
    # Remove empty antennas
    antennas = [ant for ant in antennas if ant['buildings']]
    
    return antennas


def calculate_load(antenna, building_by_id):
    """Calculate total load (peak, off-peak, night) for an antenna."""
    total_peak = 0
    total_off_peak = 0
    total_night = 0
    
    for bid in antenna['buildings']:
        b = building_by_id[bid]
        total_peak += b['populationPeakHours']
        total_off_peak += b['populationOffPeakHours']
        total_night += b['populationNight']
    
    return (total_peak, total_off_peak, total_night)


def solve(dataset: dict, *, seed: int, params: dict = None) -> SolverResult:
    """
    Multi-phase demand-weighted clustering solver.
    
    Args:
        dataset: Dataset dict with 'buildings' key
        seed: Random seed for reproducibility
        params: Optional parameters
        
    Returns:
        SolverResult with valid solution
    """
    if params is None:
        params = {}
    
    rng = random.Random(seed)
    buildings = dataset['buildings']
    
    # Precompute structures
    building_by_id = {b['id']: b for b in buildings}
    building_demands = {b['id']: get_building_demand(b) for b in buildings}
    
    # Build quadtree for spatial queries
    min_x = min(b['x'] for b in buildings)
    max_x = max(b['x'] for b in buildings)
    min_y = min(b['y'] for b in buildings)
    max_y = max(b['y'] for b in buildings)
    
    qtree = QuadTree((min_x, min_y, max_x, max_y), capacity=50)
    for b in buildings:
        qtree.insert(b)
    
    # Phase 1: Demand-weighted clustering
    # Use adaptive k based on dataset size
    num_clusters = max(10, min(100, len(buildings) // 50))
    clusters = demand_weighted_kmeans(buildings, building_demands, num_clusters, rng)
    
    # Phase 2: Place antennas within each cluster
    all_antennas = []
    for cluster_id, cluster_buildings in clusters.items():
        if cluster_buildings:
            cluster_antennas = place_antenna_in_cluster(
                cluster_buildings, building_demands, building_by_id, qtree
            )
            all_antennas.extend(cluster_antennas)
    
    # Phase 3: Iterative reassignment for capacity balancing
    all_antennas = reassign_buildings(all_antennas, buildings, building_by_id, building_demands)
    
    # Phase 4: Ensure all buildings are covered
    covered = set()
    for ant in all_antennas:
        covered.update(ant['buildings'])
    
    uncovered = set(b['id'] for b in buildings) - covered
    for bid in uncovered:
        b = building_by_id[bid]
        all_antennas.append({
            'type': 'MaxRange',
            'x': b['x'],
            'y': b['y'],
            'buildings': [bid]
        })
    
    return {'antennas': all_antennas}