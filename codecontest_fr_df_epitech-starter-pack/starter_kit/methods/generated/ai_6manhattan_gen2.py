"""
AI-Generated Solver
Generated: 2025-12-30 11:25:41
Model: claude-sonnet-4-5-20250929

This solver was automatically generated by Claude AI based on
analysis of existing solver performance patterns.
"""

"""
Advanced solver for dense, low-clustering urban environments (Manhattan-style).

Strategy:
1. Use spatial indexing (grid-based) for fast neighbor queries in dense environments
2. Implement demand-weighted initialization prioritizing high-demand areas
3. Apply adaptive antenna selection with capacity utilization awareness
4. Use multi-start parallel construction with seed variations
5. Post-optimization with 2-opt style local search for facility reassignment
6. Smart antenna type selection considering marginal cost-benefit
"""
import random
from typing import Dict, List, Set, Tuple, Optional
from collections import defaultdict
import math

from .base import (
    SolverResult,
    ANTENNA_TYPES,
    ANTENNA_TYPES_BY_CAPACITY,
    get_building_demand,
    is_in_range,
    distance
)


def solve(dataset: dict, *, seed: int, params: dict = None) -> SolverResult:
    """
    Advanced solver optimized for dense, low-clustering datasets.
    
    Args:
        dataset: Dataset dict with 'buildings' key
        seed: Random seed for reproducibility
        params: Optional parameters
    
    Returns:
        SolverResult with optimized solution
    """
    if params is None:
        params = {}
    
    buildings = dataset['buildings']
    rng = random.Random(seed)
    
    # Precompute building data
    building_by_id = {b['id']: b for b in buildings}
    building_demands = {b['id']: get_building_demand(b) for b in buildings}
    
    # Build spatial index for fast neighbor queries
    spatial_index = SpatialIndex(buildings)
    
    # Multi-start approach: try several constructions
    num_starts = 5
    best_solution = None
    best_cost = float('inf')
    
    for start_idx in range(num_starts):
        # Use seed variation for each start
        start_seed = seed + start_idx * 1000
        start_rng = random.Random(start_seed)
        
        # Construct solution with different strategies
        if start_idx == 0:
            # Demand-weighted greedy
            solution = construct_demand_weighted(
                buildings, building_by_id, building_demands, 
                spatial_index, start_rng
            )
        elif start_idx == 1:
            # Spatial sweep (grid-based)
            solution = construct_grid_sweep(
                buildings, building_by_id, building_demands,
                spatial_index, start_rng
            )
        else:
            # Randomized with capacity awareness
            solution = construct_capacity_aware(
                buildings, building_by_id, building_demands,
                spatial_index, start_rng, randomize=True
            )
        
        # Local optimization
        solution = local_optimize(
            solution, buildings, building_by_id, 
            building_demands, spatial_index, start_rng
        )
        
        # Evaluate cost
        cost = evaluate_cost(solution, building_by_id)
        
        if cost < best_cost:
            best_cost = cost
            best_solution = solution
    
    return {'antennas': best_solution}


class SpatialIndex:
    """Grid-based spatial index for fast neighbor queries."""
    
    def __init__(self, buildings: List[dict], grid_size: int = 500):
        self.grid_size = grid_size
        self.grid = defaultdict(list)
        
        # Find bounds
        self.min_x = min(b['x'] for b in buildings)
        self.min_y = min(b['y'] for b in buildings)
        self.max_x = max(b['x'] for b in buildings)
        self.max_y = max(b['y'] for b in buildings)
        
        # Index buildings
        for b in buildings:
            cell = self._get_cell(b['x'], b['y'])
            self.grid[cell].append(b)
    
    def _get_cell(self, x: int, y: int) -> Tuple[int, int]:
        """Get grid cell for coordinates."""
        cx = (x - self.min_x) // self.grid_size
        cy = (y - self.min_y) // self.grid_size
        return (cx, cy)
    
    def query_range(self, x: int, y: int, radius: int) -> List[dict]:
        """Get all buildings within radius of point."""
        # Calculate cell range
        cx, cy = self._get_cell(x, y)
        cell_radius = (radius // self.grid_size) + 1
        
        candidates = []
        for dx in range(-cell_radius, cell_radius + 1):
            for dy in range(-cell_radius, cell_radius + 1):
                cell = (cx + dx, cy + dy)
                candidates.extend(self.grid.get(cell, []))
        
        # Filter by actual distance
        result = []
        for b in candidates:
            if is_in_range(x, y, b['x'], b['y'], radius):
                result.append(b)
        
        return result


def construct_demand_weighted(
    buildings: List[dict],
    building_by_id: Dict[int, dict],
    building_demands: Dict[int, int],
    spatial_index: SpatialIndex,
    rng: random.Random
) -> List[dict]:
    """Construct solution prioritizing high-demand areas."""
    
    # Sort by demand
    sorted_buildings = sorted(
        buildings, 
        key=lambda b: building_demands[b['id']], 
        reverse=True
    )
    
    covered = set()
    antennas = []
    
    for building in sorted_buildings:
        if building['id'] in covered:
            continue
        
        # Try to place optimal antenna at this location
        antenna = place_optimal_antenna(
            building['x'], building['y'],
            buildings, building_by_id, building_demands,
            spatial_index, covered, rng
        )
        
        if antenna:
            antennas.append(antenna)
            covered.update(antenna['buildings'])
    
    # Ensure all covered
    antennas = ensure_coverage(antennas, buildings, building_by_id, covered)
    
    return antennas


def construct_grid_sweep(
    buildings: List[dict],
    building_by_id: Dict[int, dict],
    building_demands: Dict[int, int],
    spatial_index: SpatialIndex,
    rng: random.Random
) -> List[dict]:
    """Construct solution using spatial grid sweep."""
    
    # Create grid of potential antenna locations
    grid_size = 1000
    min_x = min(b['x'] for b in buildings)
    min_y = min(b['y'] for b in buildings)
    max_x = max(b['x'] for b in buildings)
    max_y = max(b['y'] for b in buildings)
    
    # Calculate grid points
    x_points = list(range(min_x, max_x + 1, grid_size))
    y_points = list(range(min_y, max_y + 1, grid_size))
    
    # Add building locations as candidates
    building_locs = set((b['x'], b['y']) for b in buildings)
    
    covered = set()
    antennas = []
    
    # Sweep through grid and building locations
    all_candidates = [(x, y) for x in x_points for y in y_points]
    all_candidates.extend(building_locs)
    
    # Sort by total nearby demand
    def nearby_demand(loc):
        x, y = loc
        nearby = spatial_index.query_range(x, y, 2000)
        return sum(building_demands[b['id']] for b in nearby if b['id'] not in covered)
    
    all_candidates.sort(key=nearby_demand, reverse=True)
    
    for x, y in all_candidates[:500]:  # Limit candidates
        if len(covered) == len(buildings):
            break
        
        # Try to place antenna here
        antenna = place_optimal_antenna(
            x, y, buildings, building_by_id, building_demands,
            spatial_index, covered, rng
        )
        
        if antenna and len(antenna['buildings']) > 0:
            antennas.append(antenna)
            covered.update(antenna['buildings'])
    
    # Ensure all covered
    antennas = ensure_coverage(antennas, buildings, building_by_id, covered)
    
    return antennas


def construct_capacity_aware(
    buildings: List[dict],
    building_by_id: Dict[int, dict],
    building_demands: Dict[int, int],
    spatial_index: SpatialIndex,
    rng: random.Random,
    randomize: bool = False
) -> List[dict]:
    """Construct solution with capacity utilization awareness."""
    
    building_list = buildings.copy()
    if randomize:
        rng.shuffle(building_list)
    else:
        building_list.sort(key=lambda b: building_demands[b['id']], reverse=True)
    
    covered = set()
    antennas = []
    
    for building in building_list:
        if building['id'] in covered:
            continue
        
        antenna = place_capacity_optimal_antenna(
            building['x'], building['y'],
            buildings, building_by_id, building_demands,
            spatial_index, covered, rng
        )
        
        if antenna:
            antennas.append(antenna)
            covered.update(antenna['buildings'])
    
    antennas = ensure_coverage(antennas, buildings, building_by_id, covered)
    
    return antennas


def place_optimal_antenna(
    x: int, y: int,
    buildings: List[dict],
    building_by_id: Dict[int, dict],
    building_demands: Dict[int, int],
    spatial_index: SpatialIndex,
    covered: Set[int],
    rng: random.Random
) -> Optional[dict]:
    """Place best antenna at location considering cost-benefit."""
    
    best_antenna = None
    best_score = -float('inf')
    
    for antenna_type in ANTENNA_TYPES_BY_CAPACITY:
        spec = ANTENNA_TYPES[antenna_type]
        antenna_range = spec['range']
        capacity = spec['capacity']
        cost = spec['cost']
        
        # Check if on building for discount
        on_building = any(b['x'] == x and b['y'] == y for b in buildings)
        actual_cost = cost // 2 if on_building else cost
        
        # Find candidates in range
        candidates = spatial_index.query_range(x, y, antenna_range)
        candidates = [b for b in candidates if b['id'] not in covered]
        
        if not candidates:
            continue
        
        # Sort by demand
        candidates.sort(key=lambda b: building_demands[b['id']], reverse=True)
        
        # Pack buildings
        assignment = []
        total_peak = 0
        total_off_peak = 0
        total_night = 0
        
        for b in candidates:
            new_peak = total_peak + b['populationPeakHours']
            new_off_peak = total_off_peak + b['populationOffPeakHours']
            new_night = total_night + b['populationNight']
            new_max = max(new_peak, new_off_peak, new_night)
            
            if new_max <= capacity:
                assignment.append(b['id'])
                total_peak = new_peak
                total_off_peak = new_off_peak
                total_night = new_night
        
        if assignment:
            # Score: buildings covered per unit cost
            score = len(assignment) / actual_cost
            
            if score > best_score:
                best_score = score
                best_antenna = {
                    'type': antenna_type,
                    'x': x,
                    'y': y,
                    'buildings': assignment
                }
    
    return best_antenna


def place_capacity_optimal_antenna(
    x: int, y: int,
    buildings: List[dict],
    building_by_id: Dict[int, dict],
    building_demands: Dict[int, int],
    spatial_index: SpatialIndex,
    covered: Set[int],
    rng: random.Random
) -> Optional[dict]:
    """Place antenna optimizing capacity utilization."""
    
    for antenna_type in ANTENNA_TYPES_BY_CAPACITY:
        spec = ANTENNA_TYPES[antenna_type]
        antenna_range = spec['range']
        capacity = spec['capacity']
        
        candidates = spatial_index.query_range(x, y, antenna_range)
        candidates = [b for b in candidates if b['id'] not in covered]
        
        if not candidates:
            continue
        
        candidates.sort(key=lambda b: building_demands[b['id']], reverse=True)
        
        assignment = []
        total_peak = 0
        total_off_peak = 0
        total_night = 0
        
        for b in candidates:
            new_peak = total_peak + b['populationPeakHours']
            new_off_peak = total_off_peak + b['populationOffPeakHours']
            new_night = total_night + b['populationNight']
            new_max = max(new_peak, new_off_peak, new_night)
            
            if new_max <= capacity:
                assignment.append(b['id'])
                total_peak = new_peak
                total_off_peak = new_off_peak
                total_night = new_night
        
        # Accept if utilization is reasonable
        if assignment:
            utilization = max(total_peak, total_off_peak, total_night) / capacity
            if utilization > 0.3:  # At least 30% utilization
                return {
                    'type': antenna_type,
                    'x': x,
                    'y': y,
                    'buildings': assignment
                }
    
    return None


def local_optimize(
    antennas: List[dict],
    buildings: List[dict],
    building_by_id: Dict[int, dict],
    building_demands: Dict[int, int],
    spatial_index: SpatialIndex,
    rng: random.Random,
    iterations: int = 100
) -> List[dict]:
    """Apply local search optimization."""
    
    current = antennas
    current_cost = evaluate_cost(current, building_by_id)
    
    for _ in range(iterations):
        # Try reassignment moves
        improved = False
        
        # Try to merge small antennas
        for i in range(len(current)):
            if len(current[i]['buildings']) <= 3:
                # Try to redistribute buildings to neighbors
                candidate = try_redistribute_antenna(
                    current, i, buildings, building_by_id, spatial_index
                )
                
                if candidate:
                    new_cost = evaluate_cost(candidate, building_by_id)
                    if new_cost < current_cost:
                        current = candidate
                        current_cost = new_cost
                        improved = True
                        break
        
        if not improved:
            # Try antenna type downgrades
            for i in range(len(current)):
                candidate = try_downgrade_antenna(
                    current, i, buildings, building_by_id
                )
                
                if candidate:
                    new_cost = evaluate_cost(candidate, building_by_id)
                    if new_cost < current_cost:
                        current = candidate
                        current_cost = new_cost
                        improved = True
                        break
        
        if not improved:
            break
    
    return current


def try_redistribute_antenna(
    antennas: List[dict],
    idx: int,
    buildings: List[dict],
    building_by_id: Dict[int, dict],
    spatial_index: SpatialIndex
) -> Optional[List[dict]]:
    """Try to remove antenna by redistributing its buildings."""
    
    antenna = antennas[idx]
    buildings_to_reassign = antenna['buildings']
    
    # Try to assign to nearby antennas
    new_antennas = [a for i, a in enumerate(antennas) if i != idx]
    
    for bid in buildings_to_reassign:
        b = building_by_id[bid]
        assigned = False
        
        for other in new_antennas:
            spec = ANTENNA_TYPES[other['type']]
            if is_in_range(other['x'], other['y'], b['x'], b['y'], spec['range']):
                # Check capacity
                if can_add_building(other, b, building_by_id, spec['capacity']):
                    other['buildings'].append(bid)
                    assigned = True
                    break
        
        if not assigned:
            return None
    
    return new_antennas


def try_downgrade_antenna(
    antennas: List[dict],
    idx: int,
    buildings: List[dict],
    building_by_id: Dict[int, dict]
) -> Optional[List[dict]]:
    """Try to downgrade antenna to smaller type."""
    
    antenna = antennas[idx]
    current_type = antenna['type']
    current_idx = ANTENNA_TYPES_BY_CAPACITY.index(current_type)
    
    if current_idx == 0:
        return None
    
    # Try smaller types
    for new_type in ANTENNA_TYPES_BY_CAPACITY[:current_idx]:
        spec = ANTENNA_TYPES[new_type]
        
        # Check if all buildings still in range and under capacity
        valid = True
        total_peak = 0
        total_off_peak = 0
        total_night = 0
        
        for bid in antenna['buildings']:
            b = building_by_id[bid]
            if not is_in_range(antenna['x'], antenna['y'], b['x'], b['y'], spec['range']):
                valid = False
                break
            
            total_peak += b['populationPeakHours']
            total_off_peak += b['populationOffPeakHours']
            total_night += b['populationNight']
        
        if valid and max(total_peak, total_off_peak, total_night) <= spec['capacity']:
            new_antennas = antennas.copy()
            new_antennas[idx] = {
                'type': new_type,
                'x': antenna['x'],
                'y': antenna['y'],
                'buildings': antenna['buildings'].copy()
            }
            return new_antennas
    
    return None


def can_add_building(antenna: dict, building: dict, building_by_id: Dict[int, dict], capacity: int) -> bool:
    """Check if building can be added to antenna."""
    total_peak = building['populationPeakHours']
    total_off_peak = building['populationOffPeakHours']
    total_night = building['populationNight']
    
    for bid in antenna['buildings']:
        b = building_by_id[bid]
        total_peak += b['populationPeakHours']
        total_off_peak += b['populationOffPeakHours']
        total_night += b['populationNight']
    
    return max(total_peak, total_off_peak, total_night) <= capacity


def ensure_coverage(
    antennas: List[dict],
    buildings: List[dict],
    building_by_id: Dict[int, dict],
    covered: Set[int]
) -> List[dict]:
    """Ensure all buildings are covered."""
    all_building_ids = {b['id'] for b in buildings}
    uncovered = all_building_ids - covered
    
    for bid in uncovered:
        b = building_by_id[bid]
        antennas.append({
            'type': 'MaxRange',
            'x': b['x'],
            'y': b['y'],
            'buildings': [bid]
        })
    
    return antennas


def evaluate_cost(antennas: List[dict], building_by_id: Dict[int, dict]) -> int:
    """Calculate total cost of solution."""
    total = 0
    
    for antenna in antennas:
        spec = ANTENNA_TYPES[antenna['type']]
        cost = spec['cost']
        
        # Check if on building
        on_building = any(
            bid in building_by_id and 
            building_by_id[bid]['x'] == antenna['x'] and 
            building_by_id[bid]['y'] == antenna['y']
            for bid in antenna['buildings']
        )
        
        if on_building:
            cost = cost // 2
        
        total += cost
    
    return total