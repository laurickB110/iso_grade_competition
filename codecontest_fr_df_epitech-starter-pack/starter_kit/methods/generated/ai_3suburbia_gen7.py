"""
AI-Generated Solver
Generated: 2025-12-29 22:33:16
Model: claude-sonnet-4-5-20250929

This solver was automatically generated by Claude AI based on
analysis of existing solver performance patterns.
"""

"""
Multi-phase hierarchical clustering solver optimized for suburbia datasets.

Strategy for 3_suburbia (2601 buildings, low clustering, moderate distribution):
1. Spatial partitioning using grid-based clustering to identify service zones
2. Demand-weighted placement within each zone using k-center approach
3. Greedy assignment with capacity balancing to minimize antenna count
4. Local optimization pass with building reassignment and antenna type downgrading
5. Boundary optimization to handle cross-zone coverage opportunities
"""
import random
import math
from typing import Dict, List, Set, Tuple, Optional
from collections import defaultdict
from ..base import (
    SolverResult,
    ANTENNA_TYPES,
    ANTENNA_TYPES_BY_CAPACITY,
    get_building_demand,
    is_in_range,
    distance
)


def solve(dataset: dict, *, seed: int, params: dict = None) -> SolverResult:
    """
    Hierarchical clustering solver with demand-aware placement.
    
    Args:
        dataset: Dataset dict with 'buildings' key
        seed: Random seed for reproducibility
        params: Optional parameters
        
    Returns:
        SolverResult with optimized solution
    """
    if params is None:
        params = {}
    
    rng = random.Random(seed)
    buildings = dataset['buildings']
    
    # Phase 1: Precompute building data
    building_by_id = {b['id']: b for b in buildings}
    building_demands = {b['id']: get_building_demand(b) for b in buildings}
    
    # Phase 2: Spatial partitioning with adaptive grid
    grid_size = int(math.sqrt(len(buildings)) / 3)  # Adaptive grid for suburbia
    zones = partition_into_zones(buildings, grid_size)
    
    # Phase 3: Initial antenna placement using demand-weighted k-center
    antennas = []
    covered = set()
    
    for zone_buildings in zones:
        if not zone_buildings:
            continue
        
        zone_antennas = place_antennas_in_zone(
            zone_buildings, 
            building_by_id, 
            building_demands,
            covered,
            rng
        )
        antennas.extend(zone_antennas)
    
    # Phase 4: Cover any remaining buildings (edge case handling)
    all_building_ids = {b['id'] for b in buildings}
    uncovered = all_building_ids - covered
    
    if uncovered:
        for bid in uncovered:
            b = building_by_id[bid]
            antennas.append({
                'type': 'MaxRange',
                'x': b['x'],
                'y': b['y'],
                'buildings': [bid]
            })
            covered.add(bid)
    
    # Phase 5: Local optimization - reassignment and type downgrading
    antennas = optimize_assignments(antennas, buildings, building_by_id, building_demands, rng)
    
    # Phase 6: Antenna consolidation - try to merge nearby antennas
    antennas = consolidate_antennas(antennas, buildings, building_by_id, building_demands)
    
    # Phase 7: Final pass - downgrade antenna types where possible
    antennas = downgrade_antenna_types(antennas, building_by_id)
    
    return {'antennas': antennas}


def partition_into_zones(buildings: List[dict], grid_size: int) -> List[List[dict]]:
    """Partition buildings into spatial zones using adaptive grid."""
    if not buildings:
        return []
    
    # Find spatial bounds
    min_x = min(b['x'] for b in buildings)
    max_x = max(b['x'] for b in buildings)
    min_y = min(b['y'] for b in buildings)
    max_y = max(b['y'] for b in buildings)
    
    # Calculate cell dimensions
    width = (max_x - min_x) / grid_size if grid_size > 0 else 1
    height = (max_y - min_y) / grid_size if grid_size > 0 else 1
    
    # Avoid division by zero
    if width == 0:
        width = 1
    if height == 0:
        height = 1
    
    # Assign buildings to grid cells
    grid = defaultdict(list)
    for b in buildings:
        cell_x = int((b['x'] - min_x) / width)
        cell_y = int((b['y'] - min_y) / height)
        # Clamp to grid boundaries
        cell_x = min(cell_x, grid_size - 1) if grid_size > 0 else 0
        cell_y = min(cell_y, grid_size - 1) if grid_size > 0 else 0
        grid[(cell_x, cell_y)].append(b)
    
    return list(grid.values())


def place_antennas_in_zone(zone_buildings: List[dict], building_by_id: Dict[int, dict],
                           building_demands: Dict[int, int], covered: Set[int],
                           rng: random.Random) -> List[dict]:
    """Place antennas in a zone using demand-weighted k-center approach."""
    antennas = []
    zone_covered = set()
    
    # Sort by demand (descending) for greedy placement
    sorted_zone = sorted(zone_buildings, key=lambda b: building_demands[b['id']], reverse=True)
    
    for building in sorted_zone:
        bid = building['id']
        
        if bid in covered or bid in zone_covered:
            continue
        
        # Find best antenna placement considering demand density
        best_placement = find_best_placement(
            building, zone_buildings, building_by_id, building_demands, 
            covered | zone_covered, rng
        )
        
        if best_placement:
            antennas.append(best_placement)
            zone_covered.update(best_placement['buildings'])
    
    # Update global covered set
    covered.update(zone_covered)
    
    return antennas


def find_best_placement(anchor: dict, candidates: List[dict], building_by_id: Dict[int, dict],
                       building_demands: Dict[int, int], covered: Set[int],
                       rng: random.Random) -> Optional[dict]:
    """Find best antenna placement for anchor building considering nearby demand."""
    anchor_id = anchor['id']
    
    if anchor_id in covered:
        return None
    
    # Try different antenna types from smallest to largest
    for antenna_type in ANTENNA_TYPES_BY_CAPACITY:
        antenna_spec = ANTENNA_TYPES[antenna_type]
        antenna_range = antenna_spec['range']
        antenna_capacity = antenna_spec['capacity']
        
        # Calculate demand-weighted center for antenna placement
        placement_x, placement_y = calculate_demand_weighted_center(
            anchor, candidates, building_demands, covered, antenna_range
        )
        
        # Find buildings within range of this placement
        reachable = []
        for other in candidates:
            other_id = other['id']
            if other_id not in covered:
                if is_in_range(placement_x, placement_y, other['x'], other['y'], antenna_range):
                    # Priority: demand + inverse distance
                    dist = distance(placement_x, placement_y, other['x'], other['y'])
                    priority = building_demands[other_id] / (dist + 1)
                    reachable.append((other_id, priority))
        
        # Sort by priority
        reachable.sort(key=lambda x: x[1], reverse=True)
        
        # Greedy packing with capacity constraints
        assignment = []
        total_peak = 0
        total_off_peak = 0
        total_night = 0
        
        for bid, _ in reachable:
            b = building_by_id[bid]
            
            new_peak = total_peak + b['populationPeakHours']
            new_off_peak = total_off_peak + b['populationOffPeakHours']
            new_night = total_night + b['populationNight']
            new_max = max(new_peak, new_off_peak, new_night)
            
            if new_max <= antenna_capacity:
                assignment.append(bid)
                total_peak = new_peak
                total_off_peak = new_off_peak
                total_night = new_night
        
        # Check if anchor is covered
        if anchor_id in assignment and len(assignment) > 0:
            return {
                'type': antenna_type,
                'x': placement_x,
                'y': placement_y,
                'buildings': assignment
            }
    
    # Fallback: MaxRange at anchor location
    return {
        'type': 'MaxRange',
        'x': anchor['x'],
        'y': anchor['y'],
        'buildings': [anchor_id]
    }


def calculate_demand_weighted_center(anchor: dict, candidates: List[dict],
                                     building_demands: Dict[int, int], covered: Set[int],
                                     max_range: int) -> Tuple[int, int]:
    """Calculate demand-weighted center for antenna placement."""
    # Start with anchor
    total_demand = 0
    weighted_x = 0
    weighted_y = 0
    
    # Find nearby high-demand buildings
    for b in candidates:
        bid = b['id']
        if bid in covered:
            continue
        
        dist = distance(anchor['x'], anchor['y'], b['x'], b['y'])
        if dist <= max_range * 0.8:  # Consider buildings within 80% of range
            demand = building_demands[bid]
            total_demand += demand
            weighted_x += b['x'] * demand
            weighted_y += b['y'] * demand
    
    if total_demand > 0:
        return (int(weighted_x / total_demand), int(weighted_y / total_demand))
    else:
        return (anchor['x'], anchor['y'])


def optimize_assignments(antennas: List[dict], buildings: List[dict],
                        building_by_id: Dict[int, dict], building_demands: Dict[int, int],
                        rng: random.Random) -> List[dict]:
    """Optimize building assignments using local search."""
    improved = True
    iterations = 0
    max_iterations = 3
    
    while improved and iterations < max_iterations:
        improved = False
        iterations += 1
        
        # Try to reassign buildings from overloaded to underutilized antennas
        for i, antenna in enumerate(antennas):
            antenna_spec = ANTENNA_TYPES[antenna['type']]
            
            # Calculate current utilization
            current_load = calculate_antenna_load(antenna, building_by_id)
            
            # If underutilized, try to pull buildings from nearby antennas
            if current_load < antenna_spec['capacity'] * 0.7:
                for j, other_antenna in enumerate(antennas):
                    if i == j:
                        continue
                    
                    # Try to move buildings from other to this antenna
                    moved = try_move_buildings(
                        antenna, other_antenna, building_by_id, antenna_spec['capacity']
                    )
                    if moved:
                        improved = True
    
    return antennas


def calculate_antenna_load(antenna: dict, building_by_id: Dict[int, dict]) -> int:
    """Calculate maximum load across all time periods."""
    total_peak = 0
    total_off_peak = 0
    total_night = 0
    
    for bid in antenna['buildings']:
        b = building_by_id[bid]
        total_peak += b['populationPeakHours']
        total_off_peak += b['populationOffPeakHours']
        total_night += b['populationNight']
    
    return max(total_peak, total_off_peak, total_night)


def try_move_buildings(target_antenna: dict, source_antenna: dict,
                      building_by_id: Dict[int, dict], target_capacity: int) -> bool:
    """Try to move buildings from source to target antenna."""
    target_spec = ANTENNA_TYPES[target_antenna['type']]
    target_range = target_spec['range']
    
    moved = False
    buildings_to_move = []
    
    for bid in source_antenna['buildings'][:]:
        b = building_by_id[bid]
        
        # Check if building is in range of target
        if is_in_range(target_antenna['x'], target_antenna['y'], b['x'], b['y'], target_range):
            # Check if target has capacity
            current_load = calculate_antenna_load(target_antenna, building_by_id)
            building_demand_peak = b['populationPeakHours']
            building_demand_off = b['populationOffPeakHours']
            building_demand_night = b['populationNight']
            
            if current_load + max(building_demand_peak, building_demand_off, building_demand_night) <= target_capacity:
                buildings_to_move.append(bid)
                moved = True
    
    # Perform the move
    for bid in buildings_to_move:
        source_antenna['buildings'].remove(bid)
        target_antenna['buildings'].append(bid)
    
    return moved


def consolidate_antennas(antennas: List[dict], buildings: List[dict],
                        building_by_id: Dict[int, dict], building_demands: Dict[int, int]) -> List[dict]:
    """Try to consolidate nearby antennas to reduce total count."""
    consolidated = []
    used = set()
    
    for i, antenna in enumerate(antennas):
        if i in used:
            continue
        
        # Try to merge with nearby antennas
        merged = False
        for j, other in enumerate(antennas):
            if i >= j or j in used:
                continue
            
            # Check if antennas are close
            dist = distance(antenna['x'], antenna['y'], other['x'], other['y'])
            
            if dist < 500:  # Threshold for consolidation
                # Try to merge into single antenna
                merged_antenna = try_merge_antennas(antenna, other, building_by_id)
                if merged_antenna:
                    consolidated.append(merged_antenna)
                    used.add(i)
                    used.add(j)
                    merged = True
                    break
        
        if not merged:
            consolidated.append(antenna)
            used.add(i)
    
    return consolidated


def try_merge_antennas(antenna1: dict, antenna2: dict, building_by_id: Dict[int, dict]) -> Optional[dict]:
    """Try to merge two antennas into one."""
    combined_buildings = antenna1['buildings'] + antenna2['buildings']
    
    # Calculate center point
    center_x = (antenna1['x'] + antenna2['x']) // 2
    center_y = (antenna1['y'] + antenna2['y']) // 2
    
    # Try each antenna type
    for antenna_type in reversed(ANTENNA_TYPES_BY_CAPACITY):  # Start with largest
        antenna_spec = ANTENNA_TYPES[antenna_type]
        
        # Check if all buildings are in range
        all_in_range = all(
            is_in_range(center_x, center_y, building_by_id[bid]['x'], 
                       building_by_id[bid]['y'], antenna_spec['range'])
            for bid in combined_buildings
        )
        
        if not all_in_range:
            continue
        
        # Check capacity
        total_peak = sum(building_by_id[bid]['populationPeakHours'] for bid in combined_buildings)
        total_off = sum(building_by_id[bid]['populationOffPeakHours'] for bid in combined_buildings)
        total_night = sum(building_by_id[bid]['populationNight'] for bid in combined_buildings)
        max_load = max(total_peak, total_off, total_night)
        
        if max_load <= antenna_spec['capacity']:
            return {
                'type': antenna_type,
                'x': center_x,
                'y': center_y,
                'buildings': combined_buildings
            }
    
    return None


def downgrade_antenna_types(antennas: List[dict], building_by_id: Dict[int, dict]) -> List[dict]:
    """Try to downgrade antenna types to cheaper options."""
    optimized = []
    
    for antenna in antennas:
        current_type = antenna['type']
        buildings_list = antenna['buildings']
        
        if not buildings_list:
            continue
        
        # Calculate required capacity
        total_peak = sum(building_by_id[bid]['populationPeakHours'] for bid in buildings_list)
        total_off = sum(building_by_id[bid]['populationOffPeakHours'] for bid in buildings_list)
        total_night = sum(building_by_id[bid]['populationNight'] for bid in buildings_list)
        required_capacity = max(total_peak, total_off, total_night)
        
        # Try smaller antenna types
        best_type = current_type
        for antenna_type in ANTENNA_TYPES_BY_CAPACITY:
            antenna_spec = ANTENNA_TYPES[antenna_type]
            
            # Check capacity
            if required_capacity > antenna_spec['capacity']:
                continue
            
            # Check range
            all_in_range = all(
                is_in_range(antenna['x'], antenna['y'], 
                           building_by_id[bid]['x'], building_by_id[bid]['y'],
                           antenna_spec['range'])
                for bid in buildings_list
            )
            
            if all_in_range:
                best_type = antenna_type
                break
        
        optimized.append({
            'type': best_type,
            'x': antenna['x'],
            'y': antenna['y'],
            'buildings': buildings_list
        })
    
    return optimized