"""
AI-Generated Solver
Generated: 2025-12-29 22:27:05
Model: claude-sonnet-4-5-20250929

This solver was automatically generated by Claude AI based on
analysis of existing solver performance patterns.
"""

"""
Hierarchical clustering solver optimized for dense, large-scale datasets (4_epitech).

Strategy:
1. Spatial grid decomposition to handle 5000 buildings efficiently
2. K-means clustering to identify demand hotspots despite "low clustering" label
3. Multi-start construction with different cluster seeds
4. Demand-weighted centroid placement for antenna positioning
5. Iterative refinement with ruin-and-recreate for dense local optima
6. Adaptive antenna type selection based on local density and demand variance
"""
import random
import math
from typing import Dict, List, Set, Tuple, Optional
from collections import defaultdict
from ..base import (
    SolverResult,
    ANTENNA_TYPES,
    ANTENNA_TYPES_BY_CAPACITY,
    get_building_demand,
    is_in_range,
    distance
)


def solve(dataset: dict, *, seed: int, params: dict = None) -> SolverResult:
    """
    Hierarchical clustering solver specialized for dense, large datasets.
    
    Args:
        dataset: Dataset dict with 'buildings' key
        seed: Random seed for reproducibility
        params: Optional parameters
        
    Returns:
        SolverResult with optimized solution
    """
    if params is None:
        params = {}
    
    rng = random.Random(seed)
    buildings = dataset['buildings']
    
    # Precompute building data
    building_by_id = {b['id']: b for b in buildings}
    building_demands = {b['id']: get_building_demand(b) for b in buildings}
    
    # Multi-start approach: try multiple strategies
    num_starts = 3
    best_solution = None
    best_cost = float('inf')
    
    for start_idx in range(num_starts):
        start_seed = seed + start_idx * 1000
        
        if start_idx == 0:
            # Strategy 1: K-means clustering
            solution = kmeans_based_solution(buildings, building_by_id, building_demands, 
                                            random.Random(start_seed))
        elif start_idx == 1:
            # Strategy 2: Grid-based spatial decomposition
            solution = grid_based_solution(buildings, building_by_id, building_demands,
                                          random.Random(start_seed))
        else:
            # Strategy 3: Demand-weighted greedy
            solution = demand_weighted_solution(buildings, building_by_id, building_demands,
                                               random.Random(start_seed))
        
        # Refine solution with local search
        solution = local_search_refinement(solution, buildings, building_by_id, 
                                          building_demands, random.Random(start_seed))
        
        # Calculate cost
        cost = calculate_cost(solution, building_by_id)
        
        if cost < best_cost:
            best_cost = cost
            best_solution = solution
    
    # Final ruin-and-recreate pass
    best_solution = ruin_and_recreate(best_solution, buildings, building_by_id,
                                      building_demands, rng, iterations=5)
    
    return {'antennas': best_solution}


def kmeans_based_solution(buildings: List[dict], building_by_id: Dict[int, dict],
                          building_demands: Dict[int, int], rng: random.Random) -> List[dict]:
    """Create solution using k-means clustering to identify antenna placement zones."""
    
    # Determine number of clusters based on dataset size and average demand
    avg_demand = sum(building_demands.values()) / len(buildings)
    # Target ~15-25 buildings per antenna for dense datasets
    target_cluster_size = 20
    num_clusters = max(10, len(buildings) // target_cluster_size)
    
    # K-means clustering
    clusters = kmeans_clustering(buildings, num_clusters, rng)
    
    antennas = []
    covered = set()
    
    # Process each cluster
    for cluster_buildings in clusters:
        if not cluster_buildings:
            continue
        
        # Find demand-weighted centroid
        total_weight = 0
        weighted_x = 0
        weighted_y = 0
        
        for bid in cluster_buildings:
            b = building_by_id[bid]
            weight = building_demands[bid]
            weighted_x += b['x'] * weight
            weighted_y += b['y'] * weight
            total_weight += weight
        
        if total_weight == 0:
            continue
        
        centroid_x = int(weighted_x / total_weight)
        centroid_y = int(weighted_y / total_weight)
        
        # Find nearest building to centroid for placement discount
        nearest_building = None
        nearest_dist = float('inf')
        
        for bid in cluster_buildings:
            b = building_by_id[bid]
            dist = distance(centroid_x, centroid_y, b['x'], b['y'])
            if dist < nearest_dist:
                nearest_dist = dist
                nearest_building = b
        
        if nearest_building is None:
            continue
        
        antenna_x, antenna_y = nearest_building['x'], nearest_building['y']
        
        # Determine best antenna type for this cluster
        uncovered_in_cluster = [bid for bid in cluster_buildings if bid not in covered]
        
        antenna = create_antenna_for_buildings(antenna_x, antenna_y, uncovered_in_cluster,
                                               buildings, building_by_id, building_demands)
        
        if antenna:
            antennas.append(antenna)
            covered.update(antenna['buildings'])
    
    # Cover any remaining buildings
    all_ids = {b['id'] for b in buildings}
    uncovered = all_ids - covered
    
    for bid in uncovered:
        b = building_by_id[bid]
        antenna = create_antenna_for_buildings(b['x'], b['y'], [bid],
                                               buildings, building_by_id, building_demands)
        if antenna:
            antennas.append(antenna)
            covered.add(bid)
    
    return antennas


def grid_based_solution(buildings: List[dict], building_by_id: Dict[int, dict],
                       building_demands: Dict[int, int], rng: random.Random) -> List[dict]:
    """Create solution using spatial grid decomposition."""
    
    # Find spatial bounds
    min_x = min(b['x'] for b in buildings)
    max_x = max(b['x'] for b in buildings)
    min_y = min(b['y'] for b in buildings)
    max_y = max(b['y'] for b in buildings)
    
    # Create grid cells - aim for ~50-100 buildings per cell
    grid_size = int(math.sqrt(len(buildings) / 75))
    grid_size = max(5, min(20, grid_size))
    
    cell_width = (max_x - min_x) / grid_size
    cell_height = (max_y - min_y) / grid_size
    
    # Assign buildings to grid cells
    grid_cells = defaultdict(list)
    
    for b in buildings:
        cell_x = int((b['x'] - min_x) / cell_width) if cell_width > 0 else 0
        cell_y = int((b['y'] - min_y) / cell_height) if cell_height > 0 else 0
        cell_x = min(cell_x, grid_size - 1)
        cell_y = min(cell_y, grid_size - 1)
        grid_cells[(cell_x, cell_y)].append(b['id'])
    
    antennas = []
    covered = set()
    
    # Process each grid cell
    for (cell_x, cell_y), cell_buildings in grid_cells.items():
        if not cell_buildings:
            continue
        
        # Sort buildings in cell by demand
        cell_buildings.sort(key=lambda bid: building_demands[bid], reverse=True)
        
        for bid in cell_buildings:
            if bid in covered:
                continue
            
            b = building_by_id[bid]
            
            # Find nearby uncovered buildings
            nearby = find_nearby_uncovered(b['x'], b['y'], buildings, covered, 
                                          building_by_id, max_range=2000)
            
            antenna = create_antenna_for_buildings(b['x'], b['y'], nearby,
                                                   buildings, building_by_id, building_demands)
            
            if antenna:
                antennas.append(antenna)
                covered.update(antenna['buildings'])
    
    # Cover remaining
    all_ids = {b['id'] for b in buildings}
    uncovered = all_ids - covered
    
    for bid in uncovered:
        b = building_by_id[bid]
        antenna = create_antenna_for_buildings(b['x'], b['y'], [bid],
                                               buildings, building_by_id, building_demands)
        if antenna:
            antennas.append(antenna)
            covered.add(bid)
    
    return antennas


def demand_weighted_solution(buildings: List[dict], building_by_id: Dict[int, dict],
                             building_demands: Dict[int, int], rng: random.Random) -> List[dict]:
    """Greedy solution with demand-weighted building selection."""
    
    # Calculate demand variance for adaptive strategy
    demands = list(building_demands.values())
    avg_demand = sum(demands) / len(demands)
    variance = sum((d - avg_demand) ** 2 for d in demands) / len(demands)
    
    # High variance: prioritize high-demand buildings more aggressively
    if variance > avg_demand * 0.5:
        # Sort with strong preference for high demand
        sorted_buildings = sorted(buildings, 
                                 key=lambda b: building_demands[b['id']] + rng.uniform(0, 50),
                                 reverse=True)
    else:
        # Lower variance: add more randomization
        sorted_buildings = sorted(buildings,
                                 key=lambda b: building_demands[b['id']] + rng.uniform(0, 200),
                                 reverse=True)
    
    covered = set()
    antennas = []
    
    for building in sorted_buildings:
        bid = building['id']
        
        if bid in covered:
            continue
        
        # Find nearby uncovered buildings with adaptive range
        nearby = find_nearby_uncovered(building['x'], building['y'], buildings, covered,
                                      building_by_id, max_range=1800)
        
        antenna = create_antenna_for_buildings(building['x'], building['y'], nearby,
                                               buildings, building_by_id, building_demands)
        
        if antenna:
            antennas.append(antenna)
            covered.update(antenna['buildings'])
    
    return antennas


def create_antenna_for_buildings(x: int, y: int, candidate_ids: List[int],
                                 buildings: List[dict], building_by_id: Dict[int, dict],
                                 building_demands: Dict[int, int]) -> Optional[dict]:
    """Create best antenna for given location and candidate buildings."""
    
    if not candidate_ids:
        return None
    
    best_antenna = None
    best_assignment = []
    best_score = -1
    
    for antenna_type in ANTENNA_TYPES_BY_CAPACITY:
        antenna_spec = ANTENNA_TYPES[antenna_type]
        antenna_range = antenna_spec['range']
        antenna_capacity = antenna_spec['capacity']
        
        # Find buildings within range
        in_range = []
        for bid in candidate_ids:
            b = building_by_id[bid]
            if is_in_range(x, y, b['x'], b['y'], antenna_range):
                in_range.append(bid)
        
        if not in_range:
            continue
        
        # Sort by demand
        in_range.sort(key=lambda bid: building_demands[bid], reverse=True)
        
        # Pack buildings into antenna
        assignment = []
        total_peak = 0
        total_off_peak = 0
        total_night = 0
        
        for bid in in_range:
            b = building_by_id[bid]
            new_peak = total_peak + b['populationPeakHours']
            new_off_peak = total_off_peak + b['populationOffPeakHours']
            new_night = total_night + b['populationNight']
            new_max = max(new_peak, new_off_peak, new_night)
            
            if new_max <= antenna_capacity:
                assignment.append(bid)
                total_peak = new_peak
                total_off_peak = new_off_peak
                total_night = new_night
        
        if assignment:
            # Score: prioritize covering more buildings with cheaper antennas
            score = len(assignment) * 1000 - antenna_spec['cost']
            
            if score > best_score:
                best_score = score
                best_antenna = antenna_type
                best_assignment = assignment
    
    if best_antenna:
        return {
            'type': best_antenna,
            'x': x,
            'y': y,
            'buildings': best_assignment
        }
    
    return None


def find_nearby_uncovered(x: int, y: int, buildings: List[dict], covered: Set[int],
                          building_by_id: Dict[int, dict], max_range: int = 2000) -> List[int]:
    """Find uncovered buildings within range."""
    nearby = []
    
    for b in buildings:
        bid = b['id']
        if bid not in covered:
            if is_in_range(x, y, b['x'], b['y'], max_range):
                nearby.append(bid)
    
    return nearby


def local_search_refinement(antennas: List[dict], buildings: List[dict],
                            building_by_id: Dict[int, dict],
                            building_demands: Dict[int, int],
                            rng: random.Random) -> List[dict]:
    """Perform local search to improve solution."""
    
    improved = True
    iterations = 0
    max_iterations = 10
    
    while improved and iterations < max_iterations:
        improved = False
        iterations += 1
        
        # Try to merge antennas
        antennas = try_merge_antennas(antennas, buildings, building_by_id, building_demands)
        
        # Try to swap buildings between antennas
        swapped = try_swap_buildings(antennas, buildings, building_by_id, building_demands, rng)
        
        if swapped:
            improved = True
    
    return antennas


def try_merge_antennas(antennas: List[dict], buildings: List[dict],
                      building_by_id: Dict[int, dict],
                      building_demands: Dict[int, int]) -> List[dict]:
    """Try to merge nearby antennas to reduce total count."""
    
    merged = []
    used = set()
    
    for i, ant1 in enumerate(antennas):
        if i in used:
            continue
        
        # Try to merge with nearby antennas
        merge_candidates = []
        
        for j, ant2 in enumerate(antennas):
            if i != j and j not in used:
                dist = distance(ant1['x'], ant1['y'], ant2['x'], ant2['y'])
                if dist < 1500:  # Close enough to consider merging
                    merge_candidates.append(j)
        
        if merge_candidates:
            # Try to merge all buildings
            all_buildings = ant1['buildings'][:]
            for j in merge_candidates:
                all_buildings.extend(antennas[j]['buildings'])
            
            # Try to fit in one antenna
            antenna = create_antenna_for_buildings(ant1['x'], ant1['y'], all_buildings,
                                                   buildings, building_by_id, building_demands)
            
            if antenna and len(antenna['buildings']) == len(all_buildings):
                # Successful merge
                merged.append(antenna)
                used.add(i)
                used.update(merge_candidates)
                continue
        
        # No merge possible
        merged.append(ant1)
        used.add(i)
    
    return merged


def try_swap_buildings(antennas: List[dict], buildings: List[dict],
                      building_by_id: Dict[int, dict],
                      building_demands: Dict[int, int],
                      rng: random.Random) -> bool:
    """Try to swap buildings between antennas for better efficiency."""
    
    # Simple implementation: try a few random swaps
    for _ in range(min(20, len(antennas))):
        if len(antennas) < 2:
            break
        
        i, j = rng.sample(range(len(antennas)), 2)
        ant1, ant2 = antennas[i], antennas[j]
        
        if not ant1['buildings'] or not ant2['buildings']:
            continue
        
        # Try swapping one building
        # (placeholder - full implementation would be more sophisticated)
        
    return False


def ruin_and_recreate(antennas: List[dict], buildings: List[dict],
                     building_by_id: Dict[int, dict],
                     building_demands: Dict[int, int],
                     rng: random.Random, iterations: int = 5) -> List[dict]:
    """Ruin and recreate parts of the solution to escape local optima."""
    
    best_solution = antennas[:]
    best_cost = calculate_cost(best_solution, building_by_id)
    
    for _ in range(iterations):
        # Ruin: remove random subset of antennas
        num_remove = max(1, len(antennas) // 10)
        to_remove = set(rng.sample(range(len(antennas)), min(num_remove, len(antennas))))
        
        kept_antennas = [ant for i, ant in enumerate(antennas) if i not in to_remove]
        
        # Track which buildings are still covered
        covered = set()
        for ant in kept_antennas:
            covered.update(ant['buildings'])
        
        # Recreate: cover uncovered buildings
        all_ids = {b['id'] for b in buildings}
        uncovered = list(all_ids - covered)
        
        if not uncovered:
            continue
        
        # Sort uncovered by demand
        uncovered.sort(key=lambda bid: building_demands[bid], reverse=True)
        
        new_antennas = kept_antennas[:]
        
        for bid in uncovered:
            if bid in covered:
                continue
            
            b = building_by_id[bid]
            nearby = find_nearby_uncovered(b['x'], b['y'], buildings, covered,
                                          building_by_id, max_range=2000)
            
            antenna = create_antenna_for_buildings(b['x'], b['y'], nearby,
                                                   buildings, building_by_id, building_demands)
            
            if antenna:
                new_antennas.append(antenna)
                covered.update(antenna['buildings'])
        
        # Check if better
        new_cost = calculate_cost(new_antennas, building_by_id)
        if new_cost < best_cost:
            best_cost = new_cost
            best_solution = new_antennas
    
    return best_solution


def calculate_cost(antennas: List[dict], building_by_id: Dict[int, dict]) -> int:
    """Calculate total cost of antenna solution."""
    total_cost = 0
    
    for ant in antennas:
        antenna_spec = ANTENNA_TYPES[ant['type']]
        base_cost = antenna_spec['cost']
        
        # Check if on building for discount
        on_building = False
        for bid in ant['buildings']:
            b = building_by_id[bid]
            if b['x'] == ant['x'] and b['y'] == ant['y']:
                on_building = True
                break
        
        cost = base_cost if on_building else base_cost * 2
        total_cost += cost
    
    return total_cost


def kmeans_clustering(buildings: List[dict], k: int, rng: random.Random) -> List[List[int]]:
    """Simple k-means clustering for buildings."""
    
    if len(buildings) <= k:
        return [[b['id']] for b in buildings]
    
    # Initialize centroids randomly
    centroids = rng.sample(buildings, k)
    centroid_coords = [(c['x'], c['y']) for c in centroids]
    
    # Run k-means for a few iterations
    for _ in range(10):
        # Assign buildings to nearest centroid
        clusters = [[] for _ in range(k)]
        
        for b in buildings:
            min_dist = float('inf')
            min_idx = 0
            
            for i, (cx, cy) in enumerate(centroid_coords):
                dist = distance(b['x'], b['y'], cx, cy)
                if dist < min_dist:
                    min_dist = dist
                    min_idx = i
            
            clusters[min_idx].append(b['id'])
        
        # Update centroids
        new_centroids = []
        for cluster_ids in clusters:
            if not cluster_ids:
                # Keep old centroid
                continue
            
            sum_x = sum(buildings[bid]['x'] for bid in cluster_ids if bid < len(buildings))
            sum_y = sum(buildings[bid]['y'] for bid in cluster_ids if bid < len(buildings))
            
            # Handle building ID lookup
            cluster_buildings = [b for b in buildings if b['id'] in cluster_ids]
            if cluster_buildings:
                sum_x = sum(b['x'] for b in cluster_buildings)
                sum_y = sum(b['y'] for b in cluster_buildings)
                new_centroids.append((sum_x // len(cluster_buildings), 
                                    sum_y // len(cluster_buildings)))
        
        if new_centroids:
            centroid_coords = new_centroids
    
    # Final assignment
    clusters = [[] for _ in range(len(centroid_coords))]
    
    for b in buildings:
        min_dist = float('inf')
        min_idx = 0
        
        for i, (cx, cy) in enumerate(centroid_coords):
            dist = distance(b['x'], b['y'], cx, cy)
            if dist < min_dist:
                min_dist = dist
                min_idx = i
        
        clusters[min_idx].append(b['id'])
    
    return [c for c in clusters if c]