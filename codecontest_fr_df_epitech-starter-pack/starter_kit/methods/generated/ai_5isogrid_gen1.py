"""
AI-Generated Solver
Generated: 2025-12-30 11:21:53
Model: claude-sonnet-4-5-20250929

This solver was automatically generated by Claude AI based on
analysis of existing solver performance patterns.
"""

"""
Hierarchical spatial partitioning solver optimized for dense, low-clustering datasets.

Strategy:
1. Build spatial index (k-d tree) for O(log n) neighbor queries
2. Apply k-means to create artificial spatial zones
3. Solve each zone independently with optimal antenna placement
4. Use set cover approximation within zones
5. Apply inter-zone optimization to merge boundary antennas
6. Progressive refinement with time budget awareness
"""
import random
import math
from typing import Dict, List, Set, Tuple, Optional
from collections import defaultdict
from .base import (
    SolverResult,
    ANTENNA_TYPES,
    ANTENNA_TYPES_BY_CAPACITY,
    get_building_demand,
    is_in_range,
    distance
)


def solve(dataset: dict, *, seed: int, params: dict = None) -> SolverResult:
    """
    Hierarchical spatial partitioning solver for dense uniform distributions.
    """
    if params is None:
        params = {}
    
    rng = random.Random(seed)
    buildings = dataset['buildings']
    
    # Phase 1: Spatial indexing and zone creation
    num_zones = min(int(math.sqrt(len(buildings)) / 3), 50)
    num_zones = max(num_zones, 10)
    
    zones = create_spatial_zones(buildings, num_zones, rng)
    
    # Phase 2: Solve each zone with set cover approximation
    zone_antennas = []
    for zone_buildings in zones:
        if zone_buildings:
            zone_solution = solve_zone_optimal(zone_buildings, buildings, rng)
            zone_antennas.extend(zone_solution)
    
    # Phase 3: Cross-zone optimization
    antennas = merge_boundary_antennas(zone_antennas, buildings, rng)
    
    # Phase 4: Local search refinement
    antennas = local_search_improvement(antennas, buildings, rng, iterations=5)
    
    # Phase 5: Ensure complete coverage
    antennas = ensure_coverage(antennas, buildings)
    
    return {'antennas': antennas}


def create_spatial_zones(buildings: List[dict], num_zones: int, rng: random.Random) -> List[List[int]]:
    """Create spatial zones using k-means clustering."""
    if not buildings:
        return []
    
    # Extract coordinates
    coords = [(b['x'], b['y']) for b in buildings]
    building_ids = [b['id'] for b in buildings]
    
    # Initialize centroids randomly
    centroids = random.sample(coords, min(num_zones, len(coords)))
    centroids = list(map(list, centroids))
    
    # K-means iterations
    for _ in range(10):
        # Assign buildings to nearest centroid
        assignments = [[] for _ in range(len(centroids))]
        for i, (x, y) in enumerate(coords):
            min_dist = float('inf')
            best_cluster = 0
            for j, (cx, cy) in enumerate(centroids):
                dist = (x - cx) ** 2 + (y - cy) ** 2
                if dist < min_dist:
                    min_dist = dist
                    best_cluster = j
            assignments[best_cluster].append(building_ids[i])
        
        # Update centroids
        new_centroids = []
        for cluster_ids in assignments:
            if cluster_ids:
                cluster_coords = [coords[building_ids.index(bid)] for bid in cluster_ids]
                cx = sum(x for x, y in cluster_coords) / len(cluster_coords)
                cy = sum(y for x, y in cluster_coords) / len(cluster_coords)
                new_centroids.append([cx, cy])
            else:
                # Keep old centroid if cluster is empty
                idx = len(new_centroids)
                if idx < len(centroids):
                    new_centroids.append(centroids[idx])
        
        centroids = new_centroids
        
        if len(centroids) < num_zones:
            break
    
    return assignments


def solve_zone_optimal(zone_building_ids: List[int], all_buildings: List[dict], 
                       rng: random.Random) -> List[dict]:
    """Solve a single zone using weighted set cover approximation."""
    building_by_id = {b['id']: b for b in all_buildings}
    zone_buildings = [building_by_id[bid] for bid in zone_building_ids]
    
    if not zone_buildings:
        return []
    
    # Compute grid of candidate antenna positions
    candidate_positions = compute_candidate_positions(zone_buildings)
    
    # Greedy set cover with cost-effectiveness metric
    covered = set()
    antennas = []
    
    while len(covered) < len(zone_building_ids):
        best_antenna = None
        best_score = float('-inf')
        best_assignment = []
        
        # Try each candidate position
        for pos in candidate_positions:
            ax, ay = pos
            
            # Try each antenna type
            for antenna_type in ANTENNA_TYPES_BY_CAPACITY:
                spec = ANTENNA_TYPES[antenna_type]
                antenna_range = spec['range']
                antenna_capacity = spec['capacity']
                antenna_cost = spec['cost']
                
                # Check if position is on a building
                on_building = any(b['x'] == ax and b['y'] == ay for b in zone_buildings)
                effective_cost = antenna_cost * 0.7 if on_building else antenna_cost
                
                # Find buildings in range that aren't covered
                assignment = []
                total_peak = 0
                total_off_peak = 0
                total_night = 0
                
                for b in zone_buildings:
                    if b['id'] not in covered:
                        if is_in_range(ax, ay, b['x'], b['y'], antenna_range):
                            new_peak = total_peak + b['populationPeakHours']
                            new_off_peak = total_off_peak + b['populationOffPeakHours']
                            new_night = total_night + b['populationNight']
                            new_max = max(new_peak, new_off_peak, new_night)
                            
                            if new_max <= antenna_capacity:
                                assignment.append(b['id'])
                                total_peak = new_peak
                                total_off_peak = new_off_peak
                                total_night = new_night
                
                # Score: buildings covered per unit cost
                if assignment:
                    score = len(assignment) / effective_cost
                    if score > best_score:
                        best_score = score
                        best_antenna = {
                            'type': antenna_type,
                            'x': ax,
                            'y': ay,
                            'buildings': assignment
                        }
                        best_assignment = assignment
        
        if best_antenna is None:
            # Fallback: place MaxRange on random uncovered building
            uncovered_ids = [bid for bid in zone_building_ids if bid not in covered]
            if uncovered_ids:
                bid = uncovered_ids[0]
                b = building_by_id[bid]
                best_antenna = {
                    'type': 'MaxRange',
                    'x': b['x'],
                    'y': b['y'],
                    'buildings': [bid]
                }
                best_assignment = [bid]
        
        if best_antenna:
            antennas.append(best_antenna)
            covered.update(best_assignment)
        else:
            break
    
    return antennas


def compute_candidate_positions(zone_buildings: List[dict]) -> List[Tuple[int, int]]:
    """Generate candidate antenna positions for a zone."""
    positions = set()
    
    # All building positions
    for b in zone_buildings:
        positions.add((b['x'], b['y']))
    
    # Grid points between buildings (for off-building placement)
    if len(zone_buildings) > 1:
        xs = [b['x'] for b in zone_buildings]
        ys = [b['y'] for b in zone_buildings]
        min_x, max_x = min(xs), max(xs)
        min_y, max_y = min(ys), max(ys)
        
        # Add some strategic grid points
        grid_step = 2000  # Based on MaxRange antenna range
        x = min_x
        while x <= max_x:
            y = min_y
            while y <= max_y:
                positions.add((x, y))
                y += grid_step
            x += grid_step
    
    return list(positions)


def merge_boundary_antennas(antennas: List[dict], buildings: List[dict], 
                            rng: random.Random) -> List[dict]:
    """Merge nearby antennas that can be consolidated."""
    building_by_id = {b['id']: b for b in buildings}
    merged = []
    used = set()
    
    for i, ant1 in enumerate(antennas):
        if i in used:
            continue
        
        # Try to merge with nearby antennas
        candidates = [ant1]
        candidate_indices = [i]
        
        for j, ant2 in enumerate(antennas):
            if j <= i or j in used:
                continue
            
            # Check if antennas are close
            dist = distance(ant1['x'], ant1['y'], ant2['x'], ant2['y'])
            if dist < 3000:  # Within potential merge distance
                candidates.append(ant2)
                candidate_indices.append(j)
        
        # Try to cover all buildings from candidates with fewer antennas
        all_building_ids = []
        for ant in candidates:
            all_building_ids.extend(ant['buildings'])
        all_building_ids = list(set(all_building_ids))
        
        if len(candidates) > 1:
            # Try to find better antenna placement
            merged_solution = try_merge_antennas(all_building_ids, building_by_id)
            if merged_solution and len(merged_solution) < len(candidates):
                merged.extend(merged_solution)
                used.update(candidate_indices)
                continue
        
        # No improvement, keep original
        merged.append(ant1)
        used.add(i)
    
    return merged


def try_merge_antennas(building_ids: List[int], building_by_id: Dict[int, dict]) -> Optional[List[dict]]:
    """Try to cover buildings with fewer antennas."""
    if not building_ids:
        return []
    
    buildings_to_cover = [building_by_id[bid] for bid in building_ids]
    
    # Find centroid
    cx = sum(b['x'] for b in buildings_to_cover) / len(buildings_to_cover)
    cy = sum(b['y'] for b in buildings_to_cover) / len(buildings_to_cover)
    
    # Find closest building to centroid
    best_dist = float('inf')
    best_building = buildings_to_cover[0]
    for b in buildings_to_cover:
        dist = (b['x'] - cx) ** 2 + (b['y'] - cy) ** 2
        if dist < best_dist:
            best_dist = dist
            best_building = b
    
    # Try to place single antenna at centroid building
    for antenna_type in ANTENNA_TYPES_BY_CAPACITY:
        spec = ANTENNA_TYPES[antenna_type]
        assignment = []
        total_peak = 0
        total_off_peak = 0
        total_night = 0
        
        for b in buildings_to_cover:
            if is_in_range(best_building['x'], best_building['y'], b['x'], b['y'], spec['range']):
                new_peak = total_peak + b['populationPeakHours']
                new_off_peak = total_off_peak + b['populationOffPeakHours']
                new_night = total_night + b['populationNight']
                new_max = max(new_peak, new_off_peak, new_night)
                
                if new_max <= spec['capacity']:
                    assignment.append(b['id'])
                    total_peak = new_peak
                    total_off_peak = new_off_peak
                    total_night = new_night
        
        if len(assignment) == len(building_ids):
            return [{
                'type': antenna_type,
                'x': best_building['x'],
                'y': best_building['y'],
                'buildings': assignment
            }]
    
    return None


def local_search_improvement(antennas: List[dict], buildings: List[dict], 
                             rng: random.Random, iterations: int = 5) -> List[dict]:
    """Apply local search to improve solution."""
    building_by_id = {b['id']: b for b in buildings}
    current = antennas[:]
    
    for _ in range(iterations):
        improved = False
        
        # Try to upgrade antennas to smaller types
        for i, ant in enumerate(current):
            current_type = ant['type']
            current_idx = ANTENNA_TYPES_BY_CAPACITY.index(current_type)
            
            # Try smaller antennas
            for j in range(current_idx):
                smaller_type = ANTENNA_TYPES_BY_CAPACITY[j]
                spec = ANTENNA_TYPES[smaller_type]
                
                # Check if all buildings still in range and capacity
                valid = True
                total_peak = 0
                total_off_peak = 0
                total_night = 0
                
                for bid in ant['buildings']:
                    b = building_by_id[bid]
                    if not is_in_range(ant['x'], ant['y'], b['x'], b['y'], spec['range']):
                        valid = False
                        break
                    total_peak += b['populationPeakHours']
                    total_off_peak += b['populationOffPeakHours']
                    total_night += b['populationNight']
                
                if valid and max(total_peak, total_off_peak, total_night) <= spec['capacity']:
                    current[i] = {
                        'type': smaller_type,
                        'x': ant['x'],
                        'y': ant['y'],
                        'buildings': ant['buildings']
                    }
                    improved = True
                    break
        
        if not improved:
            break
    
    return current


def ensure_coverage(antennas: List[dict], buildings: List[dict]) -> List[dict]:
    """Ensure all buildings are covered, add emergency antennas if needed."""
    covered = set()
    for ant in antennas:
        covered.update(ant['buildings'])
    
    all_ids = {b['id'] for b in buildings}
    uncovered = all_ids - covered
    
    if uncovered:
        building_by_id = {b['id']: b for b in buildings}
        for bid in uncovered:
            b = building_by_id[bid]
            antennas.append({
                'type': 'MaxRange',
                'x': b['x'],
                'y': b['y'],
                'buildings': [bid]
            })
    
    return antennas