"""
AI-Generated Solver
Generated: 2025-12-29 22:31:52
Model: claude-sonnet-4-5-20250929

This solver was automatically generated by Claude AI based on
analysis of existing solver performance patterns.
"""

"""
Spatial Voronoi-based solver optimized for dense, low-clustering distributions.

Strategy:
1. Use k-d tree for efficient spatial queries
2. Generate initial antenna candidates using adaptive grid overlay
3. Use weighted Lloyd's algorithm to optimize antenna positions
4. Iteratively refine with demand-aware capacity balancing
5. Apply local search with 2-opt style improvements
6. Micro-optimize antenna positions to geometric centroids
7. Attempt antenna elimination and type downgrading passes
"""
import random
import math
from typing import Dict, List, Set, Tuple, Optional
from collections import defaultdict
from ..base import (
    SolverResult,
    ANTENNA_TYPES,
    ANTENNA_TYPES_BY_CAPACITY,
    get_building_demand,
    is_in_range,
    distance
)


class KDNode:
    """Simple KD-Tree node for 2D spatial indexing."""
    def __init__(self, point, building_id, left=None, right=None, axis=0):
        self.point = point
        self.building_id = building_id
        self.left = left
        self.right = right
        self.axis = axis


class KDTree:
    """KD-Tree for efficient nearest neighbor queries."""
    def __init__(self, buildings):
        points = [(b['x'], b['y'], b['id']) for b in buildings]
        self.root = self._build(points, 0)
    
    def _build(self, points, depth):
        if not points:
            return None
        
        axis = depth % 2
        points.sort(key=lambda p: p[axis])
        median = len(points) // 2
        
        return KDNode(
            point=(points[median][0], points[median][1]),
            building_id=points[median][2],
            left=self._build(points[:median], depth + 1),
            right=self._build(points[median + 1:], depth + 1),
            axis=axis
        )
    
    def query_radius(self, center, radius):
        """Find all buildings within radius of center."""
        result = []
        self._query_radius(self.root, center, radius, result)
        return result
    
    def _query_radius(self, node, center, radius, result):
        if node is None:
            return
        
        dist = distance(center[0], center[1], node.point[0], node.point[1])
        if dist <= radius:
            result.append(node.building_id)
        
        axis = node.axis
        diff = center[axis] - node.point[axis]
        
        if diff < 0:
            self._query_radius(node.left, center, radius, result)
            if abs(diff) <= radius:
                self._query_radius(node.right, center, radius, result)
        else:
            self._query_radius(node.right, center, radius, result)
            if abs(diff) <= radius:
                self._query_radius(node.left, center, radius, result)


def compute_weighted_centroid(buildings_subset, building_by_id):
    """Compute demand-weighted centroid of buildings."""
    if not buildings_subset:
        return None
    
    total_weight = 0
    weighted_x = 0
    weighted_y = 0
    
    for bid in buildings_subset:
        b = building_by_id[bid]
        weight = get_building_demand(b)
        weighted_x += b['x'] * weight
        weighted_y += b['y'] * weight
        total_weight += weight
    
    if total_weight == 0:
        b = building_by_id[buildings_subset[0]]
        return (b['x'], b['y'])
    
    return (int(weighted_x / total_weight), int(weighted_y / total_weight))


def get_capacity_usage(building_ids, building_by_id):
    """Calculate peak capacity usage for a set of buildings."""
    total_peak = 0
    total_off_peak = 0
    total_night = 0
    
    for bid in building_ids:
        b = building_by_id[bid]
        total_peak += b['populationPeakHours']
        total_off_peak += b['populationOffPeakHours']
        total_night += b['populationNight']
    
    return max(total_peak, total_off_peak, total_night)


def find_best_antenna_type(building_ids, building_by_id, antenna_x, antenna_y):
    """Find smallest antenna type that can cover given buildings."""
    capacity_needed = get_capacity_usage(building_ids, building_by_id)
    
    for antenna_type in ANTENNA_TYPES_BY_CAPACITY:
        spec = ANTENNA_TYPES[antenna_type]
        if spec['capacity'] >= capacity_needed:
            # Verify all buildings are in range
            all_in_range = True
            for bid in building_ids:
                b = building_by_id[bid]
                if not is_in_range(antenna_x, antenna_y, b['x'], b['y'], spec['range']):
                    all_in_range = False
                    break
            
            if all_in_range:
                return antenna_type
    
    return 'MaxRange'


def create_initial_grid_antennas(buildings, building_by_id, kdtree, rng):
    """Create initial antenna placement using adaptive grid."""
    if not buildings:
        return []
    
    # Find bounds
    min_x = min(b['x'] for b in buildings)
    max_x = max(b['x'] for b in buildings)
    min_y = min(b['y'] for b in buildings)
    max_y = max(b['y'] for b in buildings)
    
    # Use Spot antenna range for initial grid spacing
    base_range = ANTENNA_TYPES['Spot']['range']
    grid_spacing = int(base_range * 1.4)  # Overlap for better coverage
    
    antennas = []
    covered = set()
    
    # Generate grid points
    y = min_y
    while y <= max_y:
        x = min_x
        while x <= max_x:
            # Find buildings near this grid point
            candidates = kdtree.query_radius((x, y), base_range * 2)
            uncovered_candidates = [bid for bid in candidates if bid not in covered]
            
            if uncovered_candidates:
                # Compute weighted centroid of uncovered buildings
                centroid = compute_weighted_centroid(uncovered_candidates, building_by_id)
                if centroid:
                    ax, ay = centroid
                    
                    # Greedy assignment: find all buildings we can cover
                    for antenna_type in ['Spot', 'Density', 'MaxRange']:
                        spec = ANTENNA_TYPES[antenna_type]
                        nearby = kdtree.query_radius((ax, ay), spec['range'])
                        nearby_uncovered = [bid for bid in nearby if bid not in covered]
                        
                        # Pack buildings into this antenna
                        assignment = []
                        total_peak = 0
                        total_off_peak = 0
                        total_night = 0
                        
                        # Sort by demand descending
                        nearby_uncovered.sort(key=lambda bid: get_building_demand(building_by_id[bid]), reverse=True)
                        
                        for bid in nearby_uncovered:
                            b = building_by_id[bid]
                            new_peak = total_peak + b['populationPeakHours']
                            new_off_peak = total_off_peak + b['populationOffPeakHours']
                            new_night = total_night + b['populationNight']
                            
                            if max(new_peak, new_off_peak, new_night) <= spec['capacity']:
                                assignment.append(bid)
                                total_peak = new_peak
                                total_off_peak = new_off_peak
                                total_night = new_night
                        
                        if assignment:
                            antennas.append({
                                'type': antenna_type,
                                'x': ax,
                                'y': ay,
                                'buildings': assignment
                            })
                            covered.update(assignment)
                            break
            
            x += grid_spacing
        y += grid_spacing
    
    return antennas, covered


def lloyd_iteration(antennas, building_by_id, kdtree):
    """Perform one Lloyd's algorithm iteration to improve antenna positions."""
    new_antennas = []
    
    for antenna in antennas:
        if not antenna['buildings']:
            continue
        
        # Compute weighted centroid
        centroid = compute_weighted_centroid(antenna['buildings'], building_by_id)
        if centroid is None:
            new_antennas.append(antenna)
            continue
        
        new_x, new_y = centroid
        
        # Verify all buildings still in range
        spec = ANTENNA_TYPES[antenna['type']]
        all_in_range = True
        for bid in antenna['buildings']:
            b = building_by_id[bid]
            if not is_in_range(new_x, new_y, b['x'], b['y'], spec['range']):
                all_in_range = False
                break
        
        if all_in_range:
            new_antennas.append({
                'type': antenna['type'],
                'x': new_x,
                'y': new_y,
                'buildings': antenna['buildings']
            })
        else:
            new_antennas.append(antenna)
    
    return new_antennas


def reassign_buildings(antennas, building_by_id, kdtree):
    """Reassign buildings to nearest suitable antenna."""
    # Create antenna index
    antenna_positions = []
    for idx, ant in enumerate(antennas):
        antenna_positions.append((ant['x'], ant['y'], idx))
    
    # Clear existing assignments
    for ant in antennas:
        ant['buildings'] = []
    
    # Reassign each building to nearest compatible antenna
    all_building_ids = set(building_by_id.keys())
    
    for bid in all_building_ids:
        b = building_by_id[bid]
        
        # Find nearest antenna that can accommodate this building
        best_antenna_idx = None
        best_distance = float('inf')
        
        for idx, ant in enumerate(antennas):
            spec = ANTENNA_TYPES[ant['type']]
            dist = distance(ant['x'], ant['y'], b['x'], b['y'])
            
            if dist <= spec['range'] and dist < best_distance:
                # Check capacity
                current_usage = get_capacity_usage(ant['buildings'], building_by_id)
                b_demand = get_building_demand(b)
                
                if current_usage + b_demand <= spec['capacity']:
                    best_antenna_idx = idx
                    best_distance = dist
        
        if best_antenna_idx is not None:
            antennas[best_antenna_idx]['buildings'].append(bid)
    
    # Remove empty antennas
    return [ant for ant in antennas if ant['buildings']]


def try_merge_antennas(antennas, building_by_id):
    """Attempt to merge nearby antennas to reduce cost."""
    merged = True
    while merged:
        merged = False
        i = 0
        while i < len(antennas):
            j = i + 1
            while j < len(antennas):
                ant1 = antennas[i]
                ant2 = antennas[j]
                
                # Try to merge into a single antenna
                combined_buildings = ant1['buildings'] + ant2['buildings']
                centroid = compute_weighted_centroid(combined_buildings, building_by_id)
                
                if centroid:
                    cx, cy = centroid
                    antenna_type = find_best_antenna_type(combined_buildings, building_by_id, cx, cy)
                    spec = ANTENNA_TYPES[antenna_type]
                    
                    # Verify all buildings in range
                    all_in_range = all(
                        is_in_range(cx, cy, building_by_id[bid]['x'], building_by_id[bid]['y'], spec['range'])
                        for bid in combined_buildings
                    )
                    
                    if all_in_range:
                        # Merge successful
                        antennas[i] = {
                            'type': antenna_type,
                            'x': cx,
                            'y': cy,
                            'buildings': combined_buildings
                        }
                        antennas.pop(j)
                        merged = True
                        break
                
                j += 1
            
            if merged:
                break
            i += 1
    
    return antennas


def try_downgrade_antennas(antennas, building_by_id):
    """Try to downgrade antenna types to cheaper alternatives."""
    for ant in antennas:
        current_type = ant['type']
        
        # Try each antenna type from smallest to current
        for antenna_type in ANTENNA_TYPES_BY_CAPACITY:
            if antenna_type == current_type:
                break
            
            spec = ANTENNA_TYPES[antenna_type]
            capacity_needed = get_capacity_usage(ant['buildings'], building_by_id)
            
            if capacity_needed <= spec['capacity']:
                # Check range
                all_in_range = all(
                    is_in_range(ant['x'], ant['y'], building_by_id[bid]['x'], building_by_id[bid]['y'], spec['range'])
                    for bid in ant['buildings']
                )
                
                if all_in_range:
                    ant['type'] = antenna_type
                    break
    
    return antennas


def solve(dataset: dict, *, seed: int, params: dict = None) -> SolverResult:
    """
    Voronoi-based solver optimized for dense, low-clustering distributions.
    """
    if params is None:
        params = {}
    
    rng = random.Random(seed)
    buildings = dataset['buildings']
    
    if not buildings:
        return {'antennas': []}
    
    # Build spatial index
    building_by_id = {b['id']: b for b in buildings}
    kdtree = KDTree(buildings)
    
    # Phase 1: Create initial grid-based antenna placement
    antennas, covered = create_initial_grid_antennas(buildings, building_by_id, kdtree, rng)
    
    # Phase 2: Cover any remaining buildings
    all_building_ids = set(building_by_id.keys())
    uncovered = all_building_ids - covered
    
    for bid in uncovered:
        b = building_by_id[bid]
        # Try to find nearest existing antenna that can take it
        assigned = False
        
        for ant in antennas:
            spec = ANTENNA_TYPES[ant['type']]
            if is_in_range(ant['x'], ant['y'], b['x'], b['y'], spec['range']):
                current_usage = get_capacity_usage(ant['buildings'], building_by_id)
                b_demand = get_building_demand(b)
                
                if current_usage + b_demand <= spec['capacity']:
                    ant['buildings'].append(bid)
                    assigned = True
                    break
        
        if not assigned:
            # Create new antenna for this building
            antennas.append({
                'type': 'MaxRange',
                'x': b['x'],
                'y': b['y'],
                'buildings': [bid]
            })
    
    # Phase 3: Lloyd's algorithm iterations for position optimization
    for _ in range(3):
        antennas = lloyd_iteration(antennas, building_by_id, kdtree)
    
    # Phase 4: Reassign buildings to optimize coverage
    antennas = reassign_buildings(antennas, building_by_id, kdtree)
    
    # Phase 5: Cover any buildings that got lost in reassignment
    covered = set()
    for ant in antennas:
        covered.update(ant['buildings'])
    
    uncovered = all_building_ids - covered
    for bid in uncovered:
        b = building_by_id[bid]
        antennas.append({
            'type': 'MaxRange',
            'x': b['x'],
            'y': b['y'],
            'buildings': [bid]
        })
    
    # Phase 6: Merge nearby antennas
    antennas = try_merge_antennas(antennas, building_by_id)
    
    # Phase 7: Downgrade antenna types where possible
    antennas = try_downgrade_antennas(antennas, building_by_id)
    
    # Final validation and cleanup
    covered = set()
    for ant in antennas:
        covered.update(ant['buildings'])
    
    uncovered = all_building_ids - covered
    for bid in uncovered:
        b = building_by_id[bid]
        antennas.append({
            'type': 'MaxRange',
            'x': b['x'],
            'y': b['y'],
            'buildings': [bid]
        })
    
    return {'antennas': antennas}